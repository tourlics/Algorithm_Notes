<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/"><channel><title>博客园-icodes</title><link>https://www.cnblogs.com/icodes8238/</link><description /><language>zh-cn</language><lastBuildDate>Thu, 06 Aug 2020 16:10:01 GMT</lastBuildDate><pubDate>Thu, 06 Aug 2020 16:10:01 GMT</pubDate><ttl>60</ttl><item><title>回溯法</title><link>http://www.cnblogs.com/icodes8238/archive/2020/05/15/12893640.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Fri, 15 May 2020 03:00:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/05/15/12893640.html</guid><description><![CDATA[<p>回溯法</p>
<p>1、基本概念与关键理解</p>
<p>（1）回溯法在问题的解空间树中,按深度优先策略,从根结点出发搜索解空间树。算法搜索至解空间树的任意一点时,先判断该结点是否包含问题的解。如果肯定不包含,则跳过对该结点为根的子树的搜索,逐层向其祖先结点回溯;否则,进入该子树,继续按深度优先策略搜索。</p>
<p>（2）回溯法的基本做法是<span style="text-decoration: underline;"><strong>搜索</strong></span>：或是一种组织得井井有条的，能避免不必要搜索的<span style="text-decoration: underline;"><strong>穷举式搜索法</strong></span>。</p>
<p>搜索是算法设计的一大核心，搜索最简单的做法就是穷举。分治法、动态规划、回溯法、分支限界法等等都可以看作对穷举的&ldquo;优化&rdquo;，这些算法本质上都是在考虑如何有&ldquo;规律&rdquo;的组织每一次&ldquo;随机&rdquo;。</p>
<p>（3）问题的解向量：回溯法希望一个问题的解能够表示成一个n元式（x1，X2，&hellip;，xm)的形式。<br />显约束：对分量x；的取值限定。<br />隐约束：为满足问题的解而对不同分量之间施加的约束。<br />解空间：对于问题的一个实例，解向量满足显式约束条件的所有多元组，构成了该实例的一个解空间。</p>
<p>（4）回溯法的重点与难点在于剪枝函数的设计。</p>
<p>常用剪枝函数有约束函数、限界函数。<span style="text-decoration: underline;"><strong>用约束函数在扩展结点处剪去不满足约束的子树;&nbsp;用限界函数剪去得不到最优解的子树</strong></span></p>
<p>2、基于递归的回溯法伪代码模板</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">void</span> backtrack(<span style="color: #0000ff;">int</span> t){ <span style="color: #008000;">//</span><span style="color: #008000;">t为递归深度 </span>
    <span style="color: #0000ff;">if</span>(t &gt; n) output(x); <span style="color: #008000;">//</span><span style="color: #008000;">已经搜索到叶节点 </span>
    <span style="color: #0000ff;">else</span><span style="color: #000000;">{
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=f(n,t); i&lt;=g(n,t); i++<span style="color: #000000;">){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">f(n,t)、g(n,t)分别表示在当前扩展结点处未搜索过的子树的起始编号和终止编号</span>
            x[t] = h(i);<span style="color: #008000;">//</span><span style="color: #008000;">h(i)表示当前扩展结点处x[t]的第i个可选值 </span>
            <span style="color: #0000ff;">if</span>(constraint(t) &amp;&amp;<span style="color: #000000;"> bound(t))
                backtrack(t</span>+<span style="color: #800080;">1</span><span style="color: #000000;">);
        }
    }
}</span></pre>
</div>
<p>3、子集树、排列树</p>
<p>子集树:当所给的问题是从n个元素的集合S中找出S满足某种性质的子树时,相应的解空间树称为子集树。&nbsp;<br />        例如:0-1背包问题所对应的解空间是一颗子集树,这类子集树通常有2n个叶子结点,其结点总数为2n+1-1,遍历子集树 需要&Omega;(2n)</p>
<p>排列树：当所给问题是确定n个元素满足某种性质的排列时，相应的解空间树称为排列树。排列树通常有n！个叶子结点，因此遍历排列树的需要2(n!)。<br />        例如：旅行商问题的解空间是一颗排列树。</p>
<p>排列树的伪代码：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">void</span> backtrack (<span style="color: #0000ff;">int</span><span style="color: #000000;"> t){
    </span><span style="color: #0000ff;">if</span> (t&gt;<span style="color: #000000;">n) output(x);
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i=t;i&lt;=n;i++<span style="color: #000000;">){
            swap(x[t],x[i]);
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(legal(t)) 
                backtrack(t</span>+<span style="color: #800080;">1</span><span style="color: #000000;">);  
            swap(x[t],x[i]);
        }
    }
}</span></pre>
</div>
<p>4、装载问题</p>
<p>问题描述：有一批共n个集装箱要装上2艘载重量分别为c1和c2的轮船,其 中集装箱i的重量为,且: n个集装箱重量之和小于c1+c2.装载问题要求确定是否有一个合理的装载方案可将这n个集装 箱装上这2艘轮船。如果有,找出一种装载方案。</p>
<p>代码及解释如下：</p>
<div class="cnblogs_code">
<pre>#include&lt;stdio.h&gt;
<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> MAXN = <span style="color: #800080;">100</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,c,cw,r,bestw,w[MAXN],x[MAXN];
</span><span style="color: #008000;">/*</span><span style="color: #008000;">---------
n为集装箱数量 
c为第一艘船的最大容量 
cw为当前已装入第一艘船的重量 
r为剩余未装入第一艘船的重量 
bestw为目前为止最好的装载方案其对应的重量 
w[i]集装箱i的重量 
x[i]集装箱i是否装入第一艘船 
</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">void</span> backtrack(<span style="color: #0000ff;">int</span><span style="color: #000000;"> i){
    </span><span style="color: #0000ff;">if</span>(i &gt; n){ <span style="color: #008000;">//</span><span style="color: #008000;">reach the leaves</span>
        <span style="color: #0000ff;">if</span>(cw &gt; bestw) bestw =<span style="color: #000000;"> cw;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    }
    r </span>-=<span style="color: #000000;"> w[i];
    </span><span style="color: #0000ff;">if</span>(cw + w[i] &lt;= c){<span style="color: #008000;">//</span><span style="color: #008000;">constraint function for searching left</span>
        x[i] = <span style="color: #800080;">1</span><span style="color: #000000;">;
        cw </span>+=<span style="color: #000000;"> w[i];
        backtrack(i</span>+<span style="color: #800080;">1</span><span style="color: #000000;">);
        cw </span>-=<span style="color: #000000;"> w[i];
    }
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">-------- 
    关键在于理解下面这个限界函数，目的是剪去得不到最优解的子树。
    这个时候我们正在处理树的第i层，即正在决定第i个集装箱是否装入
    如果说上面的约束函数是对左子树（装入i）的情况剪枝，那么该函数就是对右子树剪枝。 
    
    对该函数的理解：如果我把集装箱i抛弃掉，这个时候
    如果已经装入的重量+未装入的重量比目前的最优解bestw还要差，
    那么说明这种情况不可能得到最优解 
    也就是说如果把不装入集装箱i，肯定的不到最优解，后面的情况不用考虑了
    
    而如果当前载重量cw + 剩余集装箱的重量r&gt;当前最优载重量 best，
    那么我们就要去尝试不装入它，因为有可能得到最优解 
    </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">if</span>(cw + r &gt; bestw){ <span style="color: #008000;">//</span><span style="color: #008000;">bounding function for searching right</span>
        x[i] = <span style="color: #800080;">0</span><span style="color: #000000;">;
        backtrack(i</span>+<span style="color: #800080;">1</span><span style="color: #000000;">);
    }
    r </span>+=<span style="color: #000000;"> w[i];
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d</span><span style="color: #800000;">"</span>,&amp;n,&amp;<span style="color: #000000;">c);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">w[i]);
        r </span>+= w[i]; <span style="color: #008000;">//</span><span style="color: #008000;">r初始化为所有集装箱重量之和 </span>
<span style="color: #000000;">    } 
    backtrack(</span><span style="color: #800080;">1</span><span style="color: #000000;">);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,bestw);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">) 
        </span><span style="color: #0000ff;">if</span>(x[i] == <span style="color: #800080;">1</span><span style="color: #000000;">) 
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span><span style="color: #000000;">,i);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}
</span><span style="color: #008000;">/*</span><span style="color: #008000;">---TEST-----
5 16
2 1 8 4 2
</span><span style="color: #008000;">*/</span>   </pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>从矩阵连乘计算次序问题引出动态规划</title><link>http://www.cnblogs.com/icodes8238/archive/2020/04/09/12666779.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Thu, 09 Apr 2020 06:33:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/04/09/12666779.html</guid><description><![CDATA[<p style="text-align: center;"><span style="font-size: 18px;"><strong>从矩阵连乘计算次序问题引出动态规划</strong></span></p>
<p><span style="font-size: 16px;"><strong>问题描述</strong>：</span></p>
<p>　　给定n个矩阵：A1,A2,...,An，其中A<sub>i</sub>与A<sub>i+1</sub>是可乘的，i=1,2,&hellip;,n-1。确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的乘法（数乘）次数最少。</p>
<p>　　例如：有四个矩阵A：50x10；B：10x40；C：40x30；D：30x50，总共有五种加括号的方式：(A((BC)D))， (A(B(CD)))， ((AB)(CD))， (((AB)C)D)， ((A(BC))D)，所需乘运算的次数分别为16000，10500，36000，87500，34500，因此，计算矩阵连乘积需要乘法次数最少的方式是(A(B(CD)))</p>
<p><span style="font-size: 16px;"><strong>思路引导：</strong><span style="font-size: 14px;">（根据SCU左老师课堂笔记整理）</span></span></p>
<p>我们约定<strong>C(i，j)表示A<sub>i</sub>*A<sub>i+1</sub>*&hellip;*A<sub>j</sub>中数乘次数</strong>；<strong>P<sub>i</sub>表示第i个矩阵的行数，根据矩阵乘法相容性原则，<strong>P<sub>i+1</sub>表示第i个矩阵的列数（即第i+1个矩阵的行数）</strong></strong></p>
<p>1、对于给定的一个矩阵连乘问题，我们有很多中加括号的&ldquo;分解&rdquo;方法，所有的分类方法用数学符号表示为</p>
<p style="text-align: center;"><strong>C(i，j) = C(i,k) + C(k+1,j)+P<sub>i</sub>*P<sub>k+1</sub>*P<sub>j+1</sub>&nbsp;</strong>（k从i（包括）遍历到j（不包括））</p>
<p>对这个公式的理解：</p>
<p>　　a)为什么要加上P<sub>i</sub>*P<sub>k+1</sub>*P<sub>j+1</sub>&nbsp;？因为我们把C(i，j) 分成C(i,k)和C(k+1,j)两个矩阵后，这两个矩阵还要做一次乘法，那么这次乘法（数乘）次数为多少呢？相当于矩阵乘法AxB，其中A就是&nbsp;C(i,k)的结果，所以size(A) = [第i个矩阵的行数，第j个矩阵的列数] = [P<sub>i</sub>,P<sub>k+1</sub>]；同理，size(B) =&nbsp;[P<sub>k+1</sub>,P<sub>j+1</sub>]，因此AxB需要P<sub>i</sub>*P<sub>k+1</sub>*P<sub>j+1</sub>&nbsp;次乘法运算。</p>
<p>　　b)这里我们和分治法做一个比较：分治法中每种&ldquo;分解&rdquo;方案得到的结果都一样，而此处显然每种&ldquo;分解&rdquo;方案得到的结果不一样，这里的结果指的是乘法运算次数。</p>
<p>2、而这么多的分解方案中，我们只需要最优的，所以应该写成C(i，j) =min{C(i,k) + C(k+1,j)&nbsp;+P<sub>i</sub>*P<sub>k+1</sub>*P<sub>j+1</sub>&nbsp;&nbsp;，k&gt;=i &amp;&amp; k&lt;j}；</p>
<p>3、还存在一个问题：原问题最优解是否由子问题的最优解构成？因此我们引出<strong>最优子结构性质（</strong><strong>无后向性）：原问题的最优解包含着子问题的最优解。</strong>在这个问题中，我们很容易用反证法证明这点。</p>
<p>4、我们发现上面的公式本质上反映着递归算法。但有一个不好的地方：子问题C(m,n)中有的<strong>被重复多次计算</strong>，这样导致计算效率低。这个问题称为<strong>重叠子问题</strong>。</p>
<p>解决办法1：记忆性。增加一个记忆矩阵，将每个子问题的最优解记录下来，后面计算某些问题需要用到这些子问题的结果时直接调用即可。</p>
<p>解决方法2：采用递推的方法。这个时候我们就要分析原问题与子问题之间的关系。我们根据第一步找到的递归式，<strong>自底向上</strong>来计算，这样使得每一步计算的时候，所需要的子问题的结果都在。对于矩阵连乘问题，具体计算过程见下面的※。</p>
<p>5、如果我们还想知道子问题的最优解是由哪个方案得到的（在这个问题中表现为括号怎么分的）？我们需要<strong>记录过程</strong>。具体方法为再加一个记忆矩阵。</p>
<p><strong>※ 矩阵连乘问题中，自底向上的过程具体是怎么实现的呢？</strong></p>
<p>由最开始给的递归公式，我们发现，要计算C(i，j)，要先知道C(i,k) 和 C(k+1,j) 的值。为了方便解释，我们把每一个子问题的结果用一张表（如下）来展现。根据C(i,j)所表示的意义，我们知道这张表只有右上角的元素是需要填写的，且主对角线上的元素为0.</p>
<table style="height: 177px; width: 326px;" border="0">
<tbody>
<tr>
<td>0&nbsp;&nbsp;</td>
<td>C(1,2)</td>
<td>C(1,3)</td>
<td>C(1,4)</td>
<td>C(1,5)</td>
<td>C(1,6)</td>
<td>C(1,7)</td>
<td>C(1,8)</td>
</tr>
<tr>
<td>-</td>
<td>0</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>C(2,8)</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>0</td>
<td>C(3,4)</td>
<td>C(3,5)</td>
<td>C(3,6)</td>
<td>&nbsp;</td>
<td>C(3,8)</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
<td>0</td>
<td>&nbsp;</td>
<td>C(4,6)</td>
<td>&nbsp;</td>
<td>C(4,8)</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>0</td>
<td>C(5,6)</td>
<td>&nbsp;</td>
<td>C(5,8)</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>0</td>
<td>&nbsp;</td>
<td>C(6,8)</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>0</td>
<td>C(7,8)</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>由于k&lt;j，所以我们先要知道表中某个点左边的子问题的解；由于k+1&gt;i，所以我们要先知道某个点下边子问题的解。</p>
<p>因此，递推方式1：从C(7,8)开始，从左往右、从下往上计算。例如顺序C(7,8)--&gt;C(6,7)--&gt;C(6,8)--&gt;C(5,6)--&gt;C(5,7)--&gt;.......--&gt;C(1,8);</p>
<p>递推方式2：从紧贴着主对角线的那一条斜线开始，往右上遍历。例如计算顺序C(7,8)--&gt;C(6,7)--&gt;C(5,6)--&gt;......--&gt;C(1,2)&nbsp; --&gt;c(6,8)--&gt;C(5,7)--&gt;C(4,6)--&gt;......--&gt;C(2,8)--&gt;C(1,7)--&gt;C(1,8).</p>
<p>（注意，从C(1,2)开始以这种方式遍历也行，如代码中就是这种方式）</p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;"><strong>总结（动态规划的基本步骤）</strong></span></p>
<p>1、找出最优解的性质，并刻画其结构特征（即用子问题的最优解表示原问题的最优解）</p>
<p>2、递归地定义最优值</p>
<p>3、以自底向上的方式计算出最优值</p>
<p>4、根据计算最优值时得到的信息，构造最优解。</p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;"><strong>代码实现（MATLAB）</strong></span></p>
<div class="cnblogs_code">
<pre>function [C,Reck] =<span style="color: #000000;"> Matr(A1,A2,A3,A4,A5,A6,A7,A8)
    para </span>= <span style="color: #800080;">8</span><span style="color: #000000;">;
    [p(</span><span style="color: #800080;">1</span>),col] =<span style="color: #000000;"> size(A1); 
    [p(</span><span style="color: #800080;">2</span>),col] =<span style="color: #000000;"> size(A2); 
    [p(</span><span style="color: #800080;">3</span>),col] =<span style="color: #000000;"> size(A3); 
    [p(</span><span style="color: #800080;">4</span>),col] =<span style="color: #000000;"> size(A4); 
    [p(</span><span style="color: #800080;">5</span>),col] =<span style="color: #000000;"> size(A5); 
    [p(</span><span style="color: #800080;">6</span>),col] =<span style="color: #000000;"> size(A6); 
    [p(</span><span style="color: #800080;">7</span>),col] =<span style="color: #000000;"> size(A7); 
    [p(</span><span style="color: #800080;">8</span>),p(<span style="color: #800080;">9</span>)] = size(A8); %<span style="color: #000000;">p(i)数组储存矩阵Ai的行数

    </span><span style="color: #0000ff;">for</span> i=<span style="color: #800080;">1</span><span style="color: #000000;">:para
        </span><span style="color: #0000ff;">for</span> j=<span style="color: #800080;">1</span><span style="color: #000000;">:para
            </span><span style="color: #0000ff;">if</span> i==<span style="color: #000000;">j
                C(i,j) </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> C(i,j) =<span style="color: #000000;"> Inf;
            end
        end
    end </span>%<span style="color: #000000;">初始化上面这张表
    Reck </span>= zeros(para,para) %<span style="color: #000000;">s表示子问题的最优解
    </span><span style="color: #0000ff;">for</span> dif = <span style="color: #800080;">1</span>:para-<span style="color: #800080;">1</span> %j-i = <span style="color: #800080;">1</span> : para-<span style="color: #800080;">1</span>
        <span style="color: #0000ff;">for</span> i = <span style="color: #800080;">1</span>:para-<span style="color: #000000;">dif
            j </span>= i+<span style="color: #000000;">dif;
            </span><span style="color: #0000ff;">for</span> k = i:j-<span style="color: #800080;">1</span><span style="color: #000000;">
                temp </span>= C(i,k)+C(k+<span style="color: #800080;">1</span>,j)+p(i)*p(k+<span style="color: #800080;">1</span>)*p(j+<span style="color: #800080;">1</span>);%<span style="color: #000000;">i,j与C(i,j)意义保持一致
                </span><span style="color: #0000ff;">if</span> temp &lt;<span style="color: #000000;"> C(i,j)
                    C(i,j) </span>=<span style="color: #000000;"> temp;
                    Reck(i,j) </span>=<span style="color: #000000;"> k;
                end
            end
        end
    end<br /></span></pre>
</div>
<p>main函数测试数据</p>
<div class="cnblogs_code">
<pre>A1 = rand(<span style="color: #800080;">50</span>,<span style="color: #800080;">10</span><span style="color: #000000;">);
A2 </span>= rand(<span style="color: #800080;">10</span>,<span style="color: #800080;">40</span><span style="color: #000000;">);
A3 </span>= rand(<span style="color: #800080;">40</span>,<span style="color: #800080;">30</span><span style="color: #000000;">);
A4 </span>= rand(<span style="color: #800080;">30</span>,<span style="color: #800080;">5</span><span style="color: #000000;">);
A5 </span>= rand(<span style="color: #800080;">5</span>,<span style="color: #800080;">25</span><span style="color: #000000;">);
A6 </span>= rand(<span style="color: #800080;">25</span>,<span style="color: #800080;">60</span><span style="color: #000000;">);
A7 </span>= rand(<span style="color: #800080;">60</span>,<span style="color: #800080;">40</span><span style="color: #000000;">);
A8 </span>= rand(<span style="color: #800080;">40</span>,<span style="color: #800080;">50</span><span style="color: #000000;">);
[C,Reck] </span>= Matr(A1,A2,A3,A4,A5,A6,A7,A8)</pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Google Colab 使用易错总结</title><link>http://www.cnblogs.com/icodes8238/archive/2020/04/05/12636186.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Sun, 05 Apr 2020 02:44:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/04/05/12636186.html</guid><description><![CDATA[#**<center>Google Colab 使用易错总结</center>**  
##正常步骤  
[以SiamFC++为例](https://blog.csdn.net/qq_30347421/article/details/104534297)  

##注意点   
###1.一定要注意先选取运行环境！！！否则后面的工作白做   
###2.在colab中使用命令需要注意对空格的转义  
```
!python /content/drive/My\ Drive/BertNer/BERT_NER.py 
``` 
###3.colab运行目录是/content/drive/My Drive  
要特别注意当前工作目录，使用以下命令进入当前目录
```
%cd /content/gdrive/My\ Drive/yourfilename
```   
###4.如何在colab上更改tensorflow版本  
查看当前版本  
```
!pip3 show tensorflow
```  
方法一：如果想将2.x版本（目前colab默认2.x）改成1.x （这种方式只能在1.x和2.x之间转换）  
```
%tensorflow_version 1.x
import tensorflow as tf
tf.__version__
```
方法二：同本地命令行
```
!pip uninstall tensorflow
!pip install tensorflow==1.11
```
注意：上面两种方法使用完成后，都要重启runtime，命令如下：
```
import os
os.kill(os.getpid(), 9)
```
###5.colab不能自己新建文件夹，所以保存成文件输出路径要注意去掉文件夹
```
#out = cv2.VideoWriter('./output/'+args["input"][43:57]+ "_" + args["class"] + '_output.avi', fourcc, 15, (w, h))

out = cv2.VideoWriter('./'+args["input"][43:57]+ "_" + args["class"] + '_output.avi', fourcc, 15, (w, h))
```
###6.Cannot connect to X server GOOGLE COLAB怎么办？  
[Cannot connect to X server GOOGLE COLAB](https://stackoverflow.com/questions/54577083/cannot-connect-to-x-server-google-colab)  
简而言之：注释掉所有输出（如cv.imshow等），转为保存成文件  
  
##其它易错点总结  
https://zhuanlan.zhihu.com/p/98210226  
https://www.jianshu.com/p/a42d69568966  
https://zhuanlan.zhihu.com/p/105647700
https://zhuanlan.zhihu.com/p/89311070?utm_source=wechat_session   
  
  
  
###如有错误欢迎指出（本文档持续更新）
]]></description></item><item><title>最短距离点对问题（几何中的分治法）</title><link>http://www.cnblogs.com/icodes8238/archive/2020/04/04/12630001.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Fri, 03 Apr 2020 16:25:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/04/04/12630001.html</guid><description><![CDATA[<p>一维：</p>
<p>1.找出点集的中位数m（最大的数和最小的数的平均值）；</p>
<p><em id="__mceDel">2.将点集分为小于m的数和大于m的数；</em></p>
<p><em id="__mceDel"><em id="__mceDel">3.左边和右边分别递归求得左边的最小值d1、右边的最小值d2；</em></em></p>
<p>4.记录左边的最大值和右边的最小值，两者之差绝对值为d3；</p>
<p>5.返回d1,d2,d3三者最小值。</p>
<p>分治法时间复杂度 T(n) = 2T(n/2) + O(n)；因此时间复杂度为O(nlogn).</p>
<p>代码实现：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('3c932ac8-79c7-44f2-b6ae-fa175394639c')"><img id="code_img_closed_3c932ac8-79c7-44f2-b6ae-fa175394639c" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_3c932ac8-79c7-44f2-b6ae-fa175394639c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('3c932ac8-79c7-44f2-b6ae-fa175394639c',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_3c932ac8-79c7-44f2-b6ae-fa175394639c" class="cnblogs_code_hide">
<pre>#include&lt;stdio.h&gt;
<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> MAXN = <span style="color: #800080;">1000000</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">double</span><span style="color: #000000;"> dot[MAXN];
</span><span style="color: #0000ff;">double</span> min3(<span style="color: #0000ff;">double</span> a,<span style="color: #0000ff;">double</span> b,<span style="color: #0000ff;">double</span> c){ <span style="color: #008000;">//</span><span style="color: #008000;">min among 3 numbers</span>
    <span style="color: #0000ff;">if</span>(c&lt;=a &amp;&amp; c&lt;=b) <span style="color: #0000ff;">return</span><span style="color: #000000;"> c;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(b&lt;=a &amp;&amp; b&lt;=c) <span style="color: #0000ff;">return</span><span style="color: #000000;"> b;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(a&lt;=b &amp;&amp; a&lt;=c) <span style="color: #0000ff;">return</span><span style="color: #000000;"> a;
}
</span><span style="color: #0000ff;">double</span> maxarr(<span style="color: #0000ff;">int</span> l,<span style="color: #0000ff;">int</span> r){ <span style="color: #008000;">//</span><span style="color: #008000;">max in an array</span>
    <span style="color: #0000ff;">double</span> maxm =<span style="color: #000000;"> dot[l];
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=l+<span style="color: #800080;">1</span>;i&lt;=r;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(dot[i]&gt;<span style="color: #000000;">maxm) 
            maxm </span>=<span style="color: #000000;"> dot[i];
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> maxm;
}
</span><span style="color: #0000ff;">double</span> minarr(<span style="color: #0000ff;">int</span> l,<span style="color: #0000ff;">int</span> r){ <span style="color: #008000;">//</span><span style="color: #008000;">min in an array</span>
    <span style="color: #0000ff;">double</span> minn =<span style="color: #000000;"> dot[l];
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=l+<span style="color: #800080;">1</span>;i&lt;=r;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(dot[i]&lt;<span style="color: #000000;">minn) 
            minn </span>=<span style="color: #000000;"> dot[i];
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> minn;
}
</span><span style="color: #0000ff;">int</span> partition(<span style="color: #0000ff;">double</span> pivot,<span style="color: #0000ff;">int</span> lp,<span style="color: #0000ff;">int</span> rp){<span style="color: #008000;">//</span><span style="color: #008000;">partition in quicksort</span>
    <span style="color: #0000ff;">while</span>(lp &lt;<span style="color: #000000;"> rp){
        </span><span style="color: #0000ff;">while</span>((lp &lt; rp) &amp;&amp; (dot[lp] &lt;= pivot)) lp++<span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span>((lp &lt; rp) &amp;&amp; (dot[rp] &gt;= pivot)) rp--<span style="color: #000000;">;
        </span><span style="color: #0000ff;">double</span> temp =<span style="color: #000000;"> dot[lp];
        dot[lp] </span>=<span style="color: #000000;"> dot[rp];
        dot[rp] </span>=<span style="color: #000000;"> temp;
    }
    </span><span style="color: #0000ff;">return</span> lp-<span style="color: #800080;">1</span><span style="color: #000000;">;
}
</span><span style="color: #0000ff;">double</span> minpair1(<span style="color: #0000ff;">int</span> start,<span style="color: #0000ff;">int</span><span style="color: #000000;"> end){
    </span><span style="color: #008000;">//</span><span style="color: #008000;">bounds</span>
    <span style="color: #0000ff;">if</span>(start == end) <span style="color: #0000ff;">return</span> <span style="color: #800080;">999999</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> only one number</span>
    <span style="color: #0000ff;">if</span>(start+<span style="color: #800080;">1</span> == end){ <span style="color: #008000;">//</span><span style="color: #008000;">two numbers</span>
        <span style="color: #0000ff;">double</span> t = dot[start] -<span style="color: #000000;"> dot[end];
        </span><span style="color: #0000ff;">return</span> t &gt; <span style="color: #800080;">0</span>?t : -<span style="color: #000000;">t;
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">find mid-value</span>
    <span style="color: #0000ff;">double</span> ma =<span style="color: #000000;"> maxarr(start,end);
    </span><span style="color: #0000ff;">double</span> mi =<span style="color: #000000;"> minarr(start,end);
    </span><span style="color: #0000ff;">double</span> m = (ma + mi)/<span style="color: #800080;">2</span><span style="color: #000000;">;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">partition    </span>
    <span style="color: #0000ff;">int</span> mid =<span style="color: #000000;"> partition(m,start,end);
    </span><span style="color: #008000;">//</span><span style="color: #008000;">recursion</span>
    <span style="color: #0000ff;">double</span> d1 =<span style="color: #000000;"> minpair1(start,mid);
    </span><span style="color: #0000ff;">double</span> d2 = minpair1(mid+<span style="color: #800080;">1</span><span style="color: #000000;">,end);
    </span><span style="color: #008000;">//</span><span style="color: #008000;">find the max number in the left &amp; the min number in thr right</span>
    <span style="color: #0000ff;">double</span> lmax =<span style="color: #000000;"> maxarr(start,mid);
    </span><span style="color: #0000ff;">double</span> rmin = minarr(mid+<span style="color: #800080;">1</span><span style="color: #000000;">,end);
    </span><span style="color: #0000ff;">double</span> d3 = rmin -<span style="color: #000000;"> lmax;
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> min3(d1,d2,d3);
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">n);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++) scanf(<span style="color: #800000;">"</span><span style="color: #800000;">%lf</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">dot[i]);
    </span><span style="color: #0000ff;">double</span> dm = minpair1(<span style="color: #800080;">1</span><span style="color: #000000;">,n);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%llf</span><span style="color: #800000;">"</span><span style="color: #000000;">,dm);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
} 
</span><span style="color: #008000;">/*</span><span style="color: #008000;">----Test----
12
1.5 5.4 2.7 6.8 4.9 9.1 5.6 8.8 0.6 1.9 5.3 6.5
15
1.5 5.4 2.7 6.8 4.9 9.1 5.6 8.8 0.6 1.9 10.3 6.5 12.4 12.6 11.4
</span><span style="color: #008000;">*/</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p>二维：</p>
<p><img src="https://img2020.cnblogs.com/blog/1726496/202004/1726496-20200404002346733-247988794.png" alt="" width="577" height="331" /></p>
<p>&nbsp;</p>
<p>&nbsp;代码实现：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('9b1d2532-b5f4-40d0-bebf-be70382ceeb3')"><img id="code_img_closed_9b1d2532-b5f4-40d0-bebf-be70382ceeb3" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_9b1d2532-b5f4-40d0-bebf-be70382ceeb3" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('9b1d2532-b5f4-40d0-bebf-be70382ceeb3',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_9b1d2532-b5f4-40d0-bebf-be70382ceeb3" class="cnblogs_code_hide">
<pre>#include&lt;stdio.h&gt;<span style="color: #000000;">
#include</span>&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;math.h&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> MAXN = <span style="color: #800080;">1000000</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> Dot{
    </span><span style="color: #0000ff;">double</span><span style="color: #000000;"> x,y;
}dot[MAXN];

</span><span style="color: #0000ff;">double</span> maxxarr(<span style="color: #0000ff;">int</span> l,<span style="color: #0000ff;">int</span> r){ <span style="color: #008000;">//</span><span style="color: #008000;">max(x) in an array</span>
    <span style="color: #0000ff;">double</span> maxm =<span style="color: #000000;"> dot[l].x;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=l+<span style="color: #800080;">1</span>;i&lt;=r;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(dot[i].x&gt;<span style="color: #000000;">maxm) 
            maxm </span>=<span style="color: #000000;"> dot[i].x;
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> maxm;
}
</span><span style="color: #0000ff;">double</span> minxarr(<span style="color: #0000ff;">int</span> l,<span style="color: #0000ff;">int</span> r){ <span style="color: #008000;">//</span><span style="color: #008000;">min(x) in an array</span>
    <span style="color: #0000ff;">double</span> minn =<span style="color: #000000;"> dot[l].x;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=l+<span style="color: #800080;">1</span>;i&lt;=r;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(dot[i].x&lt;<span style="color: #000000;">minn) 
            minn </span>=<span style="color: #000000;"> dot[i].x;
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> minn;
}
</span><span style="color: #0000ff;">double</span><span style="color: #000000;"> dist(Dot a,Dot b){
    </span><span style="color: #0000ff;">return</span> sqrt((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y -<span style="color: #000000;"> b.y));
}
</span><span style="color: #0000ff;">int</span> partition(<span style="color: #0000ff;">double</span> pivot,<span style="color: #0000ff;">int</span> lp,<span style="color: #0000ff;">int</span> rp){<span style="color: #008000;">//</span><span style="color: #008000;">partition in quicksort</span>
    <span style="color: #0000ff;">while</span>(lp &lt;<span style="color: #000000;"> rp){
        </span><span style="color: #0000ff;">while</span>((lp &lt; rp) &amp;&amp; (dot[lp].x &lt;= pivot)) lp++<span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span>((lp &lt; rp) &amp;&amp; (dot[rp].x &gt;= pivot)) rp--<span style="color: #000000;">;
        Dot temp </span>=<span style="color: #000000;"> dot[lp];
        dot[lp] </span>=<span style="color: #000000;"> dot[rp];
        dot[rp] </span>=<span style="color: #000000;"> temp;
    }
    </span><span style="color: #0000ff;">return</span> lp-<span style="color: #800080;">1</span><span style="color: #000000;">;
}
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> cmp(Dot a,Dot b){
    </span><span style="color: #0000ff;">return</span> a.y &lt;<span style="color: #000000;"> b.y;
}
</span><span style="color: #0000ff;">double</span> minpair2(<span style="color: #0000ff;">int</span> start,<span style="color: #0000ff;">int</span><span style="color: #000000;"> end){
    </span><span style="color: #008000;">//</span><span style="color: #008000;">bounds</span>
    <span style="color: #0000ff;">if</span>(start == end) <span style="color: #0000ff;">return</span> <span style="color: #800080;">999999</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> only one number</span>
    <span style="color: #0000ff;">if</span>(start+<span style="color: #800080;">1</span> == end) <span style="color: #0000ff;">return</span> dist(dot[start],dot[end]); <span style="color: #008000;">//</span><span style="color: #008000;">two numbers
    </span><span style="color: #008000;">//</span><span style="color: #008000;">find mid-value of x</span>
    <span style="color: #0000ff;">double</span> ma =<span style="color: #000000;"> maxxarr(start,end);
    </span><span style="color: #0000ff;">double</span> mi =<span style="color: #000000;"> minxarr(start,end);
    </span><span style="color: #0000ff;">double</span> m = (ma + mi)/<span style="color: #800080;">2</span><span style="color: #000000;">;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">partition    </span>
    <span style="color: #0000ff;">int</span> mid =<span style="color: #000000;"> partition(m,start,end);
    </span><span style="color: #008000;">//</span><span style="color: #008000;">recursion</span>
    <span style="color: #0000ff;">double</span> d1 =<span style="color: #000000;"> minpair2(start,mid);
    </span><span style="color: #0000ff;">double</span> d2 = minpair2(mid+<span style="color: #800080;">1</span><span style="color: #000000;">,end);
    </span><span style="color: #0000ff;">double</span> dm = d1&lt;d2?<span style="color: #000000;">d1:d2;
    sort(dot</span>+<span style="color: #800080;">1</span>,dot+<span style="color: #000000;">mid,cmp);
    sort(dot</span>+mid,dot+<span style="color: #000000;">end,cmp);
    </span><span style="color: #0000ff;">double</span> d3 = <span style="color: #800080;">9999999</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=start;i&lt;=mid;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=mid+<span style="color: #800080;">1</span>;j&lt;=end;j++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(dot[i].x-m&lt;=dm &amp;&amp; dot[j].x-m&lt;=dm &amp;&amp;<span style="color: #000000;"> 
            dot[j].y</span>-dot[i].y&lt;=dm &amp;&amp; dot[j].y-dot[i].y&gt;=-<span style="color: #000000;">dm){
                </span><span style="color: #0000ff;">double</span> t =<span style="color: #000000;"> dist(dot[i],dot[j]);
                </span><span style="color: #0000ff;">if</span>(t &lt; d3) d3 =<span style="color: #000000;"> t;
            }
        }
    }
    </span><span style="color: #0000ff;">return</span> d3&lt;dm?<span style="color: #000000;">d3:dm;    
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">n);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++) scanf(<span style="color: #800000;">"</span><span style="color: #800000;">%lf %lf</span><span style="color: #800000;">"</span>,&amp;dot[i].x,&amp;<span style="color: #000000;">dot[i].y);
    </span><span style="color: #0000ff;">double</span> d = minpair2(<span style="color: #800080;">1</span><span style="color: #000000;">,n);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%llf</span><span style="color: #800000;">"</span><span style="color: #000000;">,d);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
} 
</span><span style="color: #008000;">/*</span><span style="color: #008000;">----Test----
8
1.5 5.4
2.7 6.8
4.9 9.1
5.6 8.8
1.4 5.3
5.3 6.5
3.4 5.6
2.4 3.4
9
1.5 5.4
2.7 6.8
4.9 9.1
5.6 8.8
0.6 1.9
5.3 6.5
3.4 5.6
2.4 3.4
0.7 1.7
</span><span style="color: #008000;">*/</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>]]></description></item><item><title>运筹学相关算法代码实现(MATLAB)</title><link>http://www.cnblogs.com/icodes8238/archive/2020/03/22/12547974.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Sun, 22 Mar 2020 12:04:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/03/22/12547974.html</guid><description><![CDATA[<p style="text-align: center;">运筹学线性规划问题相关算法matlab代码实现</p>
<p style="text-align: center;">涉及到的算法有：单纯形法、对偶单纯形法、指派问题的匈牙利算法</p>
<p>1、单纯形法</p>
<p>Simplex.m</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">function Simplex(A,b,c)
   [m,n] </span>=<span style="color: #000000;"> size(A);
   </span>%B = A(<span style="color: #800080;">1</span>:m,n-m+<span style="color: #800080;">1</span>:n); %det(B)!=<span style="color: #800080;">0</span><span style="color: #000000;">
   sigma </span>= c - c(n-m+<span style="color: #800080;">1</span>:n)*<span style="color: #000000;">A
   b
   </span><span style="color: #0000ff;">base</span> = [n-m+<span style="color: #800080;">1</span><span style="color: #000000;">:n]
   </span><span style="color: #0000ff;">while</span> max(sigma) &gt; <span style="color: #800080;">0</span><span style="color: #000000;">
       [t,indexin] </span>= max(sigma); %indexin = basis <span style="color: #0000ff;">var</span> to push <span style="color: #0000ff;">in</span><span style="color: #000000;">
       theta </span>= b(<span style="color: #800080;">1</span>:m)./A(<span style="color: #800080;">1</span><span style="color: #000000;">:m,indexin)
       disp(</span><span style="color: #800000;">'</span><span style="color: #800000;">----------------------</span><span style="color: #800000;">'</span><span style="color: #000000;">)
       minn </span>= <span style="color: #800080;">999999999</span><span style="color: #000000;">;
       </span><span style="color: #0000ff;">for</span> i=<span style="color: #800080;">1</span><span style="color: #000000;">:m
           </span><span style="color: #0000ff;">if</span> theta(i) &gt; <span style="color: #800080;">0</span> &amp;&amp; theta(i) &lt;<span style="color: #000000;"> minn
            minn </span>=<span style="color: #000000;"> theta(i);
            indexout </span>= i; %indexout = basis <span style="color: #0000ff;">var</span> to pop <span style="color: #0000ff;">out</span><span style="color: #000000;">
        end
       end
       </span><span style="color: #0000ff;">base</span>(indexout) =<span style="color: #000000;"> indexin;
       pivot </span>=<span style="color: #000000;"> A(indexout,indexin);
       A(indexout,</span><span style="color: #800080;">1</span>:n) = A(indexout,<span style="color: #800080;">1</span>:n)./<span style="color: #000000;">pivot;
       b(indexout) </span>=  b(indexout)./<span style="color: #000000;">pivot;
       </span><span style="color: #0000ff;">for</span> i=<span style="color: #800080;">1</span>:indexout-<span style="color: #800080;">1</span><span style="color: #000000;">
           temp </span>= -<span style="color: #000000;">A(i,indexin);
           A(i,</span><span style="color: #800080;">1</span>:n) = A(indexout,<span style="color: #800080;">1</span>:n)*temp + A(i,<span style="color: #800080;">1</span><span style="color: #000000;">:n);
           b(i) </span>= b(indexout)*temp +<span style="color: #000000;"> b(i);
       end
       </span><span style="color: #0000ff;">for</span> i=indexout+<span style="color: #800080;">1</span><span style="color: #000000;">:m
           temp </span>= -<span style="color: #000000;">A(i,indexin);
           A(i,</span><span style="color: #800080;">1</span>:n) = A(indexout,<span style="color: #800080;">1</span>:n)*temp + A(i,<span style="color: #800080;">1</span><span style="color: #000000;">:n);
           b(i) </span>= b(indexout)*temp +<span style="color: #000000;"> b(i);
       end
       A
       sigma </span>= c - c(<span style="color: #0000ff;">base</span>(<span style="color: #800080;">1</span>:m))*<span style="color: #000000;">A
       b
       basevar </span>= <span style="color: #0000ff;">base</span>(<span style="color: #800080;">1</span>:m) %<span style="color: #000000;">show basis variable
   end
end       </span></pre>
</div>
<p>&nbsp;</p>
<p>main.m</p>
<div class="cnblogs_code">
<pre>%<span style="color: #000000;">输出结果说明：ans为基变量，其余变量名含义均为单纯性表中变量名的含义
A </span>= [<span style="color: #800080;">2</span> -<span style="color: #800080;">3</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span> <span style="color: #800080;">0</span>;<span style="color: #800080;">1</span>/<span style="color: #800080;">3</span> <span style="color: #800080;">1</span> <span style="color: #800080;">5</span> <span style="color: #800080;">0</span> <span style="color: #800080;">1</span>]; %A为标准形式，默认后n-<span style="color: #000000;">m列为松弛变量
b</span>=[<span style="color: #800080;">15</span>;<span style="color: #800080;">20</span>]; %<span style="color: #000000;">输入列向量
c</span>=[<span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span>]; %<span style="color: #000000;">输入行向量，不要输入列向量！注意补齐松弛变量的0
Simplex(A,b,c)

</span>%<span style="color: #000000;">{
A</span>=[<span style="color: #800080;">2</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">0</span>;<span style="color: #800080;">1</span> <span style="color: #800080;">3</span> <span style="color: #800080;">0</span> <span style="color: #800080;">1</span><span style="color: #000000;">]
b</span>=[<span style="color: #800080;">40</span>;<span style="color: #800080;">30</span><span style="color: #000000;">]
c </span>= [<span style="color: #800080;">3</span> <span style="color: #800080;">4</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span><span style="color: #000000;">]
Simplex(A,b,c)
</span>%<span style="color: #000000;">}

</span>%<span style="color: #000000;">{
  A </span>= [<span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span>;<span style="color: #800080;">4</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">1</span> <span style="color: #800080;">0</span>;<span style="color: #800080;">0</span> <span style="color: #800080;">4</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">1</span><span style="color: #000000;">]; 
  b</span>=[<span style="color: #800080;">8</span>;<span style="color: #800080;">16</span>;<span style="color: #800080;">12</span><span style="color: #000000;">]; 
  c</span>=[<span style="color: #800080;">2</span> <span style="color: #800080;">3</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span><span style="color: #000000;">];
  Simplex(A,b,c)
</span>%}</pre>
</div>
<p>&nbsp;</p>
<p>2、对偶单纯形法</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">function DualSimplex(A,b,c)
   [m,n] </span>=<span style="color: #000000;"> size(A);
   </span>%B = A(<span style="color: #800080;">1</span>:m,n-m+<span style="color: #800080;">1</span>:n); %det(B)!=<span style="color: #800080;">0</span><span style="color: #000000;">
   sigma </span>= c - c(n-m+<span style="color: #800080;">1</span>:n)*<span style="color: #000000;">A
   b
   </span><span style="color: #0000ff;">base</span> = [n-m+<span style="color: #800080;">1</span><span style="color: #000000;">:n]
   </span><span style="color: #0000ff;">while</span> min(b) &lt; <span style="color: #800080;">0</span><span style="color: #000000;">
       [t,indexout] </span>= min(b); %<span style="color: #000000;">determine indexout
       disp(</span><span style="color: #800000;">'</span><span style="color: #800000;">----------------------</span><span style="color: #800000;">'</span><span style="color: #000000;">)
       theta </span>= sigma(<span style="color: #800080;">1</span>:n)./A(indexout,<span style="color: #800080;">1</span><span style="color: #000000;">:n)
       minn </span>= <span style="color: #800080;">999999999</span><span style="color: #000000;">;
       </span><span style="color: #0000ff;">for</span> i=<span style="color: #800080;">1</span><span style="color: #000000;">:n
           </span><span style="color: #0000ff;">if</span> theta(i) &gt; <span style="color: #800080;">0</span> &amp;&amp; theta(i) &lt;<span style="color: #000000;"> minn
            minn </span>=<span style="color: #000000;"> theta(i);
            indexin </span>= i; %<span style="color: #000000;">determine indexin
        end
       end
       </span><span style="color: #0000ff;">base</span>(indexout) =<span style="color: #000000;"> indexin;
       pivot </span>=<span style="color: #000000;"> A(indexout,indexin);
       A(indexout,</span><span style="color: #800080;">1</span>:n) = A(indexout,<span style="color: #800080;">1</span>:n)./<span style="color: #000000;">pivot;
       b(indexout) </span>=  b(indexout)./<span style="color: #000000;">pivot;
       </span><span style="color: #0000ff;">for</span> i=<span style="color: #800080;">1</span>:indexout-<span style="color: #800080;">1</span><span style="color: #000000;">
           temp </span>= -<span style="color: #000000;">A(i,indexin);
           A(i,</span><span style="color: #800080;">1</span>:n) = A(indexout,<span style="color: #800080;">1</span>:n)*temp + A(i,<span style="color: #800080;">1</span><span style="color: #000000;">:n);
           b(i) </span>= b(indexout)*temp +<span style="color: #000000;"> b(i);
       end
       </span><span style="color: #0000ff;">for</span> i=indexout+<span style="color: #800080;">1</span><span style="color: #000000;">:m
           temp </span>= -<span style="color: #000000;">A(i,indexin);
           A(i,</span><span style="color: #800080;">1</span>:n) = A(indexout,<span style="color: #800080;">1</span>:n)*temp + A(i,<span style="color: #800080;">1</span><span style="color: #000000;">:n);
           b(i) </span>= b(indexout)*temp +<span style="color: #000000;"> b(i);
       end
       A
       sigma </span>= c - c(<span style="color: #0000ff;">base</span>(<span style="color: #800080;">1</span>:m))*<span style="color: #000000;">A
       b
       basevar </span>= <span style="color: #0000ff;">base</span>(<span style="color: #800080;">1</span>:m) %<span style="color: #000000;">show basis variable
   end
end </span></pre>
</div>
<p>&nbsp;</p>
<p>3、匈牙利算法</p>
<div class="cnblogs_code">
<pre>  function[A,Book,Plan,m,n] =<span style="color: #000000;"> Mark(A,Book,Plan,m,n)
    marker </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">while</span> marker == <span style="color: #800080;">1</span><span style="color: #000000;">
        marker </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span>%<span style="color: #000000;">从第一行开始，若该行只有一个零元素, 则对这个零元素打上一对括号, 
        </span>%<span style="color: #000000;">同时对该零元素所在列画一条直线. 然后处理下一行，直到最后一行. 
        </span>%<span style="color: #000000;">需要注意的是在统计每行零元素数量的时候被直线覆盖的零元素不在统计之内.
        </span><span style="color: #0000ff;">for</span> i = <span style="color: #800080;">1</span><span style="color: #000000;">:m
            count </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> j = <span style="color: #800080;">1</span><span style="color: #000000;">:n
                </span><span style="color: #0000ff;">if</span> A(i,j) == <span style="color: #800080;">0</span> &amp;&amp; Book(i,j) == <span style="color: #800080;">0</span><span style="color: #000000;">
                    count </span>= count + <span style="color: #800080;">1</span><span style="color: #000000;">;
                    index </span>=<span style="color: #000000;"> j;
                end
            end
            </span><span style="color: #0000ff;">if</span> count == <span style="color: #800080;">1</span><span style="color: #000000;">
                marker </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
                Plan(i,index) </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">for</span> k = <span style="color: #800080;">1</span><span style="color: #000000;">:m
                    Book(k,index) </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
                end
            end
        end
        </span>%<span style="color: #000000;">从第一列开始, 若该列只有一个零元素, 则对这个零元素打上一对括号,
        </span>%<span style="color: #000000;">同时对该零元素所在行画一条直线. 然后处理下一列，直到最后一列. 
        </span>%<span style="color: #000000;">同样的, 被直线覆盖的零元素不在统计之内.
        </span><span style="color: #0000ff;">for</span> j = <span style="color: #800080;">1</span><span style="color: #000000;">:n
            count </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> i = <span style="color: #800080;">1</span><span style="color: #000000;">:m
                </span><span style="color: #0000ff;">if</span> A(i,j) == <span style="color: #800080;">0</span> &amp;&amp; Book(i,j) == <span style="color: #800080;">0</span><span style="color: #000000;">
                    count </span>= count + <span style="color: #800080;">1</span><span style="color: #000000;">;
                    index </span>=<span style="color: #000000;"> i;
                end
            end
            </span><span style="color: #0000ff;">if</span> count == <span style="color: #800080;">1</span><span style="color: #000000;">
                marker </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
                Plan(index,j) </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">for</span> k = <span style="color: #800080;">1</span><span style="color: #000000;">:n
                    Book(index,k) </span>= Book(index,k)+<span style="color: #800080;">1</span><span style="color: #000000;">;
                end
            end
        end
    end</span></pre>
</div>
<div class="cnblogs_code">
<pre><span style="color: #000000;">function Hungarian(A)
    [m,n] </span>= size(A); %<span style="color: #000000;">m行n列
    Book </span>=<span style="color: #000000;"> zeros(m,n);
    Plan </span>=<span style="color: #000000;"> zeros(m,n);
    rowmin </span>= min(A,[],<span style="color: #800080;">2</span>);%<span style="color: #000000;">得到每一行的最小元素
    </span>%<span style="color: #000000;">将效率矩阵的每行减去该行最小的元素
    </span><span style="color: #0000ff;">for</span> i = <span style="color: #800080;">1</span><span style="color: #000000;">:n
        A(</span><span style="color: #800080;">1</span>:m,i) = A(<span style="color: #800080;">1</span>:m,i) -<span style="color: #000000;"> rowmin;
    end
    
    colmin </span>= min(A,[],<span style="color: #800080;">1</span>);%<span style="color: #000000;">得到每一列的最小元素
    </span>%<span style="color: #000000;">将效率矩阵的每列减去该行最小的元素
    </span><span style="color: #0000ff;">for</span> i = <span style="color: #800080;">1</span><span style="color: #000000;">:m
        A(i,</span><span style="color: #800080;">1</span>:n) = A(i,<span style="color: #800080;">1</span>:n) -<span style="color: #000000;"> colmin;
    end
    A
    [A,Book,Plan,m,n] </span>=<span style="color: #000000;"> Mark(A,Book,Plan,m,n);
    </span><span style="color: #0000ff;">while</span> sum(sum(Plan)) &lt;<span style="color: #000000;"> m
        Plan </span>=<span style="color: #000000;"> zeros(m,n);
        </span>%<span style="color: #000000;">找到没有被直线通过的最小元素
        minn </span>= <span style="color: #800080;">9999999</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> i =<span style="color: #800080;">1</span><span style="color: #000000;"> :m
            </span><span style="color: #0000ff;">for</span> j = <span style="color: #800080;">1</span><span style="color: #000000;">:n
                </span><span style="color: #0000ff;">if</span> Book(i,j)==<span style="color: #800080;">0</span> &amp;&amp; A(i,j)&lt;<span style="color: #000000;">minn
                    minn </span>=<span style="color: #000000;"> A(i,j);
                end
            end
        end
        </span>%<span style="color: #000000;">没有被直线通过的元素减去最小的元素
        </span><span style="color: #0000ff;">for</span> i =<span style="color: #800080;">1</span><span style="color: #000000;"> :m
            </span><span style="color: #0000ff;">for</span> j = <span style="color: #800080;">1</span><span style="color: #000000;">:n
                </span><span style="color: #0000ff;">if</span> Book(i,j)==<span style="color: #800080;">0</span><span style="color: #000000;"> 
                    A(i,j) </span>= A(i,j)-<span style="color: #000000;">minn;
                end
                </span><span style="color: #0000ff;">if</span> Book(i,j)==<span style="color: #800080;">2</span><span style="color: #000000;"> 
                    A(i,j) </span>= A(i,j)+<span style="color: #000000;">minn;
                end
            end
        end
        </span>%<span style="color: #000000;">重复
        A
        Book </span>=<span style="color: #000000;"> zeros(m,n);
        [A,Book,Plan,m,n] </span>=<span style="color: #000000;"> Mark(A,Book,Plan,m,n);
    end
    Plan</span></pre>
</div>
<p>main.m</p>
<div class="cnblogs_code">
<pre>%A = [<span style="color: #800080;">2</span> <span style="color: #800080;">9</span> <span style="color: #800080;">3</span> <span style="color: #800080;">5</span> <span style="color: #800080;">7</span>;<span style="color: #800080;">6</span> <span style="color: #800080;">1</span> <span style="color: #800080;">5</span> <span style="color: #800080;">6</span> <span style="color: #800080;">6</span>;<span style="color: #800080;">9</span> <span style="color: #800080;">4</span> <span style="color: #800080;">7</span> <span style="color: #800080;">10</span> <span style="color: #800080;">3</span>;<span style="color: #800080;">2</span> <span style="color: #800080;">5</span> <span style="color: #800080;">4</span> <span style="color: #800080;">4</span> <span style="color: #800080;">1</span>;<span style="color: #800080;">9</span> <span style="color: #800080;">6</span> <span style="color: #800080;">2</span> <span style="color: #800080;">4</span> <span style="color: #800080;">6</span><span style="color: #000000;">];
</span>%A = [<span style="color: #800080;">6</span> <span style="color: #800080;">7</span> <span style="color: #800080;">11</span> <span style="color: #800080;">2</span>;<span style="color: #800080;">4</span> <span style="color: #800080;">5</span> <span style="color: #800080;">9</span> <span style="color: #800080;">8</span>;<span style="color: #800080;">3</span> <span style="color: #800080;">1</span> <span style="color: #800080;">10</span> <span style="color: #800080;">4</span>;<span style="color: #800080;">5</span> <span style="color: #800080;">9</span> <span style="color: #800080;">8</span> <span style="color: #800080;">2</span><span style="color: #000000;">];
</span>%A = [<span style="color: #800080;">3</span> <span style="color: #800080;">8</span> <span style="color: #800080;">2</span> <span style="color: #800080;">10</span> <span style="color: #800080;">3</span>;<span style="color: #800080;">8</span> <span style="color: #800080;">7</span> <span style="color: #800080;">2</span> <span style="color: #800080;">9</span> <span style="color: #800080;">7</span>;<span style="color: #800080;">6</span> <span style="color: #800080;">4</span> <span style="color: #800080;">2</span> <span style="color: #800080;">7</span> <span style="color: #800080;">5</span>;<span style="color: #800080;">8</span> <span style="color: #800080;">4</span> <span style="color: #800080;">2</span> <span style="color: #800080;">3</span> <span style="color: #800080;">5</span>;<span style="color: #800080;">9</span> <span style="color: #800080;">10</span> <span style="color: #800080;">6</span> <span style="color: #800080;">9</span> <span style="color: #800080;">10</span><span style="color: #000000;">];
A </span>= [<span style="color: #800080;">2</span> <span style="color: #800080;">9</span> <span style="color: #800080;">3</span> <span style="color: #800080;">5</span> <span style="color: #800080;">7</span>;<span style="color: #800080;">6</span> <span style="color: #800080;">1</span> <span style="color: #800080;">5</span> <span style="color: #800080;">6</span> <span style="color: #800080;">6</span>;<span style="color: #800080;">9</span> <span style="color: #800080;">4</span> <span style="color: #800080;">7</span> <span style="color: #800080;">10</span> <span style="color: #800080;">3</span>;<span style="color: #800080;">2</span> <span style="color: #800080;">5</span> <span style="color: #800080;">4</span> <span style="color: #800080;">4</span> <span style="color: #800080;">1</span>;<span style="color: #800080;">9</span> <span style="color: #800080;">6</span> <span style="color: #800080;">2</span> <span style="color: #800080;">4</span> <span style="color: #800080;">6</span><span style="color: #000000;">];
Hungarian(A)</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>字符串匹配算法（RK算法和KMP算法）</title><link>http://www.cnblogs.com/icodes8238/archive/2020/03/06/12301055.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Fri, 06 Mar 2020 15:34:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/03/06/12301055.html</guid><description><![CDATA[<h2><span style="font-family: 楷体;">算法1：RK算法</span></h2>
<h4>算法描述：</h4>
<p>（1）计算模式串的Hashcode</p>
<p>方式1：按位相加；</p>
<p>方式2：看成26进制数转化为十进制，如abc = 1x26^2 + 2x26^1 + 4x26^0；</p>
<p>方式2缺点：字符串很长时，对应的十进制数会非常大</p>
<p>（2）主串采用增量计算</p>
<p>例如：主串：abbcefg；模式串bce</p>
<p>第一次计算abb，第二次计算bbc时：<span style="text-decoration: underline;"><strong>新Hahcode =&nbsp;旧Hashcode - 'a' + 'c'</strong></span></p>
<p>（3）检查 Hash Collision</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('5a58c76e-fd8d-429e-9c42-ee222b9c4955')"><img id="code_img_closed_5a58c76e-fd8d-429e-9c42-ee222b9c4955" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_5a58c76e-fd8d-429e-9c42-ee222b9c4955" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('5a58c76e-fd8d-429e-9c42-ee222b9c4955',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_5a58c76e-fd8d-429e-9c42-ee222b9c4955" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200306</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;cstring&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> MAXN = <span style="color: #800080;">1000</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">char</span><span style="color: #000000;"> pattern[MAXN],major[MAXN];
</span><span style="color: #0000ff;">int</span> hashcode(<span style="color: #0000ff;">char</span>* arr,<span style="color: #0000ff;">int</span> begin,<span style="color: #0000ff;">int</span><span style="color: #000000;"> end){
    </span><span style="color: #0000ff;">int</span> sum = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=begin;i&lt;end;i++<span style="color: #000000;">){
        sum </span>+= (<span style="color: #0000ff;">int</span>)arr[i] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span> + <span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> ASCII of 'a' is 97</span>
<span style="color: #000000;">    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> sum;
}
</span><span style="color: #0000ff;">int</span> changehashcode(<span style="color: #0000ff;">int</span> sumori,<span style="color: #0000ff;">int</span> begin,<span style="color: #0000ff;">int</span><span style="color: #000000;"> end){
    </span><span style="color: #0000ff;">return</span> sumori - major[begin-<span style="color: #800080;">1</span>] + major[end-<span style="color: #800080;">1</span>]; <span style="color: #008000;">//</span><span style="color: #008000;"> +96-96 = 0</span>
<span style="color: #000000;">}
</span><span style="color: #0000ff;">bool</span> hashcollision(<span style="color: #0000ff;">int</span> begin,<span style="color: #0000ff;">int</span><span style="color: #000000;"> end){
    </span><span style="color: #0000ff;">bool</span> state = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=begin;i&lt;end;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(major[i] != pattern[i-<span style="color: #000000;">begin]){
            state </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
    }
    </span><span style="color: #0000ff;">if</span>(state) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span> pos = -<span style="color: #800080;">1</span><span style="color: #000000;">;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%s\n%s</span><span style="color: #800000;">"</span><span style="color: #000000;">,pattern,major);
    </span><span style="color: #0000ff;">int</span> lenp =<span style="color: #000000;"> strlen(pattern);
    </span><span style="color: #0000ff;">int</span> lenm =<span style="color: #000000;"> strlen(major);
    </span><span style="color: #0000ff;">int</span> hashp = hashcode(pattern,<span style="color: #800080;">0</span><span style="color: #000000;">,lenp);
    </span><span style="color: #0000ff;">int</span> hashm = hashcode(major,<span style="color: #800080;">0</span><span style="color: #000000;">,lenp);
    </span><span style="color: #0000ff;">if</span>(hashm == hashp &amp;&amp; !hashcollision(<span style="color: #800080;">0</span>,lenp)) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;lenm-lenp;i++<span style="color: #000000;">){
        hashm </span>= changehashcode(hashm,i,i+<span style="color: #000000;">lenp);
        </span><span style="color: #0000ff;">if</span>(hashm != hashp) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(hashcollision(i,i+lenp)) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            pos </span>=<span style="color: #000000;"> i;
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
    }
    cout</span>&lt;&lt;<span style="color: #000000;">pos;
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}
</span><span style="color: #008000;">/*</span><span style="color: #008000;">---Test---
bce
abbcefgh
//collision
bce
abcbefgh
</span><span style="color: #008000;">*/</span> </pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;">算法2：KMP算法</span></h2>
<h3><span style="font-family: 楷体;">1.什么是next数组？</span></h3>
<p>　　next[i]就是<span style="background-color: #ffff00;">子串s[0...i]的&nbsp;<strong>最长</strong><strong>&nbsp;</strong><strong>相等</strong>前后缀 的 前缀最后一位 的下标</span>。（也是<span style="background-color: #ffff00;"><strong>最长相等前后缀的长度</strong></span>）</p>
<p>　　什么是前缀？子串s[0...i]中s[0...k](k&lt;i)为前缀，s[...i]为后缀，其中前后缀长度相等。也就是从0开始往后数k个，从最后一个字符开始往前数k个(k&lt;i)；（注意k!=i，即不能是子串本身）</p>
<p>举例：s[] = abababc</p>
<p>　　当i=0时，子串为a，k&lt;i=0中k无法取值，所以next[0] = -1；</p>
<p>　　当i=1时，子串为ab, k=0 &lt; i=1，前缀a，后缀b，不相等，</p>
<p>　　　　　　所以next[1] = -1；</p>
<p>　　当i=2时，子串为aba，k=0 &lt; i=2, 前缀a，后缀a，相等，k=0</p>
<p>　　　　　　　　　　　　k=1 &lt; i=2,前缀ab，后缀ba，不相等，</p>
<p>　　　　　　所以最长相等前后缀（即最大的k）为0，所以next[2] = k = 0；</p>
<p>　　当i=3时，子串为abab，k=0 &lt; i=3，前缀a，后缀b，不相等</p>
<p>　　　　　　　　　　　&nbsp; 　k=1 &lt; i=3,前缀ab，后缀ab，相等，k=1</p>
<p>&nbsp; 　　　　　　　　　　　　k=2 &lt; i=3,前缀aba，后缀bab，不相等，</p>
<p>　　　　　　所以最长相等前后缀（即最大的k）为1，所以next[3] = k = 1；</p>
<p>　　当i=4,5,6时，同理；</p>
<p>　　当i=7(strlen(s) = 7)时，子串为abababc，k=0 &lt; i=7，前缀a，后缀c，不相等。OK，这个时候k就不需要继续往下取值了，因为不可能再相等了，也就是说遇到不相等的情况就可以终止了。【相等k继续递增，不相等k立即终止，next[i]=k-1】；</p>
<p>　　最终得到next数组为[-1,-1,0,1,2,3,-1]。</p>
<p>&nbsp;</p>
<h3><span style="font-family: 楷体;">2.如何求next数组？（上面举例时采取的求next数组算法比较繁琐，故采用下述递推方法）</span></h3>
<p>我们将在next[i-1]的基础上求next[i]：</p>
<p>　　假设我们已经求出<strong><span style="text-decoration: underline;">next[i-1]，不妨令它等于j</span></strong>（也就是说<span style="text-decoration: underline;"><strong>s[0...i]的最长相等前后缀的长度为j</strong></span>），那么当我们继续读入一位时，<span style="text-decoration-line: underline;"><strong><span style="background-color: #ffff00;">最长相等前后缀的长度 在原来基础上 最多增加1位</span></strong>,</span>也就是说，最长相等前后缀的长度最长为next[i-1]+1；</p>
<p>　　（理解：字符串xyx的 最长相等前后缀长度为strlen(x)，那么xyxa 最长相等前后缀长度 不可能超过strlen(xa) <strong>并且</strong>&nbsp;<span style="background-color: #ffff00;">xyxa&nbsp;最长相等前后缀长度等于strlen(xa)当且仅当a == y[0]</span>）</p>
<p>　　也就是说，我们判断新读入的这个字符a与y[0]是否相等即可；y[0]是什么？它就是下标j+1所对应的字符，即读入该字符之前的那个字符串 最长相等前后缀的前缀最后一位的下标+1 作为下标对应的字符。</p>
<p>　　如果 a == y[0]，那么next[i] = j+1即可；</p>
<p>　　如果a != y[0]，该怎么办？</p>
<p>　　直观的想法是从头（j = -1）开始匹配，这样的做法过于暴力，我们可以让j退回到最近的符合要求（a == s[j+1]）的位置即可。也就是说：我们需要在字符串xyxa第一个x中找到尽可能靠后的字符a，假设我们把第一个x拆为waz，后一个x拆成uw，那么我们应该使字符串wazyuwa中z的长度尽可能小（w的长度尽可能大）。那么我们怎么找到waz中a的位置呢？现在，我们已知字符串z中最后一个字符的位置，该字符对应的next数组中所存值的含义是&nbsp;<span style="text-decoration: underline;"><strong>字符串waz最长相等前后缀的前缀&nbsp;</strong></span>最后一位的下标，不妨假设这个下标刚好对应字符a（如果不是我们循环地让j=next[j]即可，直到遇到a或到-1结束），那么字符串z就变成了wa，那么整个字符串wazyuwa中最长相等前后缀的长度就是strlen(wa)。</p>
<p>&nbsp;</p>
<h3><span style="font-family: 楷体;">3.什么是KMP算法？</span></h3>
<p>　　我们发现，上述求next数组的过程，就是<span style="text-decoration: underline;"><strong>字符串&ldquo;自匹配&rdquo;</strong></span>的过程，也就是在给定字符串的子串s[0,1,2...i]中寻找s[0,1,...k](k&lt;i)和s[.....,i]使得这两个子串完全相等并且k尽可能的大。那么同样的，字符串匹配问题是指给定一个模式串pattern，去和给定的主串text的子串匹配，寻找与模式串相匹配的子串，这个过程和模式串的next数组过程大同小异。</p>
<p>　　因此，模仿求next数组的过程，我们从主串text和模式串pattern的第一个字符去匹配。如果相等，我们继续匹配text和pattern的第二个字符......如果还没有到pattern的末尾就遇到不相等的情况，这个时候我们要移动pattern位置了，如何一位一位地移动，那么就退化成BF算法了。那么究竟应该移到哪里呢？我们知道，模式串的next[i]数组记录的是模式串的子串pattern[0,1.....,i]&nbsp;最长相等前后缀 的 前缀最后一位 的下标k，也就是说pattern[0,...k]和pattern[m,....,i](m = i-k)是一样的串。不匹配发生在pattern[i+1]和text[i+1]，也就是说pattern[0,...,i]和text[0,....i]都匹配，那么pattern[m,...,i]和text[m,....i]匹配，那么pattern[0,...,k]和text[m,....i]匹配，那我们继续比对pattern[k+1]和text[i+1]是否相等就行了，而k+1就等于next[i+1]。</p>
<p>&nbsp;</p>
<h4>4.总结</h4>
<p><strong>next数组究竟有哪些含义？</strong></p>
<p>（1）子串s[0...i]的&nbsp;<strong>最长</strong><strong>相等</strong>前后缀 的 前缀最后一位 的下标；</p>
<p>（2）子串s[0...i]的&nbsp;<strong>最长相等前后缀的长度；</strong></p>
<p>（3）主串与模式串匹配时，j+1位不能匹配时，j应该退回的位置。</p>
<p>&nbsp;</p>
<p><strong>5.KMP算法对应练习题</strong>：<a href="https://www.luogu.com.cn/problem/P3375" target="_blank">洛谷OJ</a></p>
<p>AC代码：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('308cca87-63d4-4a53-8b34-e34ff56848e8')"><img id="code_img_closed_308cca87-63d4-4a53-8b34-e34ff56848e8" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_308cca87-63d4-4a53-8b34-e34ff56848e8" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('308cca87-63d4-4a53-8b34-e34ff56848e8',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_308cca87-63d4-4a53-8b34-e34ff56848e8" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200306</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;cstring&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> MAXN = <span style="color: #800080;">1000000</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">char</span><span style="color: #000000;"> pattern[MAXN],text[MAXN];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> next[MAXN];
</span><span style="color: #0000ff;">int</span> value[MAXN];<span style="color: #008000;">//</span><span style="color: #008000;">store the result in LOGU OJ </span>
<span style="color: #0000ff;">void</span><span style="color: #000000;"> getNext(){
    </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> strlen(pattern);
    next[</span><span style="color: #800080;">0</span>] = -<span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">int</span> j = next[<span style="color: #800080;">0</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;len;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">while</span>(j!=-<span style="color: #800080;">1</span> &amp;&amp; pattern[i] != pattern[j+<span style="color: #800080;">1</span><span style="color: #000000;">]){
            j </span>=<span style="color: #000000;"> next[j];
        }
        </span><span style="color: #0000ff;">if</span>(pattern[i] == pattern[j+<span style="color: #800080;">1</span>]) j++<span style="color: #000000;">;
        next[i] </span>=<span style="color: #000000;"> j;
    }
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> KMP(){
    getNext(); 
    </span><span style="color: #0000ff;">int</span> lenpt =<span style="color: #000000;"> strlen(pattern);
    </span><span style="color: #0000ff;">int</span> lentx =<span style="color: #000000;"> strlen(text);
    </span><span style="color: #0000ff;">int</span> j = next[<span style="color: #800080;">0</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">int</span> ans = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;lentx;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">while</span>(j!=-<span style="color: #800080;">1</span> &amp;&amp; text[i] != pattern[j+<span style="color: #800080;">1</span><span style="color: #000000;">]){
            j </span>=<span style="color: #000000;"> next[j];
        }
        </span><span style="color: #0000ff;">if</span>(text[i] == pattern[j+<span style="color: #800080;">1</span>]) j++<span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span>(j == lenpt - <span style="color: #800080;">1</span><span style="color: #000000;">){
            value[ans</span>++] = i+<span style="color: #800080;">1</span>-<span style="color: #000000;">j;
            j </span>=<span style="color: #000000;"> next[j];
        }
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ans;
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%s\n%s</span><span style="color: #800000;">"</span><span style="color: #000000;">,text,pattern);
    </span><span style="color: #0000ff;">int</span> ans =<span style="color: #000000;"> KMP();
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;ans;i++) cout&lt;&lt;value[i]&lt;&lt;<span style="color: #000000;">endl;
    </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> strlen(pattern);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;len;i++) cout&lt;&lt;next[i]+<span style="color: #800080;">1</span>&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;">adjust to LOGU OJ</span>
<span style="color: #000000;">    
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;">参考资料：</span></h2>
<p>[1] 胡凡《算法笔记》P455~P464</p>
<p>&nbsp;</p>]]></description></item><item><title>树的静态写法</title><link>http://www.cnblogs.com/icodes8238/archive/2020/02/12/12294687.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Wed, 12 Feb 2020 03:38:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/02/12/12294687.html</guid><description><![CDATA[<p>《算法笔记》P302</p>
<pre><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805424153280512" target="_blank">PAT A1053 Path of Equal Weight </a></pre>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200211
</span><span style="color: #008000;">//</span><span style="color: #008000;">PAT A1053 Path of Equal Weight </span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;vector&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> MAXN = <span style="color: #800080;">105</span><span style="color: #000000;">;

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,internode,findweight;
</span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> Node{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> data;
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> child;
}node[MAXN];
</span><span style="color: #0000ff;">bool</span> cmp(<span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span><span style="color: #000000;"> b){
    </span><span style="color: #0000ff;">return</span> node[a].data &gt;<span style="color: #000000;"> node[b].data;
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> path[MAXN];
</span><span style="color: #0000ff;">void</span> dfs(<span style="color: #0000ff;">int</span> index,<span style="color: #0000ff;">int</span> num,<span style="color: #0000ff;">int</span><span style="color: #000000;"> sum){
    </span><span style="color: #0000ff;">if</span>(sum ==<span style="color: #000000;"> findweight){
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(node[index].child.empty()){
            </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;num-<span style="color: #800080;">1</span>;i++) printf(<span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span><span style="color: #000000;">,path[i]);
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span>,path[num-<span style="color: #800080;">1</span><span style="color: #000000;">]);
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    }
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(sum &gt; findweight) <span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;node[index].child.size();i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">int</span> child =<span style="color: #000000;"> node[index].child[i];
        path[num] </span>=<span style="color: #000000;"> node[child].data;
        dfs(child, num</span>+<span style="color: #800080;">1</span>, sum+<span style="color: #000000;">path[num]);
    }    
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d</span><span style="color: #800000;">"</span>,&amp;n,&amp;internode,&amp;<span style="color: #000000;">findweight);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++) scanf(<span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">node[i].data);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;internode;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> inno,times;
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d</span><span style="color: #800000;">"</span>,&amp;inno,&amp;<span style="color: #000000;">times);
        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> t;
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">0</span>;j&lt;times;j++<span style="color: #000000;">){
            scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">t);
            node[inno].child.push_back(t);
        }
        sort(node[inno].child.begin(),node[inno].child.end(),cmp);
    }
    path[</span><span style="color: #800080;">0</span>] = node[<span style="color: #800080;">0</span><span style="color: #000000;">].data;
    dfs(</span><span style="color: #800080;">0</span>,<span style="color: #800080;">1</span>,path[<span style="color: #800080;">0</span><span style="color: #000000;">]);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>大整数加法、减法、乘法、除法</title><link>http://www.cnblogs.com/icodes8238/archive/2020/02/12/12298324.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Wed, 12 Feb 2020 03:38:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/02/12/12298324.html</guid><description><![CDATA[<p>大整数的四则运算</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200212</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;cstring&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> MAXN = <span style="color: #800080;">1000</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> bignum{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> d[MAXN];
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> len;
    bignum(){ 
        memset(d,</span><span style="color: #800080;">0</span>,<span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(d));
        len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
    bignum(</span><span style="color: #0000ff;">char</span> *<span style="color: #000000;">t){
        len </span>=<span style="color: #000000;"> strlen(t);
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=len-<span style="color: #800080;">1</span>;i&gt;=<span style="color: #800080;">0</span>;i--<span style="color: #000000;">) 
            d[len</span>-i-<span style="color: #800080;">1</span>] = t[i] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
    }
};
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> comparebig(bignum a,bignum b){
    </span><span style="color: #0000ff;">if</span>(a.len &gt; b.len) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(a.len &lt; b.len) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(a.len ==<span style="color: #000000;"> b.len){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=a.len-<span style="color: #800080;">1</span>;i&gt;=<span style="color: #800080;">0</span>;i--<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(a.d[i] == b.d[i]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(a.d[i] &gt; b.d[i]) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(a.d[i] &lt; b.d[i]) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
}
bignum addbig(bignum a,bignum b){
    bignum c;
    </span><span style="color: #0000ff;">int</span> lenth =<span style="color: #000000;"> max(a.len,b.len);
    </span><span style="color: #0000ff;">int</span> carry = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;lenth;i++<span style="color: #000000;">){
        c.d[i] </span>= (a.d[i] + b.d[i] + carry) % <span style="color: #800080;">10</span><span style="color: #000000;">;
        carry </span>= (a.d[i] + b.d[i] + carry) / <span style="color: #800080;">10</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">if</span>(carry) c.d[lenth++] = b.d[lenth] + <span style="color: #800080;">1</span><span style="color: #000000;">;
    c.len </span>=<span style="color: #000000;"> lenth;
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> c;
}
bignum subbig(bignum a,bignum b){ </span><span style="color: #008000;">//</span><span style="color: #008000;">a&gt;b</span>
<span style="color: #000000;">    bignum c;
    </span><span style="color: #0000ff;">int</span> lenth =<span style="color: #000000;"> a.len;
    </span><span style="color: #0000ff;">int</span> carry = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;lenth;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(a.d[i]+carry &lt;<span style="color: #000000;"> b.d[i]) {
            c.d[i] </span>= carry + a.d[i] +<span style="color: #800080;">10</span> -<span style="color: #000000;"> b.d[i];
            carry </span>= -<span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
            c.d[i] </span>= carry + a.d[i] -<span style="color: #000000;"> b.d[i];
            carry </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        }
    }
    c.len </span>=<span style="color: #000000;"> lenth;
    </span><span style="color: #0000ff;">while</span>(c.d[c.len-<span style="color: #800080;">1</span>] == <span style="color: #800080;">0</span> &amp;&amp; c.len != <span style="color: #800080;">1</span><span style="color: #000000;">){
        c.len</span>--<span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> c;
}
bignum multi(bignum a,bignum b){
    bignum c;
    bignum t[a.len</span>+<span style="color: #800080;">1</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;a.len;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">int</span> carry = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">0</span>;j&lt;b.len;j++<span style="color: #000000;">){
            t[i].d[i</span>+j] = (a.d[i] * b.d[j] + carry) % <span style="color: #800080;">10</span><span style="color: #000000;">;
            carry </span>= (a.d[i] * b.d[j] + carry) / <span style="color: #800080;">10</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(carry){
            t[i].d[i</span>+b.len] =<span style="color: #000000;"> carry;
            t[i].len </span>= i+ b.len + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }</span><span style="color: #0000ff;">else</span> t[i].len = i+<span style="color: #000000;"> b.len;
    }
    c </span>= addbig(t[<span style="color: #800080;">0</span>],t[<span style="color: #800080;">1</span><span style="color: #000000;">]);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">2</span>;i&lt;a.len;i++<span style="color: #000000;">){
        c </span>=<span style="color: #000000;"> addbig(c,t[i]);
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> c;
}

</span><span style="color: #0000ff;">int</span> divide(bignum a,bignum b){ <span style="color: #008000;">//</span><span style="color: #008000;"> "66535664674756 3" will cause error</span>
    <span style="color: #0000ff;">int</span> count = <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> may overflow</span>
    bignum c =<span style="color: #000000;"> subbig(a,b);
    </span><span style="color: #0000ff;">while</span>(comparebig(c,b) == <span style="color: #800080;">1</span>){ <span style="color: #008000;">//</span><span style="color: #008000;">may time limit error</span>
        c =<span style="color: #000000;"> subbig(c,b);
        count</span>++<span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> count;
}

</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> show(bignum c){
    </span><span style="color: #0000ff;">int</span> lenth =<span style="color: #000000;"> c.len;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=lenth-<span style="color: #800080;">1</span>;i&gt;=<span style="color: #800080;">0</span>;i--) printf(<span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span><span style="color: #000000;">,c.d[i]);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> tempa[MAXN];
    </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> tempb[MAXN];
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%s</span><span style="color: #800000;">"</span><span style="color: #000000;">,tempa);
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%s</span><span style="color: #800000;">"</span><span style="color: #000000;">,tempb);
    bignum a(tempa),b(tempb);
    
    </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> comparebig(a,b);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,t);
    
    
    bignum c </span>=<span style="color: #000000;"> addbig(a,b);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">a + b = </span><span style="color: #800000;">"</span><span style="color: #000000;">);show(c);
    
    
    </span><span style="color: #0000ff;">if</span>(comparebig(a,b) == -<span style="color: #800080;">1</span><span style="color: #000000;">){
        bignum d </span>=<span style="color: #000000;"> subbig(b,a);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">a - b = -</span><span style="color: #800000;">"</span><span style="color: #000000;">);show(d);
    }
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
        bignum d </span>=<span style="color: #000000;"> subbig(a,b);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">a - b = </span><span style="color: #800000;">"</span><span style="color: #000000;">);show(d);
    }
    
    
    bignum e </span>=<span style="color: #000000;"> multi(a,b);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">a x b = </span><span style="color: #800000;">"</span><span style="color: #000000;">);show(e);
    
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">if(comparebig(a,b) == -1){
        printf("0\n");
    }
    else{
        int f = divide(a,b);
        printf("a / b = %d\n",f);
    }</span><span style="color: #008000;">*/</span>
    
    
    
    <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>&nbsp;</p>
<p>大整数除法（优化）</p>
<p>思路：<a href="https://blog.csdn.net/wjh2622075127/article/details/81106024" target="_blank">https://blog.csdn.net/wjh2622075127/article/details/81106024</a></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200212</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;cstring&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> MAXN = <span style="color: #800080;">1000</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> bignum{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> d[MAXN];
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> len;
    bignum(){ 
        memset(d,</span><span style="color: #800080;">0</span>,<span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(d));
        len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
    bignum(</span><span style="color: #0000ff;">char</span> *<span style="color: #000000;">t){
        memset(d,</span><span style="color: #800080;">0</span>,<span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(d));
        len </span>=<span style="color: #000000;"> strlen(t);
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;len;i++<span style="color: #000000;">) 
            d[i] </span>= t[i] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
    }
};
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> comparebig(bignum a,bignum b){
    </span><span style="color: #0000ff;">if</span>(a.len &gt; b.len) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(a.len &lt; b.len) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(a.len ==<span style="color: #000000;"> b.len){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;a.len;i++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(a.d[i] == b.d[i]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(a.d[i] &gt; b.d[i]) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(a.d[i] &lt; b.d[i]) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
}
bignum subbig(bignum a,bignum b){ </span><span style="color: #008000;">//</span><span style="color: #008000;">a&gt;b</span>
    reverse(a.d,a.d+<span style="color: #000000;">a.len);
    reverse(b.d,b.d</span>+<span style="color: #000000;">b.len);
    bignum c;
    </span><span style="color: #0000ff;">int</span> lenth =<span style="color: #000000;"> a.len;
    </span><span style="color: #0000ff;">int</span> carry = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;lenth;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(a.d[i]+carry &lt;<span style="color: #000000;"> b.d[i]) {
            c.d[i] </span>= carry + a.d[i] +<span style="color: #800080;">10</span> -<span style="color: #000000;"> b.d[i];
            carry </span>= -<span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
            c.d[i] </span>= carry + a.d[i] -<span style="color: #000000;"> b.d[i];
            carry </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        }
    }
    c.len </span>=<span style="color: #000000;"> lenth;
    </span><span style="color: #0000ff;">while</span>(c.d[c.len-<span style="color: #800080;">1</span>] == <span style="color: #800080;">0</span> &amp;&amp; c.len != <span style="color: #800080;">1</span><span style="color: #000000;">){
        c.len</span>--<span style="color: #000000;">;
    }
    reverse(c.d,c.d</span>+<span style="color: #000000;">c.len);
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> c;
}
bignum reminder;
bignum divided_optimised(bignum a,bignum b){
    bignum c;
    </span><span style="color: #0000ff;">int</span> conserve =<span style="color: #000000;"> b.len;
    b.len </span>=<span style="color: #000000;"> a.len;
    </span><span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span><span style="color: #000000;">;
    bignum t;
    </span><span style="color: #0000ff;">int</span> count = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span>(comparebig(a,b) != -<span style="color: #800080;">1</span><span style="color: #000000;">){
        t </span>=<span style="color: #000000;"> subbig(a,b);
        count</span>++<span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span>(comparebig(t,b) != -<span style="color: #800080;">1</span><span style="color: #000000;">){
            t </span>=<span style="color: #000000;"> subbig(t,b);
            count</span>++<span style="color: #000000;">;
        }
    }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
        b.len</span>--<span style="color: #000000;">;
        t </span>=<span style="color: #000000;"> subbig(a,b);
        count</span>++<span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span>(comparebig(t,b) != -<span style="color: #800080;">1</span><span style="color: #000000;">){
            t </span>=<span style="color: #000000;"> subbig(t,b);
            count</span>++<span style="color: #000000;">;
        }
    }
    c.d[k</span>++] =<span style="color: #000000;"> count;
    b.len</span>--<span style="color: #000000;">;
    
    </span><span style="color: #0000ff;">while</span>(b.len &gt;=<span style="color: #000000;"> conserve){
        </span><span style="color: #0000ff;">int</span> count = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span>(comparebig(t,b) != -<span style="color: #800080;">1</span><span style="color: #000000;">){
            t </span>=<span style="color: #000000;"> subbig(t,b);
            count</span>++<span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span>(comparebig(t,b) != -<span style="color: #800080;">1</span><span style="color: #000000;">){
                t </span>=<span style="color: #000000;"> subbig(t,b);
                count</span>++<span style="color: #000000;">;
            }
        }
        c.d[k</span>++] =<span style="color: #000000;"> count;
        b.len</span>--<span style="color: #000000;">;
    }
    c.len </span>=<span style="color: #000000;"> k;
    reminder </span>=<span style="color: #000000;"> t;
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> c;
}
</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> show(bignum c){
    </span><span style="color: #0000ff;">int</span> lenth =<span style="color: #000000;"> c.len;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;lenth;i++) printf(<span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span><span style="color: #000000;">,c.d[i]);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> tempa[MAXN];
    </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> tempb[MAXN];
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%s</span><span style="color: #800000;">"</span><span style="color: #000000;">,tempa);
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%s</span><span style="color: #800000;">"</span><span style="color: #000000;">,tempb);
    bignum a(tempa),b(tempb);
    </span><span style="color: #0000ff;">if</span>(comparebig(a,b) == -<span style="color: #800080;">1</span><span style="color: #000000;">){
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">a / b\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">quotient = 0\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">reminder = </span><span style="color: #800000;">"</span><span style="color: #000000;">);
        show(a);
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
    bignum c </span>=<span style="color: #000000;"> divided_optimised(a,b);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">a / b\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">quotient = </span><span style="color: #800000;">"</span><span style="color: #000000;">);
    show(c);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">reminder = </span><span style="color: #800000;">"</span><span style="color: #000000;">);
    show(reminder);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>数学问题</title><link>http://www.cnblogs.com/icodes8238/archive/2020/02/11/12295037.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Tue, 11 Feb 2020 07:32:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/02/11/12295037.html</guid><description><![CDATA[<p><strong>最大公约数gcd&nbsp;与&nbsp;最小公倍数lcm</strong></p>
<p>欧几里得算法（辗转相除法） gcd(a,b) = gcd(b, a%b)</p>
<p>lcm(a,b) = a / gcd(a,b) * b</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">int</span> gcd(<span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span><span style="color: #000000;"> b){
    </span><span style="color: #0000ff;">if</span>(b == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> a;
    </span><span style="color: #0000ff;">return</span> gcd(b,a%<span style="color: #000000;">b);
}
</span><span style="color: #0000ff;">int</span> lcm(<span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span><span style="color: #000000;"> b){
    </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> gcd(a,b);
    </span><span style="color: #0000ff;">return</span> a/t*<span style="color: #000000;">b;
}</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;<strong>质因子分解</strong></p>
<p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805415005503488" target="_blank">PAT A1059&nbsp;Prime Factors&nbsp;</a></p>
<div class="cnblogs_code">
<pre>#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt;<span style="color: #000000;">
#include</span>&lt;cmath&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">bool</span> b[<span style="color: #800080;">10000000</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span> prime[<span style="color: #800080;">100000</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span> findprime(<span style="color: #0000ff;">int</span> s){  <span style="color: #008000;">//</span><span style="color: #008000;">long int 即 int </span>
    <span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> sqrt(s);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">2</span>;i&lt;=n;i++) b[i] = <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">2</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(b[i] == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">2</span>*i;j&lt;n;j=j+i) b[j] = <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">一个数的n倍都不是素数 </span>
<span style="color: #000000;">    }
    </span><span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;=n;i++<span style="color: #000000;">)
        </span><span style="color: #0000ff;">if</span>(b[i] == <span style="color: #800080;">1</span><span style="color: #000000;">)
            prime[k</span>++] =<span style="color: #000000;"> i;
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> k;
}
</span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> factor{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> num;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> times;
}fac[</span><span style="color: #800080;">10</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">由于最小的10个素数乘积大于int能表示的范围</span>
 
<span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> s;
    cin</span>&gt;&gt;<span style="color: #000000;">s;
    </span><span style="color: #0000ff;">if</span>(s == <span style="color: #800080;">1</span><span style="color: #000000;">){
        cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">1=1</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;    
    }
    </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> s;
    </span><span style="color: #0000ff;">int</span> k =<span style="color: #000000;"> findprime(s);
    </span><span style="color: #0000ff;">int</span> m = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;k;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(s % prime[i] == <span style="color: #800080;">0</span><span style="color: #000000;">){
            fac[m].times </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            fac[m].num </span>=<span style="color: #000000;"> prime[i];
            </span><span style="color: #0000ff;">while</span>(s % prime[i] == <span style="color: #800080;">0</span><span style="color: #000000;">){
                fac[m].times</span>++<span style="color: #000000;">;
                s </span>= s/<span style="color: #000000;">prime[i];
            }
            m</span>++<span style="color: #000000;">;    
        }    
    }
    </span><span style="color: #0000ff;">if</span>(s != <span style="color: #800080;">1</span><span style="color: #000000;">){
        fac[m].num </span>=<span style="color: #000000;"> s;
        fac[m</span>++].times = <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
    cout</span>&lt;&lt;t&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">=</span><span style="color: #800000;">"</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;m;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(fac[i].times == <span style="color: #800080;">1</span>) cout&lt;&lt;<span style="color: #000000;">fac[i].num;
        </span><span style="color: #0000ff;">if</span>(fac[i].times &gt; <span style="color: #800080;">1</span>) cout&lt;&lt;fac[i].num&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">^</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">fac[i].times;
        </span><span style="color: #0000ff;">if</span>(i&lt;m-<span style="color: #800080;">1</span>) cout&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">*</span><span style="color: #800000;">"</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>&nbsp;</p>
<p>应用：</p>
<p><a class="link color-default" href="https://www.luogu.com.cn/problem/P1029" data-v-445f91a0="" data-v-5ccef6e7=""><span class="pid" data-v-5ccef6e7="">P1029&nbsp;最大公约数和最小公倍数问题</span></a></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('120971a9-1cf6-496f-9164-9d15508bb122')"><img id="code_img_closed_120971a9-1cf6-496f-9164-9d15508bb122" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_120971a9-1cf6-496f-9164-9d15508bb122" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('120971a9-1cf6-496f-9164-9d15508bb122',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_120971a9-1cf6-496f-9164-9d15508bb122" class="cnblogs_code_hide">
<pre>#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cmath&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">bool</span> b[<span style="color: #800080;">10000000</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span> prime[<span style="color: #800080;">100000</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> count; 
</span><span style="color: #0000ff;">int</span> findprime(<span style="color: #0000ff;">int</span> s){  <span style="color: #008000;">//</span><span style="color: #008000;">long int 即 int </span>
    <span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> sqrt(s);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">2</span>;i&lt;=n;i++) b[i] = <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">2</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(b[i] == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">2</span>*i;j&lt;n;j=j+i) b[j] = <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">一个数的n倍都不是素数 </span>
<span style="color: #000000;">    }
    </span><span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;=n;i++<span style="color: #000000;">)
        </span><span style="color: #0000ff;">if</span>(b[i] == <span style="color: #800080;">1</span><span style="color: #000000;">)
            prime[k</span>++] =<span style="color: #000000;"> i;
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> k;
}
</span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> factor{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> num;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> times;
}fac[</span><span style="color: #800080;">10</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">由于最小的10个素数乘积大于int能表示的范围</span>
 
<span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> x,y;
    cin</span>&gt;&gt;x&gt;&gt;<span style="color: #000000;">y;
    </span><span style="color: #0000ff;">if</span>(y%x != <span style="color: #800080;">0</span><span style="color: #000000;">){
        cout</span>&lt;&lt;<span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">int</span> s = y/<span style="color: #000000;">x;
    </span><span style="color: #0000ff;">int</span> k =<span style="color: #000000;"> findprime(s);
    </span><span style="color: #0000ff;">int</span> m = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;k;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(s % prime[i] == <span style="color: #800080;">0</span><span style="color: #000000;">){
            fac[m].times </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            fac[m].num </span>=<span style="color: #000000;"> prime[i];
            </span><span style="color: #0000ff;">while</span>(s % prime[i] == <span style="color: #800080;">0</span><span style="color: #000000;">){
                fac[m].times</span>++<span style="color: #000000;">;
                s </span>= s/<span style="color: #000000;">prime[i];
            }
            m</span>++<span style="color: #000000;">;    
        }    
    }
    </span><span style="color: #0000ff;">if</span>(s != <span style="color: #800080;">1</span><span style="color: #000000;">){
        fac[m].num </span>=<span style="color: #000000;"> s;
        fac[m</span>++].times = <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;m;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(fac[i].times &gt; <span style="color: #800080;">0</span>) count++<span style="color: #000000;">;
    }
    cout</span>&lt;&lt;(<span style="color: #800080;">1</span>&lt;&lt;count); <span style="color: #008000;">//</span><span style="color: #008000;"> 2^count</span>
    <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>题解：（来源<a href="https://sochiji.blog.luogu.org/solution-p1029" target="_blank">https://sochiji.blog.luogu.org/solution-p1029</a>）</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1726496/202002/1726496-20200211162426994-374555257.png" alt="" width="787" height="512" /></p>
<p><img src="https://img2018.cnblogs.com/i-beta/1726496/202002/1726496-20200211162502282-306003990.png" alt="" width="786" height="461" /></p>
<p>&nbsp;</p>]]></description></item><item><title>AVL Tree</title><link>http://www.cnblogs.com/icodes8238/archive/2020/02/11/12294678.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Tue, 11 Feb 2020 05:14:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/02/11/12294678.html</guid><description><![CDATA[<p>《算法笔记》P320</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200211
</span><span style="color: #008000;">//</span><span style="color: #008000;">AVL Tree</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> node{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> data;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> height;
    node</span>*<span style="color: #000000;"> left;
    node</span>*<span style="color: #000000;"> right;
};
node</span>* newnode(<span style="color: #0000ff;">int</span><span style="color: #000000;"> v){
    node</span>* p = <span style="color: #0000ff;">new</span><span style="color: #000000;"> node;
    p</span>-&gt;data =<span style="color: #000000;"> v;
    p</span>-&gt;height = <span style="color: #800080;">1</span><span style="color: #000000;">;
    p</span>-&gt;left =<span style="color: #000000;"> NULL;
    p</span>-&gt;right =<span style="color: #000000;"> NULL;
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> p;
}
</span><span style="color: #0000ff;">int</span> getHeight(node*<span style="color: #000000;"> root){
    </span><span style="color: #0000ff;">if</span>(root == NULL) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">return</span> root-&gt;<span style="color: #000000;">height;
}
</span><span style="color: #0000ff;">int</span> getBalanceFactor(node*<span style="color: #000000;"> root){
    </span><span style="color: #0000ff;">if</span>(root == NULL) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">return</span> getHeight(root-&gt;left) - getHeight(root-&gt;<span style="color: #000000;">right);
}
</span><span style="color: #0000ff;">void</span> updateHeight(node*<span style="color: #000000;"> root){
    root</span>-&gt;height = max(getHeight(root-&gt;left) , getHeight(root-&gt;right)) + <span style="color: #800080;">1</span><span style="color: #000000;">;
}
node</span>* search(node* root,<span style="color: #0000ff;">int</span><span style="color: #000000;"> v){
    </span><span style="color: #0000ff;">if</span>(root == NULL) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
    </span><span style="color: #0000ff;">if</span>(root-&gt;data == v) <span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(v &lt; root-&gt;data) search(root-&gt;<span style="color: #000000;">left,v);
    </span><span style="color: #0000ff;">else</span> search(root-&gt;<span style="color: #000000;">right,v);
}
</span><span style="color: #0000ff;">void</span> leftrotation(node* &amp;<span style="color: #000000;">root){
    node</span>* temp = root-&gt;<span style="color: #000000;">right;
    root</span>-&gt;right = temp-&gt;<span style="color: #000000;">left;
    temp</span>-&gt;left =<span style="color: #000000;"> root;
    updateHeight(root);
    updateHeight(temp);
    root </span>=<span style="color: #000000;"> temp;
}
</span><span style="color: #0000ff;">void</span> rightrotation(node* &amp;<span style="color: #000000;">root){
    node</span>* temp = root-&gt;<span style="color: #000000;">left;
    root</span>-&gt;left = temp-&gt;<span style="color: #000000;">right;
    temp</span>-&gt;right =<span style="color: #000000;"> root;
    updateHeight(root);
    updateHeight(temp);
    root </span>=<span style="color: #000000;"> temp;
}
</span><span style="color: #0000ff;">void</span> insert(node* &amp;root,<span style="color: #0000ff;">int</span><span style="color: #000000;"> v){
    </span><span style="color: #0000ff;">if</span>(root ==<span style="color: #000000;"> NULL){
        root </span>=<span style="color: #000000;"> newnode(v);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    }
    </span><span style="color: #0000ff;">if</span>(v &gt;= root-&gt;<span style="color: #000000;">data){
        insert(root</span>-&gt;<span style="color: #000000;">right,v);
        updateHeight(root);
        </span><span style="color: #0000ff;">if</span>(getBalanceFactor(root) == -<span style="color: #800080;">2</span><span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(getBalanceFactor(root-&gt;right) == -<span style="color: #800080;">1</span><span style="color: #000000;">)
                leftrotation(root);
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(getBalanceFactor(root-&gt;right) == <span style="color: #800080;">1</span><span style="color: #000000;">){
                rightrotation(root</span>-&gt;<span style="color: #000000;">right);
                leftrotation(root);
            }
        }
    }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(v &lt; root-&gt;<span style="color: #000000;">data){
        insert(root</span>-&gt;<span style="color: #000000;">left,v);
        updateHeight(root);
        </span><span style="color: #0000ff;">if</span>(getBalanceFactor(root) == <span style="color: #800080;">2</span><span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(getBalanceFactor(root-&gt;left) == <span style="color: #800080;">1</span><span style="color: #000000;">)
                rightrotation(root);
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(getBalanceFactor(root-&gt;left) == -<span style="color: #800080;">1</span><span style="color: #000000;">){
                leftrotation(root</span>-&gt;<span style="color: #000000;">left);
                rightrotation(root);
            }
        }    
    }
    
}
node</span>* buildAVL(<span style="color: #0000ff;">int</span> data[],<span style="color: #0000ff;">int</span><span style="color: #000000;"> n){
    node</span>* root =<span style="color: #000000;"> NULL;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">) insert(root,data[i]);
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
}
</span><span style="color: #0000ff;">void</span> InOrder(node *<span style="color: #000000;">T){
    </span><span style="color: #0000ff;">if</span>(T!=<span style="color: #000000;">NULL){
        InOrder(T</span>-&gt;<span style="color: #000000;">left);
        cout</span>&lt;&lt;T-&gt;data&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
        InOrder(T</span>-&gt;<span style="color: #000000;">right);
    }
}
</span><span style="color: #0000ff;">void</span> PreOrder(node *<span style="color: #000000;">T){
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(T){
        cout</span>&lt;&lt;T-&gt;data&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
        PreOrder(T</span>-&gt;<span style="color: #000000;">left);
        PreOrder(T</span>-&gt;<span style="color: #000000;">right);
    }
}

</span><span style="color: #0000ff;">void</span> PostOrder(node *<span style="color: #000000;">T){
    </span><span style="color: #0000ff;">if</span>(T!=<span style="color: #000000;">NULL){
        PostOrder(T</span>-&gt;<span style="color: #000000;">left);
        PostOrder(T</span>-&gt;<span style="color: #000000;">right);
        cout</span>&lt;&lt;T-&gt;data&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
    }
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span> n,data[<span style="color: #800080;">100</span><span style="color: #000000;">];
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">n);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++) scanf(<span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">data[i]);
    node</span>* root =<span style="color: #000000;"> buildAVL(data,n);
    cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">InOrder:</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    InOrder(root);
    cout</span>&lt;&lt;<span style="color: #000000;">endl;
    cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">PreOrder:</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    PreOrder(root);
    cout</span>&lt;&lt;<span style="color: #000000;">endl;
    cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">PostOrder:</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    PostOrder(root); 
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}
</span><span style="color: #008000;">/*</span><span style="color: #008000;">----Test---
10
60 50 80 20 55 70 90 10 40 35
</span><span style="color: #008000;">*/</span></pre>
</div>
<p>测试数据图示：</p>
<p><img src="https://img2018.cnblogs.com/common/1726496/202002/1726496-20200211131409316-2020978590.jpg" alt="" /></p>]]></description></item><item><title>Huffman Code Tree</title><link>http://www.cnblogs.com/icodes8238/archive/2020/02/10/12292890.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Mon, 10 Feb 2020 13:36:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/02/10/12292890.html</guid><description><![CDATA[<p>实现将编码转化为字母文本</p>
<p>代码1：（20191207）</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('e7a6f1a3-631b-49db-b266-5a9144a6b854')"><img id="code_img_closed_e7a6f1a3-631b-49db-b266-5a9144a6b854" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_e7a6f1a3-631b-49db-b266-5a9144a6b854" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('e7a6f1a3-631b-49db-b266-5a9144a6b854',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_e7a6f1a3-631b-49db-b266-5a9144a6b854" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Internal nodes and leaf nodes are represented by the same classes(struct)</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;stdlib.h&gt;
<span style="color: #0000ff;">#define</span> inf 99999
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> k;
typedef </span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> Node{
    </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> data;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> weight;
    Node</span>*<span style="color: #000000;"> left;
    Node</span>*<span style="color: #000000;"> right;
    </span><span style="color: #0000ff;">int</span> state;<span style="color: #008000;">//</span><span style="color: #008000;">0:leaf&amp;unbook; 1:inter&amp;unbook; 2:book;</span><span style="color: #008000;">//</span><span style="color: #008000;">3:inter&amp;book</span>
<span style="color: #000000;">}Node;
Node leaf[</span><span style="color: #800080;">201</span><span style="color: #000000;">];
Node</span>* root = (Node*)<span style="color: #0000ff;">malloc</span>(<span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(Node));
Node</span>* cur = (Node*)<span style="color: #0000ff;">malloc</span>(<span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(Node));
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> minimal(){
    </span><span style="color: #0000ff;">int</span> minn =<span style="color: #000000;"> inf;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> index;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;<span style="color: #800080;">2</span>*n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>((leaf[i].state!=<span style="color: #800080;">2</span>) &amp;&amp; leaf[i].weight&lt;<span style="color: #000000;">minn) {
            minn </span>=<span style="color: #000000;"> leaf[i].weight;
            index </span>=<span style="color: #000000;"> i;
        }
    }
    leaf[index].state </span>= <span style="color: #800080;">2</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> index;
}

</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> merge(){
    </span><span style="color: #0000ff;">int</span> min1 =<span style="color: #000000;"> minimal();
    </span><span style="color: #0000ff;">int</span> min2 =<span style="color: #000000;"> minimal();
    leaf[n</span>+k].weight = leaf[min1].weight +<span style="color: #000000;"> leaf[min2].weight;
    leaf[n</span>+k].left = &amp;<span style="color: #000000;">leaf[min1];
    leaf[n</span>+k].right = &amp;<span style="color: #000000;">leaf[min2];
    root </span>= &amp;leaf[n+<span style="color: #000000;">k];
    k</span>++<span style="color: #000000;">;
}

</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> finish(){
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">)
        </span><span style="color: #0000ff;">if</span>(leaf[i].state==<span style="color: #800080;">0</span><span style="color: #000000;">) 
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    cin</span>&gt;&gt;<span style="color: #000000;">n;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">) {
        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> t;
        cin</span>&gt;&gt;<span style="color: #000000;">t;
        leaf[i].weight </span>=<span style="color: #000000;"> t;
        leaf[i].state </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=n;i&lt;<span style="color: #800080;">2</span>*n;i++) leaf[i].weight=<span style="color: #000000;">inf;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> t;
        cin</span>&gt;&gt;<span style="color: #000000;">t;
        leaf[i].data</span>=<span style="color: #000000;">t;
    } 
    </span><span style="color: #0000ff;">while</span>(!<span style="color: #000000;">finish()){
        merge();
    }
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> m;
    cin</span>&gt;&gt;<span style="color: #000000;">m;
    cur </span>=<span style="color: #000000;"> root;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;m;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> t;
        cin</span>&gt;&gt;<span style="color: #000000;">t;
        </span><span style="color: #0000ff;">if</span>(t==<span style="color: #800080;">0</span><span style="color: #000000;">){
            cur </span>= cur-&gt;<span style="color: #000000;">left;
            </span><span style="color: #0000ff;">if</span>(cur-&gt;data!=<span style="color: #800000;">'</span><span style="color: #800000;">\0</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                cout</span>&lt;&lt;cur-&gt;data&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
                cur </span>=<span style="color: #000000;"> root;
                </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            }
        }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
            cur </span>= cur-&gt;<span style="color: #000000;">right; 
            </span><span style="color: #0000ff;">if</span>(cur-&gt;data!=<span style="color: #800000;">'</span><span style="color: #800000;">\0</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                cout</span>&lt;&lt;cur-&gt;data&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
                cur </span>=<span style="color: #000000;"> root;
                </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            }
        }
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}
</span><span style="color: #008000;">/*</span><span style="color: #008000;">-----Test-------
8
2 7 24 32 37 42 42 120
z k m c u d l e
10
1 0 1 1 0 1 1 0 0 0
//test1 
9
2 7 24 32 37 42 42 120 307
b i r y a d p h t
55
0 0 0 1 0 0 0 1 1 0 0 1 1 0 0 1 1 1 0 0 1 1 1 1 0 0 0 1 1 1 1 0 1 0 1 1 1 1 1 1 0 0 0 1 0 1 0 1 0 0 0 1 1 1 0
//00 0100 0110 0110 01110 0111100 0111101 01111 1 100 0101 0100 01110
//test2- from notes(unsolved)
8
2 3 10 10 10 15 20 20
Q Z F M T S O E
3
0 0 0
</span><span style="color: #008000;">*/</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>代码2：（优先队列20200210）</p>
<div class="cnblogs_code">
<pre>#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;queue&gt;<span style="color: #000000;">
#include</span>&lt;<span style="color: #0000ff;">string</span>.h&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> Node{
    </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> data;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> weight;
    Node</span>*<span style="color: #000000;"> left;
    Node</span>*<span style="color: #000000;"> right;
    friend </span><span style="color: #0000ff;">bool</span> <span style="color: #0000ff;">operator</span> &lt;<span style="color: #000000;"> (Node a,Node b){
        </span><span style="color: #0000ff;">if</span>(a.weight == b.weight) <span style="color: #0000ff;">return</span> a.data &gt;<span style="color: #000000;"> b.data;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> a.weight &gt;<span style="color: #000000;"> b.weight;
    }
};

priority_queue</span>&lt;Node&gt;<span style="color: #000000;">q;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span> n; <span style="color: #008000;">//</span><span style="color: #008000;"> the number of char</span>
    scanf(<span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">n);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">){
        Node temp;
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %c\n</span><span style="color: #800000;">"</span>,&amp;temp.weight,&amp;<span style="color: #000000;">temp.data);
        q.push(temp);
    }
    </span><span style="color: #0000ff;">char</span> str[<span style="color: #800080;">1000</span><span style="color: #000000;">];
    fgets(str,</span><span style="color: #800080;">1000</span><span style="color: #000000;">,stdin);
    </span><span style="color: #0000ff;">while</span>(q.size()&gt;<span style="color: #800080;">1</span><span style="color: #000000;">){
        Node</span>* t1 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Node;
        </span>*t1 =<span style="color: #000000;"> q.top();
        q.pop();
        Node</span>* t2 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Node;
        </span>*t2 =<span style="color: #000000;"> q.top();
        q.pop();
        Node tn;
        tn.weight </span>= t1-&gt;weight + t2-&gt;<span style="color: #000000;">weight;
        tn.left </span>=<span style="color: #000000;"> t1;
        tn.right </span>=<span style="color: #000000;"> t2;
        q.push(tn);
    }
    Node</span>* root = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Node;
    </span>*root =<span style="color: #000000;"> q.top();
    Node</span>* cur =<span style="color: #000000;"> root;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;strlen(str);i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(str[i] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;"> ){
            cur </span>= cur-&gt;<span style="color: #000000;">left;
            </span><span style="color: #0000ff;">if</span>(cur-&gt;data != <span style="color: #800000;">'</span><span style="color: #800000;">\0</span><span style="color: #800000;">'</span><span style="color: #000000;">){
                printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%c</span><span style="color: #800000;">"</span>,cur-&gt;<span style="color: #000000;">data);
                cur </span>=<span style="color: #000000;"> root;
            }
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(str[i] == <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span><span style="color: #000000;"> ){
            cur </span>= cur-&gt;<span style="color: #000000;">right;
            </span><span style="color: #0000ff;">if</span>(cur-&gt;data != <span style="color: #800000;">'</span><span style="color: #800000;">\0</span><span style="color: #800000;">'</span><span style="color: #000000;">){
                printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%c</span><span style="color: #800000;">"</span>,cur-&gt;<span style="color: #000000;">data);
                cur </span>=<span style="color: #000000;"> root;
            }
        }
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>代码2的测试数据：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('f0ab16b5-3e6d-4b73-ae21-7a7938d44466')"><img id="code_img_closed_f0ab16b5-3e6d-4b73-ae21-7a7938d44466" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_f0ab16b5-3e6d-4b73-ae21-7a7938d44466" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('f0ab16b5-3e6d-4b73-ae21-7a7938d44466',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_f0ab16b5-3e6d-4b73-ae21-7a7938d44466" class="cnblogs_code_hide">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">-----Test-------
//ddue
8
2 z
7 k
24 m
32 c
37 u
42 d
42 l
120 e
1011011000
//happybirthday 
9
2 b
7 i
24 r
32 y
37 a
42 d
42 p
120 h
307 t
0001000110011001110011110001111010111111000101010001110
//test2- from notes E
8
2 Q
3 Z
10 F
10 M
10 T
15 S
20 O
20 E
000
</span><span style="color: #008000;">*/</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>]]></description></item><item><title>BST 二叉搜索树</title><link>http://www.cnblogs.com/icodes8238/archive/2020/02/10/12292465.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Mon, 10 Feb 2020 12:08:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/02/10/12292465.html</guid><description><![CDATA[<p>二叉搜索树结点的查找、插入、删除</p>
<p>1.循环写法：（20191119）</p>
<p>BST build &amp; traverse</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('89283500-a654-44c2-940f-a8cf31d29a72')"><img id="code_img_closed_89283500-a654-44c2-940f-a8cf31d29a72" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_89283500-a654-44c2-940f-a8cf31d29a72" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('89283500-a654-44c2-940f-a8cf31d29a72',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_89283500-a654-44c2-940f-a8cf31d29a72" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20191116
</span><span style="color: #008000;">//</span><span style="color: #008000;">BST build &amp; traverse</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;stdlib.h&gt;

<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

typedef </span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> BSTNode{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> value;
    </span><span style="color: #0000ff;">struct</span> BSTNode *<span style="color: #000000;">left;
    </span><span style="color: #0000ff;">struct</span> BSTNode *<span style="color: #000000;">right;
}BSTNode; 
BSTNode </span>*root = (BSTNode*)<span style="color: #0000ff;">malloc</span>(<span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(BSTNode));

</span><span style="color: #0000ff;">void</span> buildBST(<span style="color: #0000ff;">int</span> n,<span style="color: #0000ff;">int</span><span style="color: #000000;"> data[]){
    root</span>-&gt;value = data[<span style="color: #800080;">0</span><span style="color: #000000;">];
    root</span>-&gt;left =<span style="color: #000000;"> NULL;
    root</span>-&gt;right =<span style="color: #000000;"> NULL;
    BSTNode </span>*p =<span style="color: #000000;"> root;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;n;i++<span style="color: #000000;">){
        p </span>=<span style="color: #000000;"> root;
        BSTNode </span>*t = (BSTNode*)<span style="color: #0000ff;">malloc</span>(<span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(BSTNode));
        t</span>-&gt;value =<span style="color: #000000;"> data[i];
        t</span>-&gt;left =<span style="color: #000000;"> NULL; 
        t</span>-&gt;right =<span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">while</span>(<span style="color: #800080;">1</span><span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(t-&gt;value &lt; p-&gt;<span style="color: #000000;">value){
                </span><span style="color: #0000ff;">if</span>(p-&gt;left!=<span style="color: #000000;">NULL){
                    p </span>= p-&gt;<span style="color: #000000;">left;    
                }</span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    p</span>-&gt;left =<span style="color: #000000;">t;
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(t-&gt;value &gt;= p-&gt;<span style="color: #000000;">value){
                </span><span style="color: #0000ff;">if</span>(p-&gt;right!=<span style="color: #000000;">NULL){
                    p </span>= p-&gt;<span style="color: #000000;">right;    
                }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
                    p</span>-&gt;right =<span style="color: #000000;">t;
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                } 
            }
        }
    }
}
</span><span style="color: #0000ff;">void</span> InOrder(BSTNode *<span style="color: #000000;">T){
    </span><span style="color: #0000ff;">if</span>(T!=<span style="color: #000000;">NULL){
        InOrder(T</span>-&gt;<span style="color: #000000;">left);
        cout</span>&lt;&lt;T-&gt;value&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
        InOrder(T</span>-&gt;<span style="color: #000000;">right);
    }
}
</span><span style="color: #0000ff;">void</span> PreOrder(BSTNode *<span style="color: #000000;">T){
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(T){
        cout</span>&lt;&lt;T-&gt;value&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
        PreOrder(T</span>-&gt;<span style="color: #000000;">left);
        PreOrder(T</span>-&gt;<span style="color: #000000;">right);
    }
}

</span><span style="color: #0000ff;">void</span> PostOrder(BSTNode *<span style="color: #000000;">T){
    </span><span style="color: #0000ff;">if</span>(T!=<span style="color: #000000;">NULL){
        PostOrder(T</span>-&gt;<span style="color: #000000;">left);
        PostOrder(T</span>-&gt;<span style="color: #000000;">right);
        cout</span>&lt;&lt;T-&gt;value&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
    }
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span> data[<span style="color: #800080;">100</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
    cin</span>&gt;&gt;<span style="color: #000000;">n;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">){
        cin</span>&gt;&gt;<span style="color: #000000;">data[i];
    }
    buildBST(n,data);
    cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">InOrder:</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    InOrder(root);</span><span style="color: #008000;">//</span><span style="color: #008000;">中序遍历结果按从小到大顺序输出</span>
    cout&lt;&lt;<span style="color: #000000;">endl;
    cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">PreOrder:</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    PreOrder(root);
    cout</span>&lt;&lt;<span style="color: #000000;">endl;
    cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">PostOrder:</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    PostOrder(root); 
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}
</span><span style="color: #008000;">/*</span><span style="color: #008000;">------test-------
10
5 3 2 8 4 1 9 7 0 6
10
6 1 3 0 5 3 9 4 8 2
</span><span style="color: #008000;">*/</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>BST insert &amp; delete</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('0d1d0c17-7c59-4bf8-abf6-d53c75199bc0')"><img id="code_img_closed_0d1d0c17-7c59-4bf8-abf6-d53c75199bc0" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_0d1d0c17-7c59-4bf8-abf6-d53c75199bc0" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('0d1d0c17-7c59-4bf8-abf6-d53c75199bc0',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_0d1d0c17-7c59-4bf8-abf6-d53c75199bc0" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20191119
</span><span style="color: #008000;">//</span><span style="color: #008000;">BST insert &amp; delete</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;stdlib.h&gt;<span style="color: #000000;">
#include</span>&lt;<span style="color: #0000ff;">string</span>.h&gt;

<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #008000;">//</span><span style="color: #008000;">定义结点 </span>
typedef <span style="color: #0000ff;">struct</span><span style="color: #000000;"> BSTNode{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> value;
    </span><span style="color: #0000ff;">struct</span> BSTNode *<span style="color: #000000;">left;
    </span><span style="color: #0000ff;">struct</span> BSTNode *<span style="color: #000000;">right;
}BSTNode; 
</span><span style="color: #008000;">//</span><span style="color: #008000;">函数声明 </span>
<span style="color: #0000ff;">void</span> buildBST(<span style="color: #0000ff;">int</span> ,<span style="color: #0000ff;">int</span><span style="color: #000000;"> []);
</span><span style="color: #0000ff;">void</span> insertnode(<span style="color: #0000ff;">int</span><span style="color: #000000;"> );
BSTNode</span>* findnode(<span style="color: #0000ff;">int</span><span style="color: #000000;"> );
BSTNode</span>* findparent(<span style="color: #0000ff;">int</span><span style="color: #000000;"> );
</span><span style="color: #0000ff;">void</span> delenode(<span style="color: #0000ff;">int</span><span style="color: #000000;"> );
</span><span style="color: #0000ff;">void</span> InOrder(BSTNode *<span style="color: #000000;">);
BSTNode</span>* succ(<span style="color: #0000ff;">int</span><span style="color: #000000;"> );
</span><span style="color: #008000;">//</span><span style="color: #008000;">全局变量root根节点 </span>
BSTNode *root = (BSTNode*)<span style="color: #0000ff;">malloc</span>(<span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(BSTNode));
BSTNode </span>*p =<span style="color: #000000;"> root;

</span><span style="color: #0000ff;">void</span> buildBST(<span style="color: #0000ff;">int</span> n,<span style="color: #0000ff;">int</span><span style="color: #000000;"> data[]){
    root</span>-&gt;value = data[<span style="color: #800080;">0</span><span style="color: #000000;">];
    root</span>-&gt;left =<span style="color: #000000;"> NULL;
    root</span>-&gt;right =<span style="color: #000000;"> NULL;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;n;i++<span style="color: #000000;">){
        insertnode(data[i]);
    }
}
</span><span style="color: #0000ff;">void</span> insertnode(<span style="color: #0000ff;">int</span><span style="color: #000000;"> v){
    p </span>=<span style="color: #000000;"> root;
    BSTNode </span>*t = (BSTNode*)<span style="color: #0000ff;">malloc</span>(<span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(BSTNode));
    t</span>-&gt;value =<span style="color: #000000;"> v;
    t</span>-&gt;left =<span style="color: #000000;"> NULL; 
    t</span>-&gt;right =<span style="color: #000000;"> NULL;
    </span><span style="color: #0000ff;">while</span>(<span style="color: #800080;">1</span><span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(t-&gt;value &lt; p-&gt;<span style="color: #000000;">value){
            </span><span style="color: #0000ff;">if</span>(p-&gt;left!=<span style="color: #000000;">NULL){
                p </span>= p-&gt;<span style="color: #000000;">left;    
            }</span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                p</span>-&gt;left =<span style="color: #000000;">t;
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
        }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(t-&gt;value &gt;= p-&gt;<span style="color: #000000;">value){
            </span><span style="color: #0000ff;">if</span>(p-&gt;right!=<span style="color: #000000;">NULL){
                p </span>= p-&gt;<span style="color: #000000;">right;    
            }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
                p</span>-&gt;right =<span style="color: #000000;">t;
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            } 
        }
    }
}
BSTNode</span>* findnode(<span style="color: #0000ff;">int</span><span style="color: #000000;"> t){
    BSTNode </span>*c =<span style="color: #000000;"> root;
    </span><span style="color: #0000ff;">while</span>(<span style="color: #800080;">1</span><span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(t &lt; c-&gt;value &amp;&amp; c-&gt;left!=<span style="color: #000000;">NULL){
            c </span>= c-&gt;<span style="color: #000000;">left;    
        }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(t &gt; c-&gt;value &amp;&amp; c-&gt;right!=<span style="color: #000000;">NULL){
            c </span>= c-&gt;<span style="color: #000000;">right;    
        }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(t == c-&gt;<span style="color: #000000;">value){
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> c;
        }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
    }
} 
BSTNode</span>* findparent(BSTNode *<span style="color: #000000;">m){
    BSTNode </span>*c =<span style="color: #000000;"> root;
    </span><span style="color: #0000ff;">while</span>(<span style="color: #800080;">1</span><span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>((c-&gt;left!=NULL &amp;&amp; m == c-&gt;left) || (c-&gt;right!=NULL &amp;&amp; m == c-&gt;right)){<span style="color: #008000;">//</span><span style="color: #008000;">解决了结点关键码相等的问题 </span>
            <span style="color: #0000ff;">return</span><span style="color: #000000;"> c;
        }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(m-&gt;value &lt; c-&gt;value &amp;&amp; c-&gt;left!=<span style="color: #000000;">NULL){
            c </span>= c-&gt;<span style="color: #000000;">left;    
        }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(m-&gt;value &gt;= c-&gt;value &amp;&amp; c-&gt;right!=<span style="color: #000000;">NULL){
            c </span>= c-&gt;<span style="color: #000000;">right;    
        }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
    }
} 
BSTNode</span>* succ(BSTNode *<span style="color: #000000;">m){
    m </span>= m-&gt;<span style="color: #000000;">right;
    </span><span style="color: #0000ff;">while</span>(m-&gt;left !=<span style="color: #000000;"> NULL){
        m </span>= m-&gt;<span style="color: #000000;">left;
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">cout&lt;&lt;m-&gt;value;</span>
    <span style="color: #0000ff;">return</span><span style="color: #000000;"> m;
}

</span><span style="color: #0000ff;">void</span> delenode(BSTNode *<span style="color: #000000;">m){ 
    BSTNode </span>*pre =<span style="color: #000000;"> findparent(m);
    
    </span><span style="color: #0000ff;">if</span>(m-&gt;left!=NULL &amp;&amp; m-&gt;right!=NULL){<span style="color: #008000;">//</span><span style="color: #008000;">两边都有 </span>
        BSTNode *t =succ(m);<span style="color: #008000;">//</span><span style="color: #008000;">一个结点的后继结点必无左孩子</span>
        pre =findparent(t);<span style="color: #008000;">//</span><span style="color: #008000;">先找父节点，不然出问题 </span>
        m-&gt;value = t-&gt;<span style="color: #000000;">value;
        </span><span style="color: #0000ff;">if</span>(t == pre-&gt;<span style="color: #000000;">left){
            pre</span>-&gt;left = t-&gt;<span style="color: #000000;">right;
        }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(t == pre-&gt;<span style="color: #000000;">right){
            pre</span>-&gt;right = t-&gt;<span style="color: #000000;">right;
        }     
    }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(m == root){<span style="color: #008000;">//</span><span style="color: #008000;">考虑根节点没有父节点的情况 </span>
        <span style="color: #0000ff;">if</span>(m-&gt;left != NULL) root = m-&gt;<span style="color: #000000;">left;
        </span><span style="color: #0000ff;">if</span>(m-&gt;right != NULL) root = m-&gt;<span style="color: #000000;">right;
        </span><span style="color: #0000ff;">if</span>(m-&gt;left == NULL &amp;&amp; m-&gt;right == NULL) cout&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">you can not delete the last vertex!</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    }
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(m == pre-&gt;<span style="color: #000000;">left){ 
        </span><span style="color: #0000ff;">if</span>(m-&gt;left ==<span style="color: #000000;"> NULL){
            pre</span>-&gt;left = m-&gt;<span style="color: #000000;">right;
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(m-&gt;right ==<span style="color: #000000;"> NULL){
            pre</span>-&gt;left = m-&gt;<span style="color: #000000;">left;
        }        
    }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(m== pre-&gt;<span style="color: #000000;">right){
        </span><span style="color: #0000ff;">if</span>(m-&gt;left ==<span style="color: #000000;"> NULL){
            pre</span>-&gt;right = m-&gt;<span style="color: #000000;">right;
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(m-&gt;right ==<span style="color: #000000;"> NULL){
            pre</span>-&gt;right = m-&gt;<span style="color: #000000;">left;
        }    
    }
}
</span><span style="color: #0000ff;">void</span> InOrder(BSTNode *<span style="color: #000000;">T){
    </span><span style="color: #0000ff;">if</span>(T!=<span style="color: #000000;">NULL){
        InOrder(T</span>-&gt;<span style="color: #000000;">left);
        cout</span>&lt;&lt;T-&gt;value&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
        InOrder(T</span>-&gt;<span style="color: #000000;">right);
    }
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span> data[<span style="color: #800080;">30</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
    cin</span>&gt;&gt;<span style="color: #000000;">n;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">){
        cin</span>&gt;&gt;<span style="color: #000000;">data[i];
    }
    buildBST(n,data);
    InOrder(root);
    cout</span>&lt;&lt;<span style="color: #000000;">endl;
    
    </span><span style="color: #0000ff;">for</span><span style="color: #000000;">(;;){
        </span><span style="color: #0000ff;">char</span> t[<span style="color: #800080;">100</span><span style="color: #000000;">];
        cin</span>&gt;&gt;<span style="color: #000000;">t;
        </span><span style="color: #0000ff;">if</span>(strcmp(t,<span style="color: #800000;">"</span><span style="color: #800000;">exit</span><span style="color: #800000;">"</span>)==<span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> d;
        
        </span><span style="color: #0000ff;">if</span>(strcmp(t,<span style="color: #800000;">"</span><span style="color: #800000;">insert</span><span style="color: #800000;">"</span>)==<span style="color: #800080;">0</span><span style="color: #000000;">) {
            cin</span>&gt;&gt;<span style="color: #000000;">d;
            insertnode(d);
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(strcmp(t,<span style="color: #800000;">"</span><span style="color: #800000;">delete</span><span style="color: #800000;">"</span>)==<span style="color: #800080;">0</span><span style="color: #000000;">){
            cin</span>&gt;&gt;<span style="color: #000000;">d;
            BSTNode </span>*m =<span style="color: #000000;"> findnode(d);
            </span><span style="color: #0000ff;">if</span>(!m) cout&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">it is not exits</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> delenode(m);    
        }
        InOrder(root);
        cout</span>&lt;&lt;<span style="color: #000000;">endl;
    }
    
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}
</span><span style="color: #008000;">/*</span><span style="color: #008000;">------test-------
10
5 3 2 8 4 1 9 7 0 6
10
6 1 3 0 5 3 9 4 8 2
delete 3
6
2 5 8 7 6 9
</span><span style="color: #008000;">*/</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p>2.递归写法：（20200210）</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200210</span>
#include&lt;iostream&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

typedef </span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> BSTNode{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> value;
    </span><span style="color: #0000ff;">struct</span> BSTNode *<span style="color: #000000;">left;
    </span><span style="color: #0000ff;">struct</span> BSTNode *<span style="color: #000000;">right;
}BSTNode; 

BSTNode</span>* newnode(<span style="color: #0000ff;">int</span><span style="color: #000000;"> v){
    BSTNode</span>* p = <span style="color: #0000ff;">new</span><span style="color: #000000;"> BSTNode;
    p</span>-&gt;value =<span style="color: #000000;"> v;
    p</span>-&gt;left =<span style="color: #000000;"> NULL;
    p</span>-&gt;right =<span style="color: #000000;"> NULL;
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> p;
}

BSTNode</span>* searchnode(BSTNode* root,<span style="color: #0000ff;">int</span><span style="color: #000000;"> data){
    </span><span style="color: #0000ff;">if</span>(root == NULL) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
    </span><span style="color: #0000ff;">if</span>(root-&gt;value == data) <span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(data &lt; root-&gt;value) searchnode(root-&gt;<span style="color: #000000;">left,data);
    </span><span style="color: #0000ff;">else</span> searchnode(root-&gt;<span style="color: #000000;">right,data);
}

</span><span style="color: #0000ff;">void</span> insertnode(BSTNode* &amp;root,<span style="color: #0000ff;">int</span><span style="color: #000000;"> data){
    </span><span style="color: #0000ff;">if</span>(root ==<span style="color: #000000;"> NULL){
        root </span>=<span style="color: #000000;"> newnode(data);
        </span><span style="color: #0000ff;">return</span> ; <span style="color: #008000;">//</span><span style="color: #008000;">recursion bounds</span>
<span style="color: #000000;">    }
    </span><span style="color: #0000ff;">if</span>(data &lt; root-&gt;value) insertnode(root-&gt;<span style="color: #000000;">left,data);
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(data &gt;= root-&gt;value) insertnode(root-&gt;<span style="color: #000000;">right,data);
}

BSTNode</span>* buildBST(<span style="color: #0000ff;">int</span> data[],<span style="color: #0000ff;">int</span><span style="color: #000000;"> n){
    BSTNode </span>*root =<span style="color: #000000;"> NULL;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">) insertnode(root,data[i]);
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
}
BSTNode</span>* findparent(BSTNode *root,BSTNode *<span style="color: #000000;">m){
    </span><span style="color: #0000ff;">if</span>(root-&gt;left == m || root-&gt;right == m) <span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(m == NULL) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(m-&gt;value &gt; root-&gt;value) findparent(root-&gt;<span style="color: #000000;">right,m);
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(m-&gt;value &lt; root-&gt;value) findparent(root-&gt;<span style="color: #000000;">left,m);
} 
BSTNode</span>* succ(BSTNode *<span style="color: #000000;">m){
    m </span>= m-&gt;<span style="color: #000000;">right;
    </span><span style="color: #0000ff;">while</span>(m-&gt;left !=<span style="color: #000000;"> NULL){
        m </span>= m-&gt;<span style="color: #000000;">left;
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> m;
}

</span><span style="color: #0000ff;">void</span> deletenode(BSTNode* &amp;root,<span style="color: #0000ff;">int</span><span style="color: #000000;"> v){ 
    BSTNode </span>*m =<span style="color: #000000;"> searchnode(root,v);
    BSTNode </span>*pre =<span style="color: #000000;"> findparent(root,m);
    </span><span style="color: #0000ff;">if</span>(m-&gt;left!=NULL &amp;&amp; m-&gt;right!=NULL){<span style="color: #008000;">//</span><span style="color: #008000;">两边都有 </span>
        BSTNode *t =succ(m);<span style="color: #008000;">//</span><span style="color: #008000;">一个结点的后继结点必无左孩子</span>
        pre =findparent(root,t);<span style="color: #008000;">//</span><span style="color: #008000;">先找父节点，不然出问题 </span>
        m-&gt;value = t-&gt;<span style="color: #000000;">value;
        </span><span style="color: #0000ff;">if</span>(t == pre-&gt;<span style="color: #000000;">left){
            pre</span>-&gt;left = t-&gt;<span style="color: #000000;">right;
        }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(t == pre-&gt;<span style="color: #000000;">right){
            pre</span>-&gt;right = t-&gt;<span style="color: #000000;">right;
        }     
    }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(m == root){<span style="color: #008000;">//</span><span style="color: #008000;">考虑根节点没有父节点的情况 </span>
        <span style="color: #0000ff;">if</span>(m-&gt;left != NULL) root = m-&gt;<span style="color: #000000;">left;
        </span><span style="color: #0000ff;">if</span>(m-&gt;right != NULL) root = m-&gt;<span style="color: #000000;">right;
        </span><span style="color: #0000ff;">if</span>(m-&gt;left == NULL &amp;&amp; m-&gt;right == NULL) cout&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">you can not delete the last vertex!</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    }
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(m == pre-&gt;<span style="color: #000000;">left){ 
        </span><span style="color: #0000ff;">if</span>(m-&gt;left ==<span style="color: #000000;"> NULL){
            pre</span>-&gt;left = m-&gt;<span style="color: #000000;">right;
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(m-&gt;right ==<span style="color: #000000;"> NULL){
            pre</span>-&gt;left = m-&gt;<span style="color: #000000;">left;
        }        
    }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(m== pre-&gt;<span style="color: #000000;">right){
        </span><span style="color: #0000ff;">if</span>(m-&gt;left ==<span style="color: #000000;"> NULL){
            pre</span>-&gt;right = m-&gt;<span style="color: #000000;">right;
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(m-&gt;right ==<span style="color: #000000;"> NULL){
            pre</span>-&gt;right = m-&gt;<span style="color: #000000;">left;
        }    
    }
}

</span><span style="color: #0000ff;">void</span> InOrder(BSTNode *<span style="color: #000000;">T){
    </span><span style="color: #0000ff;">if</span>(T!=<span style="color: #000000;">NULL){
        InOrder(T</span>-&gt;<span style="color: #000000;">left);
        cout</span>&lt;&lt;T-&gt;value&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
        InOrder(T</span>-&gt;<span style="color: #000000;">right);
    }
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span> data[<span style="color: #800080;">100</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
    cin</span>&gt;&gt;<span style="color: #000000;">n;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">){
        cin</span>&gt;&gt;<span style="color: #000000;">data[i];
    }
    BSTNode </span>*root =<span style="color: #000000;"> buildBST(data,n);
    cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">InOrder:</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    InOrder(root);</span><span style="color: #008000;">//</span><span style="color: #008000;">中序遍历结果按从小到大顺序输出</span>
    cout&lt;&lt;<span style="color: #000000;">endl;
    insertnode(root,</span><span style="color: #800080;">10</span><span style="color: #000000;">);
    InOrder(root);
    cout</span>&lt;&lt;<span style="color: #000000;">endl;
    deletenode(root,</span><span style="color: #800080;">10</span><span style="color: #000000;">);
    InOrder(root);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>&nbsp;</p>
<p>3.应用：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805440976633856" target="_blank">PAT A1043 Is It a Binary Search Tree</a></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('e84d0c79-68e6-4872-a41c-0d4cc9559d35')"><img id="code_img_closed_e84d0c79-68e6-4872-a41c-0d4cc9559d35" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_e84d0c79-68e6-4872-a41c-0d4cc9559d35" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('e84d0c79-68e6-4872-a41c-0d4cc9559d35',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_e84d0c79-68e6-4872-a41c-0d4cc9559d35" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200210
</span><span style="color: #008000;">//</span><span style="color: #008000;">PAT A1043 Is It a Binary Search Tree</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;vector&gt;

<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

typedef </span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> BSTNode{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> value;
    </span><span style="color: #0000ff;">struct</span> BSTNode *<span style="color: #000000;">left;
    </span><span style="color: #0000ff;">struct</span> BSTNode *<span style="color: #000000;">right;
}BSTNode; 

BSTNode</span>* newnode(<span style="color: #0000ff;">int</span><span style="color: #000000;"> v){
    BSTNode</span>* p = <span style="color: #0000ff;">new</span><span style="color: #000000;"> BSTNode;
    p</span>-&gt;value =<span style="color: #000000;"> v;
    p</span>-&gt;left =<span style="color: #000000;"> NULL;
    p</span>-&gt;right =<span style="color: #000000;"> NULL;
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> p;
}

</span><span style="color: #0000ff;">void</span> insertnode(BSTNode* &amp;root,<span style="color: #0000ff;">int</span><span style="color: #000000;"> data){
    </span><span style="color: #0000ff;">if</span>(root ==<span style="color: #000000;"> NULL){
        root </span>=<span style="color: #000000;"> newnode(data);
        </span><span style="color: #0000ff;">return</span> ; <span style="color: #008000;">//</span><span style="color: #008000;">recursion bounds</span>
<span style="color: #000000;">    }
    </span><span style="color: #0000ff;">if</span>(data &lt; root-&gt;value) insertnode(root-&gt;<span style="color: #000000;">left,data);
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(data &gt;= root-&gt;value) insertnode(root-&gt;<span style="color: #000000;">right,data);
}
vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> data,pre,mirpre,post,mirpost;
BSTNode</span>* buildBST(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n){
    BSTNode </span>*root =<span style="color: #000000;"> NULL;
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;::iterator it =<span style="color: #000000;"> data.begin();
    </span><span style="color: #0000ff;">for</span>(it;it != data.end();it++) insertnode(root,*<span style="color: #000000;">it);
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
}

</span><span style="color: #0000ff;">void</span> PreOrder(BSTNode *T,vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;v){ <span style="color: #008000;">//</span><span style="color: #008000;">也可直接全局变量</span>
    <span style="color: #0000ff;">if</span>(!T) <span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    v.push_back(T</span>-&gt;<span style="color: #000000;">value);
    PreOrder(T</span>-&gt;<span style="color: #000000;">left,v);
    PreOrder(T</span>-&gt;<span style="color: #000000;">right,v);
    
}
</span><span style="color: #0000ff;">void</span> MirrorPreOrder(BSTNode *T,vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;v){ <span style="color: #008000;">//</span><span style="color: #008000;">镜像的时候把左右子树换一下即可 </span>
    <span style="color: #0000ff;">if</span>(!T) <span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    v.push_back(T</span>-&gt;<span style="color: #000000;">value);
    MirrorPreOrder(T</span>-&gt;<span style="color: #000000;">right,v);
    MirrorPreOrder(T</span>-&gt;<span style="color: #000000;">left,v);
}

</span><span style="color: #0000ff;">void</span> PostOrder(BSTNode *T,vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">v){
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(T){
        PostOrder(T</span>-&gt;<span style="color: #000000;">left,v);
        PostOrder(T</span>-&gt;<span style="color: #000000;">right,v);
        v.push_back(T</span>-&gt;<span style="color: #000000;">value);
    }
}
</span><span style="color: #0000ff;">void</span> MirrorPostOrder(BSTNode *T,vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">v){
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(T){
        MirrorPostOrder(T</span>-&gt;<span style="color: #000000;">right,v);
        MirrorPostOrder(T</span>-&gt;<span style="color: #000000;">left,v);
        v.push_back(T</span>-&gt;<span style="color: #000000;">value);
    }
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">n);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">) {
        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> t;
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">t);
        data.push_back(t);
    }
    BSTNode </span>*root =<span style="color: #000000;"> buildBST(n);
    PreOrder(root,pre);
    MirrorPreOrder(root,mirpre);
    </span><span style="color: #0000ff;">if</span>(pre ==<span style="color: #000000;"> data){
        PostOrder(root,post);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">YES\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i;
        </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>;i&lt;post.size()-<span style="color: #800080;">1</span>;i++) printf(<span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span><span style="color: #000000;">,post[i]);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span><span style="color: #000000;">,post[i]);
    }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(mirpre ==<span style="color: #000000;"> data){
        MirrorPostOrder(root,mirpost);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">YES\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i;
        </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>;i&lt;mirpost.size()-<span style="color: #800080;">1</span>;i++) printf(<span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span><span style="color: #000000;">,mirpost[i]);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span><span style="color: #000000;">,mirpost[i]);
    }</span><span style="color: #0000ff;">else</span> printf(<span style="color: #800000;">"</span><span style="color: #800000;">NO\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>]]></description></item><item><title>最短路径问题</title><link>http://www.cnblogs.com/icodes8238/archive/2020/02/06/12268566.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Thu, 06 Feb 2020 06:20:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/02/06/12268566.html</guid><description><![CDATA[<h1 style="text-align: center;"><span style="font-family: 楷体;">最短路径问题</span></h1>
<h2><span style="font-family: 楷体;"><strong>算法1：使用dfs遍历整个图</strong></span></h2>
<p>【邻接矩阵（无向图）】直接用dfs解决（无法输出具体路径）（洛谷OJ时一个数据超时）</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('aa3f0e69-d7bf-4f1a-8b9b-12fb52f43d3d')"><img id="code_img_closed_aa3f0e69-d7bf-4f1a-8b9b-12fb52f43d3d" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_aa3f0e69-d7bf-4f1a-8b9b-12fb52f43d3d" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('aa3f0e69-d7bf-4f1a-8b9b-12fb52f43d3d',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_aa3f0e69-d7bf-4f1a-8b9b-12fb52f43d3d" class="cnblogs_code_hide">
<pre>#include&lt;stdio.h&gt;
<span style="color: #0000ff;">#define</span> inf 9999999
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span> min =<span style="color: #000000;"> inf;
</span><span style="color: #0000ff;">int</span> book[<span style="color: #800080;">101</span>],e[<span style="color: #800080;">101</span>][<span style="color: #800080;">101</span><span style="color: #000000;">],n,start,end;
</span><span style="color: #0000ff;">void</span> dfs(<span style="color: #0000ff;">int</span> cur,<span style="color: #0000ff;">int</span><span style="color: #000000;"> dis){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> j;
    </span><span style="color: #0000ff;">if</span>(dis&gt;<span style="color: #000000;">min) {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;    
    }
    </span><span style="color: #0000ff;">if</span>(cur==<span style="color: #000000;">end){
        </span><span style="color: #0000ff;">if</span>(dis&lt;<span style="color: #000000;">min){
            min </span>=<span style="color: #000000;"> dis;         
        } 
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    }
    </span><span style="color: #0000ff;">for</span>(j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(e[cur][j]!=inf &amp;&amp; book[j]==<span style="color: #800080;">0</span><span style="color: #000000;">){
            book[j]</span>=<span style="color: #800080;">1</span><span style="color: #000000;">;
            dfs(j,dis</span>+<span style="color: #000000;">e[cur][j]);
            book[j]</span>=<span style="color: #800080;">0</span>;<span style="color: #008000;">//</span><span style="color: #008000;">一条路径全部走完才book[j]=0; </span>
<span style="color: #000000;">        }
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,m,a,b,c;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d %d</span><span style="color: #800000;">"</span>,&amp;n,&amp;m,&amp;start,&amp;<span style="color: #000000;">end);
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(i==j) e[i][j]=<span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> e[i][j]=<span style="color: #000000;">inf;
        }
    }
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">1</span>;i&lt;=m;i++<span style="color: #000000;">){
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d</span><span style="color: #800000;">"</span>,&amp;a,&amp;b,&amp;<span style="color: #000000;">c);
        e[a][b]</span>=<span style="color: #000000;">c;
        e[b][a]</span>=<span style="color: #000000;">c;
    }
    book[</span><span style="color: #800080;">1</span>]=<span style="color: #800080;">1</span><span style="color: #000000;">;
    dfs(start,</span><span style="color: #800080;">0</span><span style="color: #000000;">);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,min);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;"><strong>算法2：Dijkstra算法</strong></span></h2>
<p>（《算法笔记》相关内容在P370）</p>
<p><strong>1.【邻接矩阵（无向图）】详细输出每一步的过程（距离数组的值）</strong> 20191206</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('14cfd859-d42e-45a1-b091-69602905de52')"><img id="code_img_closed_14cfd859-d42e-45a1-b091-69602905de52" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_14cfd859-d42e-45a1-b091-69602905de52" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('14cfd859-d42e-45a1-b091-69602905de52',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_14cfd859-d42e-45a1-b091-69602905de52" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">show the whole procedure as the notes demostrate.</span>
#include&lt;iostream&gt;
<span style="color: #0000ff;">#define</span> inf 9999999
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span> book[<span style="color: #800080;">101</span>],e[<span style="color: #800080;">101</span>][<span style="color: #800080;">101</span>],n,start,term,data[<span style="color: #800080;">101</span><span style="color: #000000;">];
</span><span style="color: #008000;">//</span><span style="color: #008000;">start means start from start
</span><span style="color: #008000;">//</span><span style="color: #008000;">term means the termination, use d[term] to get. In fact, we can get all the path from data[]
</span><span style="color: #008000;">//</span><span style="color: #008000;">data[] stores the shortest distance of every vertex</span>
<span style="color: #0000ff;">int</span> countk; <span style="color: #008000;">//</span><span style="color: #008000;">record the number of vertices booked</span>
<span style="color: #0000ff;">int</span><span style="color: #000000;"> seekmin(){
    </span><span style="color: #0000ff;">int</span> minn=<span style="color: #000000;">inf;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> index;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(book[i]==<span style="color: #800080;">0</span> &amp;&amp; data[i]&lt;minn){ <span style="color: #008000;">//</span><span style="color: #008000;">make sure not compare with the vertex booked</span>
            minn =<span style="color: #000000;"> data[i];
            index </span>=<span style="color: #000000;"> i;
        }
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> index;
}
</span><span style="color: #0000ff;">void</span> Dijkstra(<span style="color: #0000ff;">int</span> cur,<span style="color: #0000ff;">int</span><span style="color: #000000;"> dis){
    book[cur] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    countk</span>++<span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">)
        </span><span style="color: #0000ff;">if</span>(book[i]==<span style="color: #800080;">0</span> &amp;&amp; dis+e[cur][i]&lt;data[i]) <span style="color: #008000;">//</span><span style="color: #008000;">inf + dis&lt; inf</span>
            data[i] = dis +<span style="color: #000000;"> e[cur][i];
}
</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> show(){
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        cout</span>&lt;&lt;data[i]&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
    }
    cout</span>&lt;&lt;<span style="color: #000000;">endl;
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,m,a,b,c;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d %d</span><span style="color: #800000;">"</span>,&amp;n,&amp;m,&amp;start,&amp;<span style="color: #000000;">term);
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(i==j) e[i][j]=<span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> e[i][j]=<span style="color: #000000;">inf;
        }
    }
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">1</span>;i&lt;=m;i++<span style="color: #000000;">){
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d</span><span style="color: #800000;">"</span>,&amp;a,&amp;b,&amp;<span style="color: #000000;">c);
        e[a][b]</span>=<span style="color: #000000;">c;
        e[b][a]</span>=<span style="color: #000000;">c;
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">initialize</span>
    <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(i==start) data[i] = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span> data[i] =<span style="color: #000000;"> inf;
    }
    Dijkstra(start,</span><span style="color: #800080;">0</span><span style="color: #000000;">);
    show();
    </span><span style="color: #0000ff;">int</span> next =<span style="color: #000000;"> seekmin();
    </span><span style="color: #0000ff;">while</span>(countk!=<span style="color: #000000;">n){
        Dijkstra(next,data[next]);
        show();
        next </span>=<span style="color: #000000;"> seekmin();
        
    }
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,data[term]);    
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}
</span><span style="color: #008000;">/*</span><span style="color: #008000;">------Test-------
//左侧 
7 12 1 4
1 2 12
2 3 10
3 4 3
4 5 4
3 5 5
5 6 2
3 6 6
2 6 7
1 6 16
6 7 9
5 7 8
1 7 14
//右侧 
6 9 1 6
1 2 4
1 3 2
2 3 3
2 4 5
3 4 8
3 5 10
4 5 2
5 6 3
4 6 6
</span><span style="color: #008000;">*/</span> </pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>测试数据图示：（图片来自课件）</p>
<p><img src="https://img2018.cnblogs.com/common/1726496/202002/1726496-20200206114544060-1528651755.png" alt="" width="222" height="135" />&nbsp; &nbsp;&nbsp;<img src="https://img2018.cnblogs.com/common/1726496/202002/1726496-20200206114556046-118128754.jpg" alt="" width="206" height="143" /></p>
<p>&nbsp;</p>
<p><strong>2. 【邻接表（无向图）】AC洛谷 <a href="https://www.luogu.com.cn/problem/P1339" target="_blank">P1339</a>&nbsp;</strong> &nbsp;（20200206）</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('7541dbed-1f80-4ff3-9f55-6272224dd875')"><img id="code_img_closed_7541dbed-1f80-4ff3-9f55-6272224dd875" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_7541dbed-1f80-4ff3-9f55-6272224dd875" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('7541dbed-1f80-4ff3-9f55-6272224dd875',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_7541dbed-1f80-4ff3-9f55-6272224dd875" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200206
</span><span style="color: #008000;">//</span><span style="color: #008000;">Dijkstra adjacent list(vector)</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;vector&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt; <span style="color: #008000;">//</span><span style="color: #008000;">fill </span>
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> inf = <span style="color: #800080;">0x3fffffff</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> MAXN = <span style="color: #800080;">2510</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> book[MAXN]; 
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,start,term;
</span><span style="color: #0000ff;">int</span> data[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">stores the shortest distance of every vertex</span>
<span style="color: #0000ff;">struct</span><span style="color: #000000;"> Edge{
    </span><span style="color: #0000ff;">int</span> v; <span style="color: #008000;">//</span><span style="color: #008000;">v为该边的另外一个顶点</span>
    <span style="color: #0000ff;">int</span> weight; <span style="color: #008000;">//</span><span style="color: #008000;">该边的边权 </span>
<span style="color: #000000;">};
vector</span>&lt;Edge&gt; adj[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">adj[i]存放从顶点i出发所有能到达的点 ；相当于二维数组 </span>
<span style="color: #0000ff;">int</span><span style="color: #000000;"> countk;
</span><span style="color: #0000ff;">int</span> seekmin(){ <span style="color: #008000;">//</span><span style="color: #008000;">seek the min in data[];</span>
    <span style="color: #0000ff;">int</span> minn =<span style="color: #000000;"> inf;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> index;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(book[i]==<span style="color: #800080;">0</span> &amp;&amp; data[i]&lt;<span style="color: #000000;">minn){ 
        </span><span style="color: #008000;">//</span><span style="color: #008000;">make sure not compare with the vertex booked</span>
            minn =<span style="color: #000000;"> data[i];
            index </span>=<span style="color: #000000;"> i;
        }
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> index;
}
</span><span style="color: #0000ff;">void</span> Dijkstra(<span style="color: #0000ff;">int</span> cur,<span style="color: #0000ff;">int</span><span style="color: #000000;"> dis){
    book[cur] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    countk</span>++<span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;adj[cur].size();i++<span style="color: #000000;">){
        Edge e </span>=<span style="color: #000000;"> adj[cur][i];
        </span><span style="color: #0000ff;">if</span>(book[e.v]==<span style="color: #800080;">0</span> &amp;&amp; e.weight+dis&lt;data[e.v]) data[e.v] = e.weight +<span style="color: #000000;"> dis;
        </span><span style="color: #008000;">//</span><span style="color: #008000;">make sure not compare with the vertex booked</span>
<span style="color: #000000;">    }
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,m,a,b,c;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d %d</span><span style="color: #800000;">"</span>,&amp;n,&amp;m,&amp;start,&amp;<span style="color: #000000;">term);
    fill(data,data </span>+<span style="color: #000000;"> MAXN,inf);
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>;i&lt;m;i++<span style="color: #000000;">){
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d</span><span style="color: #800000;">"</span>,&amp;a,&amp;b,&amp;<span style="color: #000000;">c);
        Edge e1;
        e1.v </span>=<span style="color: #000000;"> b;
        e1.weight </span>=<span style="color: #000000;"> c;
        adj[a].push_back(e1); 
        Edge e2;
        e2.v </span>=<span style="color: #000000;"> a;
        e2.weight </span>=<span style="color: #000000;"> c;
        adj[b].push_back(e2); 
    }
    Dijkstra(start,</span><span style="color: #800080;">0</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">while</span>(countk&lt;<span style="color: #000000;">n){
        </span><span style="color: #0000ff;">int</span> next =<span style="color: #000000;"> seekmin();
        </span><span style="color: #0000ff;">int</span> distance =<span style="color: #000000;"> data[next];
        Dijkstra(next,distance);
    }
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,data[term]);    
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p><strong>3.【邻接表（无向图）】能记录最短路径的路线图</strong> （20200206）</p>
<p>说明：只需在更新data[i]时记录&nbsp;i&nbsp;的前驱结点即可，即上一步选出的最小结点cur；</p>
<p>要获得最短路径，从尾部递归其前驱结点直到start为止。</p>
<p>新增代码：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">void</span> Dijkstra(<span style="color: #0000ff;">int</span> cur,<span style="color: #0000ff;">int</span><span style="color: #000000;"> dis){
    book[cur] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    countk</span>++<span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;adj[cur].size();i++<span style="color: #000000;">){
        Edge e </span>=<span style="color: #000000;"> adj[cur][i];
        </span><span style="color: #0000ff;">if</span>(book[e.v]==<span style="color: #800080;">0</span> &amp;&amp; e.weight+dis&lt;data[e.v]){<span style="color: #008000;">//</span><span style="color: #008000;">make sure not compare with the vertex booked</span>
            data[e.v] = e.weight +<span style="color: #000000;"> dis;
            <span style="background-color: #ffff00;">pre[e.v] </span></span><span style="background-color: #ffff00;">=</span><span style="color: #000000;"><span style="background-color: #ffff00;"> cur;</span>
        }     
    }
}
</span><span style="color: #0000ff;">void</span> dfs(<span style="color: #0000ff;">int</span> v){ <span style="color: #008000;">//</span><span style="color: #008000;">不能用while代替，因为顺序不对 </span>
    <span style="color: #0000ff;">if</span>(v ==<span style="color: #000000;"> start){
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d-&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">,v);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    }
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
        dfs(pre[v]);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d-&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">,v);
    }
}</span></pre>
</div>
<p>完整代码：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('1640187d-35d6-47ed-9adb-5cda9e0c46b7')"><img id="code_img_closed_1640187d-35d6-47ed-9adb-5cda9e0c46b7" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_1640187d-35d6-47ed-9adb-5cda9e0c46b7" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('1640187d-35d6-47ed-9adb-5cda9e0c46b7',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_1640187d-35d6-47ed-9adb-5cda9e0c46b7" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200206
</span><span style="color: #008000;">//</span><span style="color: #008000;">Dijkstra adjacent list(vector) + record the path</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;vector&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt; <span style="color: #008000;">//</span><span style="color: #008000;">fill </span>
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> inf = <span style="color: #800080;">0x3fffffff</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> MAXN = <span style="color: #800080;">2510</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> book[MAXN]; 
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,start,term;
</span><span style="color: #0000ff;">int</span> data[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">stores the shortest distance of every vertex</span>
<span style="color: #0000ff;">int</span> pre[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">记录前驱结点 </span>
<span style="color: #0000ff;">struct</span><span style="color: #000000;"> Edge{
    </span><span style="color: #0000ff;">int</span> v; <span style="color: #008000;">//</span><span style="color: #008000;">v为该边的另外一个顶点</span>
    <span style="color: #0000ff;">int</span> weight; <span style="color: #008000;">//</span><span style="color: #008000;">该边的边权 </span>
<span style="color: #000000;">};
vector</span>&lt;Edge&gt; adj[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">adj[i]存放从顶点i出发所有能到达的点 ；相当于二维数组 </span>
<span style="color: #0000ff;">int</span><span style="color: #000000;"> countk;
</span><span style="color: #0000ff;">int</span> seekmin(){ <span style="color: #008000;">//</span><span style="color: #008000;">seek the min in data[];</span>
    <span style="color: #0000ff;">int</span> minn =<span style="color: #000000;"> inf;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> index;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(book[i]==<span style="color: #800080;">0</span> &amp;&amp; data[i]&lt;<span style="color: #000000;">minn){ 
        </span><span style="color: #008000;">//</span><span style="color: #008000;">make sure not compare with the vertex booked</span>
            minn =<span style="color: #000000;"> data[i];
            index </span>=<span style="color: #000000;"> i;
        }
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> index;
}
</span><span style="color: #0000ff;">void</span> Dijkstra(<span style="color: #0000ff;">int</span> cur,<span style="color: #0000ff;">int</span><span style="color: #000000;"> dis){
    book[cur] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    countk</span>++<span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;adj[cur].size();i++<span style="color: #000000;">){
        Edge e </span>=<span style="color: #000000;"> adj[cur][i];
        </span><span style="color: #0000ff;">if</span>(book[e.v]==<span style="color: #800080;">0</span> &amp;&amp; e.weight+dis&lt;data[e.v]){<span style="color: #008000;">//</span><span style="color: #008000;">make sure not compare with the vertex booked</span>
            data[e.v] = e.weight +<span style="color: #000000;"> dis;
            pre[e.v] </span>=<span style="color: #000000;"> cur;
        }     
    }
}
</span><span style="color: #0000ff;">void</span> dfs(<span style="color: #0000ff;">int</span> v){ <span style="color: #008000;">//</span><span style="color: #008000;">不能用while代替，因为顺序不对 </span>
    <span style="color: #0000ff;">if</span>(v ==<span style="color: #000000;"> start){
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d-&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">,v);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    }
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
        dfs(pre[v]);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d-&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">,v);
    }
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,m,a,b,c;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d %d</span><span style="color: #800000;">"</span>,&amp;n,&amp;m,&amp;start,&amp;<span style="color: #000000;">term);
    fill(data,data </span>+<span style="color: #000000;"> MAXN,inf);
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>;i&lt;m;i++<span style="color: #000000;">){
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d</span><span style="color: #800000;">"</span>,&amp;a,&amp;b,&amp;<span style="color: #000000;">c);
        Edge e1;
        e1.v </span>=<span style="color: #000000;"> b;
        e1.weight </span>=<span style="color: #000000;"> c;
        adj[a].push_back(e1); 
        Edge e2;
        e2.v </span>=<span style="color: #000000;"> a;
        e2.weight </span>=<span style="color: #000000;"> c;
        adj[b].push_back(e2); 
    }
    Dijkstra(start,</span><span style="color: #800080;">0</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">while</span>(countk&lt;<span style="color: #000000;">n){
        </span><span style="color: #0000ff;">int</span> next =<span style="color: #000000;"> seekmin();
        </span><span style="color: #0000ff;">int</span> distance =<span style="color: #000000;"> data[next];
        Dijkstra(next,distance);
    }
    dfs(pre[term]);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,term);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,data[term]);    
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}
</span><span style="color: #008000;">/*</span><span style="color: #008000;">---Test---- 
7 11 5 4
2 4 2
1 4 3
7 2 2
3 4 3
5 7 5
7 3 3
6 1 1
6 3 4
2 4 3
5 6 3
7 2 1
</span><span style="color: #008000;">*/</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>测试数据图示：（下左）</p>
<p><img src="https://img2018.cnblogs.com/common/1726496/202002/1726496-20200206130655705-1786282979.jpg" alt="" width="169" height="179" />&nbsp; &nbsp; &nbsp;<img src="https://img2018.cnblogs.com/common/1726496/202002/1726496-20200206134000642-843485748.jpg" alt="" width="184" height="181" /></p>
<p>&nbsp;</p>
<p><strong>4.【邻接表（无向图）】能输出最短路径条数</strong>（参考《算法笔记》P377）</p>
<p>新增代码：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">void</span> Dijkstra(<span style="color: #0000ff;">int</span> cur,<span style="color: #0000ff;">int</span><span style="color: #000000;"> dis){
    book[cur] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    countk</span>++<span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;adj[cur].size();i++<span style="color: #000000;">){
        Edge e </span>=<span style="color: #000000;"> adj[cur][i];
        </span><span style="color: #0000ff;">if</span>(book[e.v]==<span style="color: #800080;">0</span> &amp;&amp; e.weight+dis&lt;<span style="color: #000000;">data[e.v]){
            data[e.v] </span>= e.weight +<span style="color: #000000;"> dis;
            <span style="background-color: #ffff00;">num[e.v] </span></span><span style="background-color: #ffff00;">= num[cur];</span> <span style="color: #008000;">//</span><span style="color: #008000;">如果小于，就继承 </span>
<span style="color: #000000;">        }
        </span><span style="background-color: #ffff00;"><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(book[e.v]==<span style="color: #800080;">0</span> &amp;&amp; e.weight+dis==data[e.v]) num[e.v] +=<span style="color: #000000;"> num[cur];
</span></span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果等于，就加上 </span>
<span style="color: #000000;">    }
}</span></pre>
</div>
<p>完整代码：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('8c287723-e2c9-4211-ba5b-d965d4ee0317')"><img id="code_img_closed_8c287723-e2c9-4211-ba5b-d965d4ee0317" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_8c287723-e2c9-4211-ba5b-d965d4ee0317" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('8c287723-e2c9-4211-ba5b-d965d4ee0317',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_8c287723-e2c9-4211-ba5b-d965d4ee0317" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200206
</span><span style="color: #008000;">//</span><span style="color: #008000;">Dijkstra adjacent list(vector)</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;vector&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt; <span style="color: #008000;">//</span><span style="color: #008000;">fill </span>
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> inf = <span style="color: #800080;">0x3fffffff</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> MAXN = <span style="color: #800080;">2510</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> book[MAXN]; 
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,start,term;
</span><span style="color: #0000ff;">int</span> data[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">stores the shortest distance of every vertex</span>
<span style="color: #0000ff;">int</span> num[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">record the num of shortest path </span>
<span style="color: #0000ff;">struct</span><span style="color: #000000;"> Edge{
    </span><span style="color: #0000ff;">int</span> v; <span style="color: #008000;">//</span><span style="color: #008000;">v为该边的另外一个顶点</span>
    <span style="color: #0000ff;">int</span> weight; <span style="color: #008000;">//</span><span style="color: #008000;">该边的边权 </span>
<span style="color: #000000;">};
vector</span>&lt;Edge&gt; adj[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">adj[i]存放从顶点i出发所有能到达的点 ；相当于二维数组 </span>
<span style="color: #0000ff;">int</span><span style="color: #000000;"> countk;
</span><span style="color: #0000ff;">int</span> seekmin(){ <span style="color: #008000;">//</span><span style="color: #008000;">seek the min in data[];</span>
    <span style="color: #0000ff;">int</span> minn =<span style="color: #000000;"> inf;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> index;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(book[i]==<span style="color: #800080;">0</span> &amp;&amp; data[i]&lt;<span style="color: #000000;">minn){ 
        </span><span style="color: #008000;">//</span><span style="color: #008000;">make sure not compare with the vertex booked</span>
            minn =<span style="color: #000000;"> data[i];
            index </span>=<span style="color: #000000;"> i;
        }
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> index;
}
</span><span style="color: #0000ff;">void</span> Dijkstra(<span style="color: #0000ff;">int</span> cur,<span style="color: #0000ff;">int</span><span style="color: #000000;"> dis){
    book[cur] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    countk</span>++<span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;adj[cur].size();i++<span style="color: #000000;">){
        Edge e </span>=<span style="color: #000000;"> adj[cur][i];
        </span><span style="color: #0000ff;">if</span>(book[e.v]==<span style="color: #800080;">0</span> &amp;&amp; e.weight+dis&lt;<span style="color: #000000;">data[e.v]){
            data[e.v] </span>= e.weight +<span style="color: #000000;"> dis;
            num[e.v] </span>= num[cur]; <span style="color: #008000;">//</span><span style="color: #008000;">如果小于，就继承 </span>
<span style="color: #000000;">        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(book[e.v]==<span style="color: #800080;">0</span> &amp;&amp; e.weight+dis==data[e.v]) num[e.v] +=<span style="color: #000000;"> num[cur];
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果等于，就加上 </span>
<span style="color: #000000;">    }
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,m,a,b,c;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d %d</span><span style="color: #800000;">"</span>,&amp;n,&amp;m,&amp;start,&amp;<span style="color: #000000;">term);
    fill(data,data </span>+<span style="color: #000000;"> MAXN,inf);
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>;i&lt;m;i++<span style="color: #000000;">){
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d</span><span style="color: #800000;">"</span>,&amp;a,&amp;b,&amp;<span style="color: #000000;">c);
        Edge e1;
        e1.v </span>=<span style="color: #000000;"> b;
        e1.weight </span>=<span style="color: #000000;"> c;
        adj[a].push_back(e1); 
        Edge e2;
        e2.v </span>=<span style="color: #000000;"> a;
        e2.weight </span>=<span style="color: #000000;"> c;
        adj[b].push_back(e2); 
    }
    num[start] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    Dijkstra(start,</span><span style="color: #800080;">0</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">while</span>(countk&lt;<span style="color: #000000;">n){
        </span><span style="color: #0000ff;">int</span> next =<span style="color: #000000;"> seekmin();
        </span><span style="color: #0000ff;">int</span> distance =<span style="color: #000000;"> data[next];
        Dijkstra(next,distance);
    }
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">shortest distance = %d\nnum = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,data[term],num[term]);    
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}
</span><span style="color: #008000;">/*</span><span style="color: #008000;">---Test----
8 11 1 8
1 2 3
1 3 3
1 4 3
4 5 1
4 6 1
4 7 1
5 8 2
6 8 2
7 8 2
3 8 3
2 8 3
</span><span style="color: #008000;">*/</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>测试数据图示：（上右）</p>
<p>&nbsp;</p>
<p><strong><strong>5.【邻接表（无向图）】能记录所有最短路径的路线图</strong></strong>（参考《算法笔记》P382）</p>
<p>新增代码：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">void</span> Dijkstra(<span style="color: #0000ff;">int</span> cur,<span style="color: #0000ff;">int</span><span style="color: #000000;"> dis){
    book[cur] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    countk</span>++<span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;adj[cur].size();i++<span style="color: #000000;">){
        Edge e </span>=<span style="color: #000000;"> adj[cur][i];
        </span><span style="color: #0000ff;">if</span>(book[e.v]==<span style="color: #800080;">0</span> &amp;&amp; e.weight+dis&lt;<span style="color: #000000;">data[e.v]){
            data[e.v] </span>= e.weight +<span style="color: #000000;"> dis;
            num[e.v] </span>= num[cur]; <span style="color: #008000;">//</span><span style="color: #008000;">如果小于，就继承 </span>
<span style="color: #000000;">           <span style="background-color: #ffff00;"> pre[e.v].clear();</span>
            <span style="background-color: #ffff00;">pre[e.v].push_back(cur);</span>
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(book[e.v]==<span style="color: #800080;">0</span> &amp;&amp; e.weight+dis==data[e.v]){<span style="color: #008000;">//</span><span style="color: #008000;"> 如果等于，就加上 </span>
            num[e.v] +=<span style="color: #000000;"> num[cur];
            <span style="background-color: #ffff00;">pre[e.v].push_back(cur);</span>
        }
        
    }
}
stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
</span><span style="color: #0000ff;">void</span> dfs(<span style="color: #0000ff;">int</span><span style="color: #000000;"> v){
    </span><span style="color: #0000ff;">if</span>(v ==<span style="color: #000000;"> start){
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d-&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">,v);
        </span><span style="color: #0000ff;">while</span>(s.size() &gt; <span style="color: #800080;">1</span><span style="color: #000000;">){
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d-&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">,s.top());
            s.pop();
        }
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,s.top());
        s.pop();
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;    
    }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;pre[v].size();i++<span style="color: #000000;">){
            s.push(v);
            dfs(pre[v][i]);
        }
    }
}</span></pre>
</div>
<p>完整代码：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('adfc53a3-8008-46fe-ac13-389ebb549711')"><img id="code_img_closed_adfc53a3-8008-46fe-ac13-389ebb549711" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_adfc53a3-8008-46fe-ac13-389ebb549711" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('adfc53a3-8008-46fe-ac13-389ebb549711',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_adfc53a3-8008-46fe-ac13-389ebb549711" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200206
</span><span style="color: #008000;">//</span><span style="color: #008000;">Dijkstra adjacent list(vector)</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;vector&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt; <span style="color: #008000;">//</span><span style="color: #008000;">fill </span>
#include&lt;stack&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> inf = <span style="color: #800080;">0x3fffffff</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> MAXN = <span style="color: #800080;">2510</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> book[MAXN]; 
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,start,term;
</span><span style="color: #0000ff;">int</span> data[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">stores the shortest distance of every vertex</span>
<span style="color: #0000ff;">int</span> num[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">record the num of shortest path </span>
<span style="color: #0000ff;">struct</span><span style="color: #000000;"> Edge{
    </span><span style="color: #0000ff;">int</span> v; <span style="color: #008000;">//</span><span style="color: #008000;">v为该边的另外一个顶点</span>
    <span style="color: #0000ff;">int</span> weight; <span style="color: #008000;">//</span><span style="color: #008000;">该边的边权 </span>
<span style="color: #000000;">};
vector</span>&lt;Edge&gt; adj[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">adj[i]存放从顶点i出发所有能到达的点 ；相当于二维数组 </span>
vector&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> pre[MAXN]; 
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> countk;
</span><span style="color: #0000ff;">int</span> seekmin(){ <span style="color: #008000;">//</span><span style="color: #008000;">seek the min in data[];</span>
    <span style="color: #0000ff;">int</span> minn =<span style="color: #000000;"> inf;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> index;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(book[i]==<span style="color: #800080;">0</span> &amp;&amp; data[i]&lt;<span style="color: #000000;">minn){ 
        </span><span style="color: #008000;">//</span><span style="color: #008000;">make sure not compare with the vertex booked</span>
            minn =<span style="color: #000000;"> data[i];
            index </span>=<span style="color: #000000;"> i;
        }
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> index;
}
</span><span style="color: #0000ff;">void</span> Dijkstra(<span style="color: #0000ff;">int</span> cur,<span style="color: #0000ff;">int</span><span style="color: #000000;"> dis){
    book[cur] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    countk</span>++<span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;adj[cur].size();i++<span style="color: #000000;">){
        Edge e </span>=<span style="color: #000000;"> adj[cur][i];
        </span><span style="color: #0000ff;">if</span>(book[e.v]==<span style="color: #800080;">0</span> &amp;&amp; e.weight+dis&lt;<span style="color: #000000;">data[e.v]){
            data[e.v] </span>= e.weight +<span style="color: #000000;"> dis;
            num[e.v] </span>= num[cur]; <span style="color: #008000;">//</span><span style="color: #008000;">如果小于，就继承 </span>
<span style="color: #000000;">            pre[e.v].clear();
            pre[e.v].push_back(cur);
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(book[e.v]==<span style="color: #800080;">0</span> &amp;&amp; e.weight+dis==data[e.v]){<span style="color: #008000;">//</span><span style="color: #008000;"> 如果等于，就加上 </span>
            num[e.v] +=<span style="color: #000000;"> num[cur];
            pre[e.v].push_back(cur);
        }
        
    }
}
stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
</span><span style="color: #0000ff;">void</span> dfs(<span style="color: #0000ff;">int</span><span style="color: #000000;"> v){
    
    </span><span style="color: #0000ff;">if</span>(v ==<span style="color: #000000;"> start){
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d-&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">,v);
        </span><span style="color: #0000ff;">while</span>(s.size() &gt; <span style="color: #800080;">1</span><span style="color: #000000;">){
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d-&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">,s.top());
            s.pop();
        }
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,s.top());
        s.pop();
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;    
    }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;pre[v].size();i++<span style="color: #000000;">){
            s.push(v);
            dfs(pre[v][i]);
        }
    }
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,m,a,b,c;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d %d</span><span style="color: #800000;">"</span>,&amp;n,&amp;m,&amp;start,&amp;<span style="color: #000000;">term);
    fill(data,data </span>+<span style="color: #000000;"> MAXN,inf);
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>;i&lt;m;i++<span style="color: #000000;">){
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d</span><span style="color: #800000;">"</span>,&amp;a,&amp;b,&amp;<span style="color: #000000;">c);
        Edge e1;
        e1.v </span>=<span style="color: #000000;"> b;
        e1.weight </span>=<span style="color: #000000;"> c;
        adj[a].push_back(e1); 
        Edge e2;
        e2.v </span>=<span style="color: #000000;"> a;
        e2.weight </span>=<span style="color: #000000;"> c;
        adj[b].push_back(e2); 
    }
    num[start] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    Dijkstra(start,</span><span style="color: #800080;">0</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">while</span>(countk&lt;<span style="color: #000000;">n){
        </span><span style="color: #0000ff;">int</span> next =<span style="color: #000000;"> seekmin();
        </span><span style="color: #0000ff;">int</span> distance =<span style="color: #000000;"> data[next];
        Dijkstra(next,distance);
    }
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">shortest distance = %d\nnum = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,data[term],num[term]);
    dfs(term);    
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}
</span><span style="color: #008000;">/*</span><span style="color: #008000;">---Test----
8 11 1 8
1 2 3
1 3 3
1 4 3
4 5 1
4 6 1
4 7 1
5 8 2
6 8 2
7 8 2
3 8 3
2 8 3
</span><span style="color: #008000;">*/</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>测试数据图示同上</p>
<p>&nbsp;</p>
<p><strong><strong>6.<strong><strong>【邻接表（无向图）】新增点权/边权（第二标尺）</strong></strong></strong></strong>（参考《算法笔记》P377） AC <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376" target="_blank">PAT A1003&nbsp;Emergency</a>（记录最短路径条数和点权最大）</p>
<p>新增代码：（边权同理，详见《算法笔记》P377）</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">void</span> Dijkstra(<span style="color: #0000ff;">int</span> cur,<span style="color: #0000ff;">int</span><span style="color: #000000;"> dis){
    book[cur] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    countk</span>++<span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;adj[cur].size();i++<span style="color: #000000;">){
        Edge e </span>=<span style="color: #000000;"> adj[cur][i];
        </span><span style="color: #0000ff;">if</span>(book[e.v]==<span style="color: #800080;">0</span> &amp;&amp; e.weight+dis&lt;<span style="color: #000000;">data[e.v]){
            data[e.v] </span>= e.weight +<span style="color: #000000;"> dis;
            num[e.v] </span>=<span style="color: #000000;"> num[cur];
            <span style="background-color: #ffff00;">w[e.v] </span></span><span style="background-color: #ffff00;">= w[cur] +</span><span style="color: #000000;"><span style="background-color: #ffff00;"> weig[e.v];</span> 
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(book[e.v]==<span style="color: #800080;">0</span> &amp;&amp; e.weight+dis==<span style="color: #000000;">data[e.v]){
            num[e.v] </span>+=<span style="color: #000000;"> num[cur]; //必须放在外面，因为路径数和点权无关
            </span><span style="background-color: #ffff00;"><span style="color: #0000ff;">if</span>(w[cur] + weig[e.v] &gt;</span><span style="color: #000000;"><span style="background-color: #ffff00;"> w[e.v])</span>
                <span style="background-color: #ffff00;">w[e.v] </span></span><span style="background-color: #ffff00;">= w[cur] +</span><span style="color: #000000;"><span style="background-color: #ffff00;"> weig[e.v];</span> 
        } 
    }
}</span></pre>
</div>
<p>完整代码：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('9afe1f24-6046-46e2-a47f-05e0b106142a')"><img id="code_img_closed_9afe1f24-6046-46e2-a47f-05e0b106142a" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_9afe1f24-6046-46e2-a47f-05e0b106142a" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('9afe1f24-6046-46e2-a47f-05e0b106142a',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_9afe1f24-6046-46e2-a47f-05e0b106142a" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200206
</span><span style="color: #008000;">//</span><span style="color: #008000;"> PAT A1003 Emergency</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;vector&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt; <span style="color: #008000;">//</span><span style="color: #008000;">fill </span>
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> inf = <span style="color: #800080;">0x3fffffff</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> MAXN = <span style="color: #800080;">510</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> book[MAXN]; 
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,start,term;
</span><span style="color: #0000ff;">int</span> data[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">stores the shortest distance of every vertex</span>
<span style="color: #0000ff;">int</span> num[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">record the num of shortest path </span>
<span style="color: #0000ff;">int</span> weig[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;"> the given point-weight </span>
<span style="color: #0000ff;">int</span> w[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">record the point-weight of shortest path </span>
<span style="color: #0000ff;">struct</span><span style="color: #000000;"> Edge{
    </span><span style="color: #0000ff;">int</span> v; <span style="color: #008000;">//</span><span style="color: #008000;">v为该边的另外一个顶点</span>
    <span style="color: #0000ff;">int</span> weight; <span style="color: #008000;">//</span><span style="color: #008000;">该边的边权 </span>
<span style="color: #000000;">};
vector</span>&lt;Edge&gt; adj[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">adj[i]存放从顶点i出发所有能到达的点 ；相当于二维数组 </span>
<span style="color: #0000ff;">int</span><span style="color: #000000;"> countk;
</span><span style="color: #0000ff;">int</span> seekmin(){ <span style="color: #008000;">//</span><span style="color: #008000;">seek the min in data[];</span>
    <span style="color: #0000ff;">int</span> minn =<span style="color: #000000;"> inf;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> index;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++){ <span style="color: #008000;">//</span><span style="color: #008000;">notice that the min vertex is 0 in this problem</span>
        <span style="color: #0000ff;">if</span>(book[i]==<span style="color: #800080;">0</span> &amp;&amp; data[i]&lt;<span style="color: #000000;">minn){ 
        </span><span style="color: #008000;">//</span><span style="color: #008000;">make sure not compare with the vertex booked</span>
            minn =<span style="color: #000000;"> data[i];
            index </span>=<span style="color: #000000;"> i;
        }
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> index;
}
</span><span style="color: #0000ff;">void</span> Dijkstra(<span style="color: #0000ff;">int</span> cur,<span style="color: #0000ff;">int</span><span style="color: #000000;"> dis){
    book[cur] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    countk</span>++<span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;adj[cur].size();i++<span style="color: #000000;">){
        Edge e </span>=<span style="color: #000000;"> adj[cur][i];
        </span><span style="color: #0000ff;">if</span>(book[e.v]==<span style="color: #800080;">0</span> &amp;&amp; e.weight+dis&lt;<span style="color: #000000;">data[e.v]){
            data[e.v] </span>= e.weight +<span style="color: #000000;"> dis;
            num[e.v] </span>=<span style="color: #000000;"> num[cur];
            w[e.v] </span>= w[cur] +<span style="color: #000000;"> weig[e.v]; 
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(book[e.v]==<span style="color: #800080;">0</span> &amp;&amp; e.weight+dis==<span style="color: #000000;">data[e.v]){
            num[e.v] </span>+=<span style="color: #000000;"> num[cur];
            </span><span style="color: #0000ff;">if</span>(w[cur] + weig[e.v] &gt;<span style="color: #000000;"> w[e.v])
                w[e.v] </span>= w[cur] +<span style="color: #000000;"> weig[e.v]; 
        } 
    }
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,m,a,b,c;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d %d</span><span style="color: #800000;">"</span>,&amp;n,&amp;m,&amp;start,&amp;<span style="color: #000000;">term);
    fill(data,data </span>+<span style="color: #000000;"> MAXN,inf);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++) <span style="color: #008000;">//</span><span style="color: #008000;">notice that the min vertex is 0 in this problem</span>
        scanf(<span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">weig[i]);
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>;i&lt;m;i++<span style="color: #000000;">){
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d</span><span style="color: #800000;">"</span>,&amp;a,&amp;b,&amp;<span style="color: #000000;">c);
        Edge e1;
        e1.v </span>=<span style="color: #000000;"> b;
        e1.weight </span>=<span style="color: #000000;"> c;
        adj[a].push_back(e1); 
        Edge e2;
        e2.v </span>=<span style="color: #000000;"> a;
        e2.weight </span>=<span style="color: #000000;"> c;
        adj[b].push_back(e2); 
    }
    w[start] </span>=<span style="color: #000000;"> weig[start];
    num[start] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    Dijkstra(start,</span><span style="color: #800080;">0</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">while</span>(countk&lt;<span style="color: #000000;">n){
        </span><span style="color: #0000ff;">int</span> next =<span style="color: #000000;"> seekmin();
        </span><span style="color: #0000ff;">int</span> distance =<span style="color: #000000;"> data[next];
        Dijkstra(next,distance);
    }
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,num[term],w[term]);    
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p><strong><span style="background-color: #ffff00;">7.【模板 Dijkstra+DFS】</span><strong><strong><strong><span style="background-color: #ffff00;">邻接表（无向图）新增第二标尺</span>&nbsp;</strong></strong></strong></strong>（参考《算法笔记》P381）AC <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805464397627392" target="_blank">PAT A1030&nbsp;Travel Plan</a></p>
<p>基本思想：（类似于5中输出所有最短路径，可优化）</p>
<p>先在Dijkstra算法中记录下所有最短路径（只考虑距离）；</p>
<p>然后从这些最短路径中选出一条第二标尺最优的路径（在给定的一条路径情况下，这条路径的边权、点权信息很容易求出来）</p>
<p>实现方式1：（完全仿照5中的思想完成）（代码量较大，不推荐）</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('198399de-60e3-49dc-bcdc-8b598e4bdf3d')"><img id="code_img_closed_198399de-60e3-49dc-bcdc-8b598e4bdf3d" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_198399de-60e3-49dc-bcdc-8b598e4bdf3d" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('198399de-60e3-49dc-bcdc-8b598e4bdf3d',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_198399de-60e3-49dc-bcdc-8b598e4bdf3d" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200206
</span><span style="color: #008000;">//</span><span style="color: #008000;">PAT A1030 Travel Plan</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;vector&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt; <span style="color: #008000;">//</span><span style="color: #008000;">fill </span>
#include&lt;stack&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> inf = <span style="color: #800080;">0x3fffffff</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> MAXN = <span style="color: #800080;">510</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> book[MAXN]; 
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,start,term;
</span><span style="color: #0000ff;">int</span> data[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">stores the shortest distance of every vertex</span>
<span style="color: #0000ff;">int</span> num[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">record the num of shortest path </span>
<span style="color: #0000ff;">int</span><span style="color: #000000;"> cost[MAXN][MAXN];
</span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> Edge{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> cur;
    </span><span style="color: #0000ff;">int</span> v; <span style="color: #008000;">//</span><span style="color: #008000;">v为该边的另外一个顶点</span>
    <span style="color: #0000ff;">int</span> weight; <span style="color: #008000;">//</span><span style="color: #008000;">该边的边权 
</span><span style="color: #008000;">//</span><span style="color: #008000;">    int cost; </span><span style="color: #008000;">//</span><span style="color: #008000;">该边的花费 </span>
<span style="color: #000000;">};
vector</span>&lt;Edge&gt; adj[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">adj[i]存放从顶点i出发所有能到达的点 ；相当于二维数组 </span>
vector&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> pre[MAXN]; 
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> countk;
</span><span style="color: #0000ff;">int</span> seekmin(){ <span style="color: #008000;">//</span><span style="color: #008000;">seek the min in data[];</span>
    <span style="color: #0000ff;">int</span> minn =<span style="color: #000000;"> inf;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> index;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(book[i]==<span style="color: #800080;">0</span> &amp;&amp; data[i]&lt;<span style="color: #000000;">minn){ 
        </span><span style="color: #008000;">//</span><span style="color: #008000;">make sure not compare with the vertex booked</span>
            minn =<span style="color: #000000;"> data[i];
            index </span>=<span style="color: #000000;"> i;
        }
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> index;
}
</span><span style="color: #0000ff;">void</span> Dijkstra(<span style="color: #0000ff;">int</span> cur,<span style="color: #0000ff;">int</span><span style="color: #000000;"> dis){
    book[cur] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    countk</span>++<span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;adj[cur].size();i++<span style="color: #000000;">){
        Edge e </span>=<span style="color: #000000;"> adj[cur][i];
        </span><span style="color: #0000ff;">if</span>(book[e.v]==<span style="color: #800080;">0</span> &amp;&amp; e.weight+dis&lt;<span style="color: #000000;">data[e.v]){
            data[e.v] </span>= e.weight +<span style="color: #000000;"> dis;
            num[e.v] </span>= num[cur]; <span style="color: #008000;">//</span><span style="color: #008000;">如果小于，就继承 </span>
<span style="color: #000000;">            pre[e.v].clear();
            pre[e.v].push_back(cur);
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(book[e.v]==<span style="color: #800080;">0</span> &amp;&amp; e.weight+dis==data[e.v]){<span style="color: #008000;">//</span><span style="color: #008000;"> 如果等于，就加上 </span>
            num[e.v] +=<span style="color: #000000;"> num[cur];
            pre[e.v].push_back(cur);
        }
        
    }
}
stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s,temppath,finalpath;
</span><span style="color: #0000ff;">int</span> mincost =<span style="color: #000000;"> inf;
</span><span style="color: #0000ff;">int</span> sum = <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">void</span> dfs(<span style="color: #0000ff;">int</span><span style="color: #000000;"> v){
    </span><span style="color: #0000ff;">if</span>(v ==<span style="color: #000000;"> start){
        sum </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span>(!<span style="color: #000000;">temppath.empty()) temppath.pop();
        </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> s.top();
        sum </span>+=<span style="color: #000000;"> cost[v][t];
        temppath.push(v);
        </span><span style="color: #0000ff;">while</span>(s.size() &gt; <span style="color: #800080;">1</span><span style="color: #000000;">){
            </span><span style="color: #0000ff;">int</span> temp =<span style="color: #000000;"> s.top();
            temppath.push(s.top());
            s.pop();
            sum </span>+=<span style="color: #000000;"> cost[temp][s.top()];    
        }
        temppath.push(s.top());
        s.pop();
        </span><span style="color: #0000ff;">if</span>(sum &lt;<span style="color: #000000;"> mincost){
            </span><span style="color: #0000ff;">while</span>(!<span style="color: #000000;">finalpath.empty()) finalpath.pop();
            mincost </span>=<span style="color: #000000;"> sum;
            </span><span style="color: #0000ff;">while</span>(!<span style="color: #000000;">temppath.empty()){
                finalpath.push(temppath.top());
                temppath.pop();
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;    
    }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;pre[v].size();i++<span style="color: #000000;">){
            s.push(v);
            dfs(pre[v][i]);
        }
    }
}
</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> show(){
    </span><span style="color: #0000ff;">while</span>(!<span style="color: #000000;">finalpath.empty()){
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span><span style="color: #000000;">,finalpath.top());
        finalpath.pop();
    }
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d</span><span style="color: #800000;">"</span><span style="color: #000000;">,data[term],mincost);
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,m,a,b,c,d;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d %d</span><span style="color: #800000;">"</span>,&amp;n,&amp;m,&amp;start,&amp;<span style="color: #000000;">term);
    fill(data,data </span>+<span style="color: #000000;"> MAXN,inf);
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>;i&lt;m;i++<span style="color: #000000;">){
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d %d</span><span style="color: #800000;">"</span>,&amp;a,&amp;b,&amp;c,&amp;<span style="color: #000000;">d);
        Edge e1;
        e1.v </span>=<span style="color: #000000;"> b;
        e1.weight </span>=<span style="color: #000000;"> c;
        adj[a].push_back(e1); 
        Edge e2;
        e2.v </span>=<span style="color: #000000;"> a;
        e2.weight </span>=<span style="color: #000000;"> c;
        adj[b].push_back(e2);
        cost[a][b] </span>= cost[b][a] =<span style="color: #000000;"> d; 
    }
    num[start] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    Dijkstra(start,</span><span style="color: #800080;">0</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">while</span>(countk&lt;<span style="color: #000000;">n){
        </span><span style="color: #0000ff;">int</span> next =<span style="color: #000000;"> seekmin();
        </span><span style="color: #0000ff;">int</span> distance =<span style="color: #000000;"> data[next];
        Dijkstra(next,distance);
    }
    dfs(term);
    show();
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>实现方式2：（树结构，参考《算法笔记》P381）</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">void</span> dfs(<span style="color: #0000ff;">int</span><span style="color: #000000;"> v){
    </span><span style="color: #0000ff;">if</span>(v ==<span style="color: #000000;"> start){
        sum </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        temppath.push_back(v);
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=temppath.size()-<span style="color: #800080;">1</span>;i&gt;<span style="color: #800080;">0</span>;i--<span style="color: #000000;">){
            sum </span>+= cost[temppath[i]][temppath[i-<span style="color: #800080;">1</span><span style="color: #000000;">]];
        }
        </span><span style="color: #0000ff;">if</span>(sum &lt;<span style="color: #000000;"> mincost){
            mincost </span>=<span style="color: #000000;"> sum;
            finalpath </span>=<span style="color: #000000;"> temppath;
        }
        temppath.pop_back();
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;    
    }
    temppath.push_back(v);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;pre[v].size();i++<span style="color: #000000;">){
        dfs(pre[v][i]);
    }
    temppath.pop_back();
}</span></pre>
</div>
<p>完整代码：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('a3187d8c-4272-4fcc-8b72-d0b585dee073')"><img id="code_img_closed_a3187d8c-4272-4fcc-8b72-d0b585dee073" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_a3187d8c-4272-4fcc-8b72-d0b585dee073" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('a3187d8c-4272-4fcc-8b72-d0b585dee073',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_a3187d8c-4272-4fcc-8b72-d0b585dee073" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200206
</span><span style="color: #008000;">//</span><span style="color: #008000;">PAT A1030 Travel Plan</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;vector&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt; <span style="color: #008000;">//</span><span style="color: #008000;">fill </span>
#include&lt;stack&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> inf = <span style="color: #800080;">0x3fffffff</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> MAXN = <span style="color: #800080;">510</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> book[MAXN]; 
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,start,term;
</span><span style="color: #0000ff;">int</span> data[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">stores the shortest distance of every vertex</span>
<span style="color: #0000ff;">int</span> num[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">record the num of shortest path </span>
<span style="color: #0000ff;">int</span><span style="color: #000000;"> cost[MAXN][MAXN];
</span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> Edge{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> cur;
    </span><span style="color: #0000ff;">int</span> v; <span style="color: #008000;">//</span><span style="color: #008000;">v为该边的另外一个顶点</span>
    <span style="color: #0000ff;">int</span> weight; <span style="color: #008000;">//</span><span style="color: #008000;">该边的边权 
</span><span style="color: #008000;">//</span><span style="color: #008000;">    int cost; </span><span style="color: #008000;">//</span><span style="color: #008000;">该边的花费 </span>
<span style="color: #000000;">};
vector</span>&lt;Edge&gt; adj[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">adj[i]存放从顶点i出发所有能到达的点 ；相当于二维数组 </span>
vector&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> pre[MAXN]; 
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> countk;
</span><span style="color: #0000ff;">int</span> seekmin(){ <span style="color: #008000;">//</span><span style="color: #008000;">seek the min in data[];</span>
    <span style="color: #0000ff;">int</span> minn =<span style="color: #000000;"> inf;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> index;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(book[i]==<span style="color: #800080;">0</span> &amp;&amp; data[i]&lt;<span style="color: #000000;">minn){ 
        </span><span style="color: #008000;">//</span><span style="color: #008000;">make sure not compare with the vertex booked</span>
            minn =<span style="color: #000000;"> data[i];
            index </span>=<span style="color: #000000;"> i;
        }
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> index;
}
</span><span style="color: #0000ff;">void</span> Dijkstra(<span style="color: #0000ff;">int</span> cur,<span style="color: #0000ff;">int</span><span style="color: #000000;"> dis){
    book[cur] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    countk</span>++<span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;adj[cur].size();i++<span style="color: #000000;">){
        Edge e </span>=<span style="color: #000000;"> adj[cur][i];
        </span><span style="color: #0000ff;">if</span>(book[e.v]==<span style="color: #800080;">0</span> &amp;&amp; e.weight+dis&lt;<span style="color: #000000;">data[e.v]){
            data[e.v] </span>= e.weight +<span style="color: #000000;"> dis;
            num[e.v] </span>= num[cur]; <span style="color: #008000;">//</span><span style="color: #008000;">如果小于，就继承 </span>
<span style="color: #000000;">            pre[e.v].clear();
            pre[e.v].push_back(cur);
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(book[e.v]==<span style="color: #800080;">0</span> &amp;&amp; e.weight+dis==data[e.v]){<span style="color: #008000;">//</span><span style="color: #008000;"> 如果等于，就加上 </span>
            num[e.v] +=<span style="color: #000000;"> num[cur];
            pre[e.v].push_back(cur);
        }
        
    }
}
vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; temppath,finalpath; <span style="color: #008000;">//</span><span style="color: #008000;">temppath不用栈，因为栈只能pop，pop后就没了 </span>
<span style="color: #0000ff;">int</span> mincost =<span style="color: #000000;"> inf;
</span><span style="color: #0000ff;">int</span> sum = <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">void</span> dfs(<span style="color: #0000ff;">int</span><span style="color: #000000;"> v){
    </span><span style="color: #0000ff;">if</span>(v ==<span style="color: #000000;"> start){
        sum </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        temppath.push_back(v);
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=temppath.size()-<span style="color: #800080;">1</span>;i&gt;<span style="color: #800080;">0</span>;i--<span style="color: #000000;">){
            sum </span>+= cost[temppath[i]][temppath[i-<span style="color: #800080;">1</span><span style="color: #000000;">]];
        }
        </span><span style="color: #0000ff;">if</span>(sum &lt;<span style="color: #000000;"> mincost){
            mincost </span>=<span style="color: #000000;"> sum;
            finalpath </span>=<span style="color: #000000;"> temppath;
        }
        temppath.pop_back();
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;    
    }
    temppath.push_back(v);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;pre[v].size();i++<span style="color: #000000;">){
        dfs(pre[v][i]);
    }
    temppath.pop_back();
}
</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> show(){
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=finalpath.size()-<span style="color: #800080;">1</span>;i&gt;=<span style="color: #800080;">0</span>;i--<span style="color: #000000;">){
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span><span style="color: #000000;">,finalpath[i]);
    }
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d</span><span style="color: #800000;">"</span><span style="color: #000000;">,data[term],mincost);
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,m,a,b,c,d;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d %d</span><span style="color: #800000;">"</span>,&amp;n,&amp;m,&amp;start,&amp;<span style="color: #000000;">term);
    fill(data,data </span>+<span style="color: #000000;"> MAXN,inf);
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>;i&lt;m;i++<span style="color: #000000;">){
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d %d</span><span style="color: #800000;">"</span>,&amp;a,&amp;b,&amp;c,&amp;<span style="color: #000000;">d);
        Edge e1;
        e1.v </span>=<span style="color: #000000;"> b;
        e1.weight </span>=<span style="color: #000000;"> c;
        adj[a].push_back(e1); 
        Edge e2;
        e2.v </span>=<span style="color: #000000;"> a;
        e2.weight </span>=<span style="color: #000000;"> c;
        adj[b].push_back(e2);
        cost[a][b] </span>= cost[b][a] =<span style="color: #000000;"> d; 
    }
    num[start] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    Dijkstra(start,</span><span style="color: #800080;">0</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">while</span>(countk&lt;<span style="color: #000000;">n){
        </span><span style="color: #0000ff;">int</span> next =<span style="color: #000000;"> seekmin();
        </span><span style="color: #0000ff;">int</span> distance =<span style="color: #000000;"> data[next];
        Dijkstra(next,distance);
    }
    dfs(term);
    show();
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}
</span><span style="color: #008000;">/*</span><span style="color: #008000;">---Test----
8 11 1 8
1 2 3 10
1 3 3 20
1 4 3 10
4 5 1 30
4 6 1 20
4 7 1 30
5 8 2 40
6 8 2 50
7 8 2 30
3 8 3 20
2 8 3 10
</span><span style="color: #008000;">*/</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;"><strong>算法3：Bellman-Ford算法（简称BF算法）</strong></span></h2>
<p>（参照《算法笔记》P391）</p>
<p>Dijkstra算法适用于无负边权的问题，对于存在负边权的问题，需要用BF算法</p>
<p>&nbsp;但注意：所有的算法都无法解决图中存在负环的问题，因为若存在负环，绕着负环转圈路程会越来越小，所以这个问题本身是无解的。</p>
<p>代码实现：（对于有可达负环情况返回None，可AC<strong>洛谷&nbsp;<a href="https://www.luogu.com.cn/problem/P1339" target="_blank">P1339</a></strong>）</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('ee21c7d1-c443-4ec5-b296-6a4d77e1aef4')"><img id="code_img_closed_ee21c7d1-c443-4ec5-b296-6a4d77e1aef4" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_ee21c7d1-c443-4ec5-b296-6a4d77e1aef4" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('ee21c7d1-c443-4ec5-b296-6a4d77e1aef4',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_ee21c7d1-c443-4ec5-b296-6a4d77e1aef4" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200210
</span><span style="color: #008000;">//</span><span style="color: #008000;">BF adjacent list(vector)</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;vector&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt; <span style="color: #008000;">//</span><span style="color: #008000;">fill </span>
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> inf = <span style="color: #800080;">0x3fffffff</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> MAXN = <span style="color: #800080;">2510</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,start,term;
</span><span style="color: #0000ff;">int</span> data[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">stores the shortest distance of every vertex</span>
<span style="color: #0000ff;">struct</span><span style="color: #000000;"> Edge{
    </span><span style="color: #0000ff;">int</span> v; <span style="color: #008000;">//</span><span style="color: #008000;">v为该边的另外一个顶点</span>
    <span style="color: #0000ff;">int</span> weight; <span style="color: #008000;">//</span><span style="color: #008000;">该边的边权 </span>
<span style="color: #000000;">};
vector</span>&lt;Edge&gt; adj[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">adj[i]存放从顶点i出发所有能到达的点 ；相当于二维数组 </span>
<span style="color: #0000ff;">bool</span><span style="color: #000000;"> BF(){ 
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> k=<span style="color: #800080;">0</span>;k&lt;n-<span style="color: #800080;">1</span>;k++){ <span style="color: #008000;">//</span><span style="color: #008000;">execute n-1 times</span>
        <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++){<span style="color: #008000;">//</span><span style="color: #008000;">traverse all the edges</span>
            <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">0</span>;j&lt;adj[i].size();j++<span style="color: #000000;">){
                </span><span style="color: #0000ff;">int</span> v =<span style="color: #000000;"> adj[i][j].v;
                </span><span style="color: #0000ff;">int</span> weight =<span style="color: #000000;"> adj[i][j].weight;
                </span><span style="color: #0000ff;">if</span>(data[i]+weight &lt; data[v]) data[v] = data[i] +<span style="color: #000000;"> weight;
            }
        }
    }
    </span><span style="color: #0000ff;">bool</span> state = <span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;">判断是否存在从源点可达的负环 </span>
    <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++){<span style="color: #008000;">//</span><span style="color: #008000;">traverse all the edges</span>
        <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">0</span>;j&lt;adj[i].size();j++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">int</span> v =<span style="color: #000000;"> adj[i][j].v;
            </span><span style="color: #0000ff;">int</span> weight =<span style="color: #000000;"> adj[i][j].weight;
            </span><span style="color: #0000ff;">if</span>(data[i]+weight &lt;<span style="color: #000000;"> data[v]){
                state </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                data[v] </span>= data[i] +<span style="color: #000000;"> weight;
            }
        }
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> state;
} 

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,m,a,b,c;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d %d</span><span style="color: #800000;">"</span>,&amp;n,&amp;m,&amp;start,&amp;<span style="color: #000000;">term);
    fill(data,data </span>+<span style="color: #000000;"> MAXN,inf);
    data[start] </span>= <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">源点 </span>
    <span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>;i&lt;m;i++<span style="color: #000000;">){
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d</span><span style="color: #800000;">"</span>,&amp;a,&amp;b,&amp;<span style="color: #000000;">c);
        Edge e1;
        e1.v </span>=<span style="color: #000000;"> b;
        e1.weight </span>=<span style="color: #000000;"> c;
        adj[a].push_back(e1); 
        Edge e2;
        e2.v </span>=<span style="color: #000000;"> a;
        e2.weight </span>=<span style="color: #000000;"> c;
        adj[b].push_back(e2); 
    }
    </span><span style="color: #0000ff;">if</span>(BF()) printf(<span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,data[term]);    
    </span><span style="color: #0000ff;">else</span> printf(<span style="color: #800000;">"</span><span style="color: #800000;">None\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>BF算法变式应用基本同Dijkstra算法，但需要注意记录最短路径条数不一样</p>
<p>代码如下：（AC&nbsp;<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805464397627392" target="_blank">PAT A1030&nbsp;Travel Plan</a>）</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200210
</span><span style="color: #008000;">//</span><span style="color: #008000;"> PAT A1003 Emergency</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;vector&gt;<span style="color: #000000;">
#include</span>&lt;<span style="color: #0000ff;">set</span>&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt; <span style="color: #008000;">//</span><span style="color: #008000;">fill </span>
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> inf = <span style="color: #800080;">0x3fffffff</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> MAXN = <span style="color: #800080;">510</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> book[MAXN]; 
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,start,term;
</span><span style="color: #0000ff;">int</span> data[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">stores the shortest distance of every vertex</span>
<span style="color: #0000ff;">int</span> num[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">record the num of shortest path </span>
<span style="color: #0000ff;">int</span> weig[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;"> the given point-weight </span>
<span style="color: #0000ff;">int</span> w[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">record the point-weight of shortest path </span>

<span style="color: #0000ff;">struct</span><span style="color: #000000;"> Edge{
    </span><span style="color: #0000ff;">int</span> v; <span style="color: #008000;">//</span><span style="color: #008000;">v为该边的另外一个顶点</span>
    <span style="color: #0000ff;">int</span> weight; <span style="color: #008000;">//</span><span style="color: #008000;">该边的边权 </span>
<span style="color: #000000;">};
vector</span>&lt;Edge&gt; adj[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">adj[i]存放从顶点i出发所有能到达的点 ；相当于二维数组</span>
<span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">int</span>&gt; pre[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">used to record the num of different paths </span>
<span style="color: #0000ff;">int</span><span style="color: #000000;"> countk;
</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> BF(){ 
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> k=<span style="color: #800080;">0</span>;k&lt;n-<span style="color: #800080;">1</span>;k++){ <span style="color: #008000;">//</span><span style="color: #008000;">execute n-1 times</span>
        <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++){ <span style="color: #008000;">//</span><span style="color: #008000;">traverse all the edges</span>
            <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">0</span>;j&lt;adj[i].size();j++<span style="color: #000000;">){
                </span><span style="color: #0000ff;">int</span> v =<span style="color: #000000;"> adj[i][j].v;
                </span><span style="color: #0000ff;">int</span> weight =<span style="color: #000000;"> adj[i][j].weight;
                </span><span style="color: #0000ff;">if</span>(data[i]+weight &lt;<span style="color: #000000;"> data[v]){
                    data[v] </span>= data[i] +<span style="color: #000000;"> weight;
                    w[v] </span>= w[i] +<span style="color: #000000;"> weig[v];
                    <span style="background-color: #ffff00;">num[v] </span></span><span style="background-color: #ffff00;">=</span><span style="color: #000000;"><span style="background-color: #ffff00;"> num[i];</span>
                    <span style="background-color: #ffff00;">pre[v].clear();
</span>                   <span style="background-color: #ffff00;"> pre[v].insert(i);</span>
                }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(data[i]+weight ==<span style="color: #000000;"> data[v]){
                    </span><span style="color: #0000ff;">if</span>(w[i]+weig[v] &gt; w[v]) w[v] = w[i] +<span style="color: #000000;"> weig[v];
                    <span style="background-color: #ffff00;">pre[v].insert(i);</span>
                    <span style="background-color: #ffff00;">num[v] </span></span><span style="background-color: #ffff00;">= <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">recount the num</span>
</span>                  <span style="background-color: #ffff00;">  <span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">int</span>&gt;::iterator it =<span style="color: #000000;"> pre[v].begin();
</span></span><span style="background-color: #ffff00;"><span style="color: #0000ff;">for</span>(it;it != pre[v].end();it++<span style="color: #000000;">){
</span></span><span style="background-color: #ffff00;"><span style="color: #000000;"> num[v] </span>+= num[*</span><span style="color: #000000;"><span style="background-color: #ffff00;">it];</span>
                    }
                }
            }
        }
    }
} 

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,m,a,b,c;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d %d</span><span style="color: #800000;">"</span>,&amp;n,&amp;m,&amp;start,&amp;<span style="color: #000000;">term);
    fill(data,data </span>+<span style="color: #000000;"> MAXN,inf);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++) <span style="color: #008000;">//</span><span style="color: #008000;">notice that the min vertex is 0 in this problem</span>
        scanf(<span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">weig[i]);
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>;i&lt;m;i++<span style="color: #000000;">){
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d</span><span style="color: #800000;">"</span>,&amp;a,&amp;b,&amp;<span style="color: #000000;">c);
        Edge e1;
        e1.v </span>=<span style="color: #000000;"> b;
        e1.weight </span>=<span style="color: #000000;"> c;
        adj[a].push_back(e1); 
        Edge e2;
        e2.v </span>=<span style="color: #000000;"> a;
        e2.weight </span>=<span style="color: #000000;"> c;
        adj[b].push_back(e2); 
    }
    w[start] </span>=<span style="color: #000000;"> weig[start];
    num[start] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    data[start] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
    BF();
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,num[term],w[term]);    
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;"><strong>算法4：SPFA算法(Shortest Path Faster Algorithm)</strong></span></h2>
<p>我们发现，每一轮操作都要遍历所有的边，这里面有大量重复性工作。注意到只有当某个顶点的d[]值改变时，从它出发的边的邻接点的d[]值才可能改变。因此我们设立一个队列判断d[]的值是否改变。</p>
<p>代码如下：（可AC<strong>洛谷&nbsp;<a href="https://www.luogu.com.cn/problem/P1339" target="_blank">P1339</a></strong>）</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200210
</span><span style="color: #008000;">//</span><span style="color: #008000;">BF(queue optimised) adjacent list(vector)</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;vector&gt;<span style="color: #000000;">
#include</span>&lt;queue&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt; <span style="color: #008000;">//</span><span style="color: #008000;">fill </span>
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> inf = <span style="color: #800080;">0x3fffffff</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> MAXN = <span style="color: #800080;">2510</span><span style="color: #000000;">; 
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,start,term;
</span><span style="color: #0000ff;">int</span> data[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">stores the shortest distance of every vertex</span>
<span style="color: #0000ff;">struct</span><span style="color: #000000;"> Edge{
    </span><span style="color: #0000ff;">int</span> v; <span style="color: #008000;">//</span><span style="color: #008000;">v为该边的另外一个顶点</span>
    <span style="color: #0000ff;">int</span> weight; <span style="color: #008000;">//</span><span style="color: #008000;">该边的边权 </span>
<span style="color: #000000;">};
vector</span>&lt;Edge&gt; adj[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">adj[i]存放从顶点i出发所有能到达的点 ；相当于二维数组 </span>
<span style="color: #0000ff;">int</span><span style="color: #000000;"> countk;
queue</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> q;
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> inq[MAXN];
</span><span style="color: #0000ff;">int</span> num[MAXN]; <span style="color: #008000;">//</span><span style="color: #008000;">判断是否有可达负环 </span>
<span style="color: #0000ff;">bool</span><span style="color: #000000;"> SPFA(){ 
    </span><span style="color: #0000ff;">while</span>(!<span style="color: #000000;">q.empty()){
        </span><span style="color: #0000ff;">int</span> i =<span style="color: #000000;"> q.front();
        q.pop();
        inq[i] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">0</span>;j&lt;adj[i].size();j++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">int</span> v =<span style="color: #000000;"> adj[i][j].v;
            </span><span style="color: #0000ff;">int</span> weight =<span style="color: #000000;"> adj[i][j].weight;
            </span><span style="color: #0000ff;">if</span>(data[i]+weight &lt;<span style="color: #000000;"> data[v]){
                data[v] </span>= data[i] +<span style="color: #000000;"> weight;
                </span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">inq[v]){
                    q.push(v);
                    inq[v] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                    num[v]</span>++<span style="color: #000000;">;
                    </span><span style="color: #0000ff;">if</span>(num[v] &gt; n) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
            }
        }    
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
} 

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,m,a,b,c;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d %d</span><span style="color: #800000;">"</span>,&amp;n,&amp;m,&amp;start,&amp;<span style="color: #000000;">term);
    fill(data,data </span>+<span style="color: #000000;"> MAXN,inf);
    data[start] </span>= <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">源点 </span>
<span style="color: #000000;">    q.push(start);
    inq[start] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    num[start]</span>++<span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>;i&lt;m;i++<span style="color: #000000;">){
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d</span><span style="color: #800000;">"</span>,&amp;a,&amp;b,&amp;<span style="color: #000000;">c);
        Edge e1;
        e1.v </span>=<span style="color: #000000;"> b;
        e1.weight </span>=<span style="color: #000000;"> c;
        adj[a].push_back(e1); 
        Edge e2;
        e2.v </span>=<span style="color: #000000;"> a;
        e2.weight </span>=<span style="color: #000000;"> c;
        adj[b].push_back(e2); 
    }
    </span><span style="color: #0000ff;">if</span>(SPFA()) printf(<span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,data[term]);    
    </span><span style="color: #0000ff;">else</span> printf(<span style="color: #800000;">"</span><span style="color: #800000;">None\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;"><strong>算法5：Floyd算法 </strong></span></h2>
<p>代码实现：【邻接矩阵】（20190831）</p>
<div class="cnblogs_code">
<pre>#include&lt;stdio.h&gt;
<span style="color: #0000ff;">#define</span> inf 9999999

<span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span> e[<span style="color: #800080;">10</span>][<span style="color: #800080;">10</span><span style="color: #000000;">],k,n,m,t1,t2,t3;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d</span><span style="color: #800000;">"</span>,&amp;n,&amp;<span style="color: #000000;">m);
    </span><span style="color: #008000;">//</span><span style="color: #008000;">矩阵初始化 </span>
    <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(i==j) e[i][j]=<span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> e[i][j]=<span style="color: #000000;">inf;
        }
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">读入边</span>
    <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=m;i++<span style="color: #000000;">){
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d</span><span style="color: #800000;">"</span>,&amp;t1.&amp;t2,&amp;<span style="color: #000000;">t3);
        e[t1][t2]</span>=<span style="color: #000000;">t3;
    }
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;">Floyd算法</span>
    <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> k=<span style="color: #800080;">1</span>;k&lt;=n;k++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
                </span><span style="color: #0000ff;">if</span>(e[i][j]&gt;e[i][k]+<span style="color: #000000;">e[k][j]) {
                    e[i][j]</span>=e[i][k]+<span style="color: #000000;">e[k][j]
                }
            }
        }
    } 
    </span><span style="color: #008000;">//</span><span style="color: #008000;">输出</span>
    <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%10d</span><span style="color: #800000;">"</span><span style="color: #000000;">,e[i][j]);
        }
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    } 
    
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;">五种算法比较</span></h2>
<p><span style="font-family: 楷体;"><img src="https://img2018.cnblogs.com/i-beta/1726496/202002/1726496-20200210154538023-1333384919.png" alt="" width="623" height="223" /></span></p>
<p>&nbsp;说明：其中N是结点数；M是边数（图片来源于《啊哈算法》）</p>
<p>直接采用dfs遍历在数据量很大的时候很容易超时，并且只能求出最短路径，故不建议采用。</p>]]></description></item><item><title>DFS与BFS</title><link>http://www.cnblogs.com/icodes8238/archive/2020/02/05/12262225.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Tue, 04 Feb 2020 16:16:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/02/05/12262225.html</guid><description><![CDATA[<p><strong>图论与dfs：</strong></p>
<p>递归实现：（推荐）</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('e718141e-f6f5-4f37-a05c-1a27e6053ad6')"><img id="code_img_closed_e718141e-f6f5-4f37-a05c-1a27e6053ad6" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_e718141e-f6f5-4f37-a05c-1a27e6053ad6" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('e718141e-f6f5-4f37-a05c-1a27e6053ad6',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_e718141e-f6f5-4f37-a05c-1a27e6053ad6" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20190807</span>
#include&lt;stdio.h&gt;
<span style="color: #0000ff;">#define</span> inf 9999999
<span style="color: #0000ff;">int</span> book[<span style="color: #800080;">101</span>],sum,n,e[<span style="color: #800080;">101</span>][<span style="color: #800080;">101</span><span style="color: #000000;">],start;
</span><span style="color: #0000ff;">int</span> data[<span style="color: #800080;">101</span><span style="color: #000000;">],size;

</span><span style="color: #0000ff;">void</span> dfs (<span style="color: #0000ff;">int</span><span style="color: #000000;"> cur){
    book[cur] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">printf("%d ",cur);</span>
    data[size++] =<span style="color: #000000;"> cur;
    sum</span>++<span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span>(sum==n) <span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">)
        </span><span style="color: #0000ff;">if</span>(e[cur][i]==<span style="color: #800080;">1</span>&amp;&amp;book[i]==<span style="color: #800080;">0</span><span style="color: #000000;">) 
            dfs(i);
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,m,a,b;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d</span><span style="color: #800000;">"</span>,&amp;n,&amp;m,&amp;<span style="color: #000000;">start);
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(i==j) e[i][j]=<span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> e[i][j]=<span style="color: #000000;">inf;
        }
    }
    
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">1</span>;i&lt;=m;i++<span style="color: #000000;">){
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d</span><span style="color: #800000;">"</span>,&amp;a,&amp;<span style="color: #000000;">b);
        e[a][b]</span>=<span style="color: #800080;">1</span><span style="color: #000000;">;
        e[b][a]</span>=<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
    dfs(start);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;size;i++<span style="color: #000000;">){
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span><span style="color: #000000;">,data[i]);
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}
</span><span style="color: #008000;">/*</span><span style="color: #008000;">--------Test-------
//dfs1
9 9 2
1 2
1 3
2 4
2 5
3 6
5 7
3 8
8 9
5 8
//dfs2
9 8 2
1 2
1 3
2 4
2 5
3 6
5 7
3 8
8 9
</span><span style="color: #008000;">*/</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>栈实现：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('8025ab79-8476-4eab-b01d-c8c8ef56a06f')"><img id="code_img_closed_8025ab79-8476-4eab-b01d-c8c8ef56a06f" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_8025ab79-8476-4eab-b01d-c8c8ef56a06f" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('8025ab79-8476-4eab-b01d-c8c8ef56a06f',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_8025ab79-8476-4eab-b01d-c8c8ef56a06f" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20191204</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;stack&gt;
<span style="color: #0000ff;">#define</span> inf 999999
<span style="color: #008000;">//</span><span style="color: #008000;">此题和递归思想高度契合，因此用递归代码更简洁。为加深理解，此处用栈实现 </span>
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span> n,m,a,b,cur,book[<span style="color: #800080;">101</span>],e[<span style="color: #800080;">101</span>][<span style="color: #800080;">101</span><span style="color: #000000;">];
stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
</span><span style="color: #0000ff;">void</span> dfs(<span style="color: #0000ff;">int</span><span style="color: #000000;"> cur){
    </span><span style="color: #0000ff;">if</span>(!book[cur]) cout&lt;&lt;cur&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
    book[cur]</span>=<span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(e[cur][i]==<span style="color: #800080;">1</span>&amp;&amp;book[i]==<span style="color: #800080;">0</span><span style="color: #000000;">){
            s.push(i);
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">if</span>(i==n&amp;!(e[cur][i]==<span style="color: #800080;">1</span>&amp;&amp;book[i]==<span style="color: #800080;">0</span><span style="color: #000000;">)) s.pop();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">当这个结点去dfs却没有向stack里面添加新元素时，则把这个结点pop </span>
<span style="color: #000000;">    }
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    cin</span>&gt;&gt;n&gt;&gt;m;<span style="color: #008000;">//</span><span style="color: #008000;">n vertices, m edges</span>
    <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(i==j) e[i][j]=<span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> e[i][j]=<span style="color: #000000;">inf;
        }
    }
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=m;i++<span style="color: #000000;">){
        cin</span>&gt;&gt;a&gt;&gt;<span style="color: #000000;">b;
        e[a][b]</span>=<span style="color: #800080;">1</span><span style="color: #000000;">;
        e[b][a]</span>=<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
    
    cur </span>= <span style="color: #800080;">2</span>;<span style="color: #008000;">//</span><span style="color: #008000;">start from vertex 2</span>
<span style="color: #000000;">    s.push(cur);

    </span><span style="color: #0000ff;">while</span>(!<span style="color: #000000;">s.empty()){
        cur </span>=<span style="color: #000000;"> s.top();
        dfs(cur);
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}
</span><span style="color: #008000;">/*</span><span style="color: #008000;">--------Test-------
//dfs1
9 9
1 2
1 3
2 4
2 5
3 6
5 7
3 8
8 9
5 8
//dfs2
9 8
1 2
1 3
2 4
2 5
3 6
5 7
3 8
8 9
</span><span style="color: #008000;">*/</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>测试数据图示：（左dfs1，右dfs2）&nbsp;</p>
<p><img src="https://img2018.cnblogs.com/common/1726496/202002/1726496-20200205001710986-1605907467.png" alt="" width="216" height="228" />&nbsp; &nbsp;&nbsp;<img src="https://img2018.cnblogs.com/common/1726496/202002/1726496-20200205001725121-187168496.png" alt="" width="214" height="226" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>图论与bfs：</strong></p>
<p>队列实现：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('fef8d81f-d125-43e7-ac1d-62b150503ca0')"><img id="code_img_closed_fef8d81f-d125-43e7-ac1d-62b150503ca0" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_fef8d81f-d125-43e7-ac1d-62b150503ca0" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('fef8d81f-d125-43e7-ac1d-62b150503ca0',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_fef8d81f-d125-43e7-ac1d-62b150503ca0" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">based on queue, view the notes for pseuodo code</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;queue&gt;
<span style="color: #0000ff;">#define</span> inf 999999
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span> n,m,a,b,cur,book[<span style="color: #800080;">101</span>]={<span style="color: #800080;">0</span>},e[<span style="color: #800080;">101</span>][<span style="color: #800080;">101</span><span style="color: #000000;">],start;
    queue</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> q;
    cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;start;<span style="color: #008000;">//</span><span style="color: #008000;">n vertices, m edges,start from vertxt start</span>
    <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(i==j) e[i][j]=<span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> e[i][j]=<span style="color: #000000;">inf;
        }
    }
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=m;i++<span style="color: #000000;">){
        cin</span>&gt;&gt;a&gt;&gt;<span style="color: #000000;">b;
        e[a][b]</span>=<span style="color: #800080;">1</span><span style="color: #000000;">;
        e[b][a]</span>=<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
    cur </span>= start;<span style="color: #008000;">//</span><span style="color: #008000;">start from vertex cur</span>
<span style="color: #000000;">    q.push(cur);
    book[cur]</span>=<span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">while</span>(!<span style="color: #000000;">q.empty()){
        cur </span>=<span style="color: #000000;"> q.front();
        cout</span>&lt;&lt;cur&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
        q.pop();
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(e[cur][i]==<span style="color: #800080;">1</span>&amp;&amp;book[i]==<span style="color: #800080;">0</span><span style="color: #000000;">){
                q.push(i);
                book[i]</span>=<span style="color: #800080;">1</span><span style="color: #000000;">;
            }
        }    
    }
    
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}
</span><span style="color: #008000;">/*</span><span style="color: #008000;">--------Test-------
9 11 2
1 2
1 3
2 4
2 5
3 6
7 8
6 8
1 5
5 7
3 8
8 9
</span><span style="color: #008000;">*/</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;测试数据图示：</p>
<p><img src="https://img2018.cnblogs.com/common/1726496/202002/1726496-20200205001827704-629820132.png" alt="" width="177" height="217" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>应用</strong></p>
<p><strong>1.有障碍的迷宫dfs：</strong><a href="https://www.luogu.com.cn/problem/P1605" target="_blank">P1605 迷宫</a></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('11e84b36-992c-4de4-ac44-e24503181e02')"><img id="code_img_closed_11e84b36-992c-4de4-ac44-e24503181e02" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_11e84b36-992c-4de4-ac44-e24503181e02" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('11e84b36-992c-4de4-ac44-e24503181e02',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_11e84b36-992c-4de4-ac44-e24503181e02" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200204</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;cmath&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span> chess[<span style="color: #800080;">6</span>][<span style="color: #800080;">6</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> count;
</span><span style="color: #0000ff;">int</span> n,m;<span style="color: #008000;">//</span><span style="color: #008000;">bound</span>
<span style="color: #0000ff;">int</span><span style="color: #000000;"> startx,starty,endx,endy;
</span><span style="color: #0000ff;">int</span> dx[<span style="color: #800080;">4</span>]={<span style="color: #800080;">0</span>,<span style="color: #800080;">0</span>,<span style="color: #800080;">1</span>,-<span style="color: #800080;">1</span><span style="color: #000000;">};
</span><span style="color: #0000ff;">int</span> dy[<span style="color: #800080;">4</span>]={<span style="color: #800080;">1</span>,-<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span>,<span style="color: #800080;">0</span><span style="color: #000000;">};
</span><span style="color: #0000ff;">void</span> dfs(<span style="color: #0000ff;">int</span> x,<span style="color: #0000ff;">int</span><span style="color: #000000;"> y){    
    </span><span style="color: #0000ff;">if</span>(x == endx &amp;&amp; y ==<span style="color: #000000;"> endy){
        count</span>++<span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    }
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;<span style="color: #800080;">4</span>;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(chess[x+dx[i]][y+dy[i]]==<span style="color: #800080;">0</span> &amp;&amp; x+dx[i]&gt;<span style="color: #800080;">0</span> &amp;&amp; x+dx[i]&lt;=m &amp;&amp; y+dy[i]&gt;<span style="color: #800080;">0</span> &amp;&amp; y+dy[i]&lt;=<span style="color: #000000;">n){
            chess[x][y] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
            dfs(x</span>+dx[i],y+<span style="color: #000000;">dy[i]);
            </span><span style="color: #0000ff;">if</span>(chess[x][y] == <span style="color: #800080;">1</span>) chess[x][y] = <span style="color: #800080;">0</span><span style="color: #000000;">;
        }
    }
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d</span><span style="color: #800000;">"</span>,&amp;n,&amp;<span style="color: #000000;">m);
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> num;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">num);
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d %d</span><span style="color: #800000;">"</span>,&amp;startx,&amp;starty,&amp;endx,&amp;<span style="color: #000000;">endy);
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> t1,t2;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;num;i++<span style="color: #000000;">) {
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d</span><span style="color: #800000;">"</span>,&amp;t1,&amp;<span style="color: #000000;">t2);
        chess[t1][t2] </span>= <span style="color: #800080;">2</span><span style="color: #000000;">;
    }
    dfs(startx,starty);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,count);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>启示：如何遍布一个位置的四个方向？</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">int</span> dx[<span style="color: #800080;">4</span>]={<span style="color: #800080;">0</span>,<span style="color: #800080;">0</span>,<span style="color: #800080;">1</span>,-<span style="color: #800080;">1</span><span style="color: #000000;">};
</span><span style="color: #0000ff;">int</span> dy[<span style="color: #800080;">4</span>]={<span style="color: #800080;">1</span>,-<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span>,<span style="color: #800080;">0</span><span style="color: #000000;">};
</span><span style="color: #008000;">//</span><span style="color: #008000;">然后dfs的时候再遍历：</span>
<span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;<span style="color: #800080;">4</span>;i++<span style="color: #000000;">){
    </span><span style="color: #0000ff;">if</span>(chess[x+dx[i]][y+dy[i]]==<span style="color: #800080;">0</span> &amp;&amp; x+dx[i]&gt;<span style="color: #800080;">0</span> &amp;&amp; x+dx[i]&lt;=m &amp;&amp; y+dy[i]&gt;<span style="color: #800080;">0</span> &amp;&amp; y+dy[i]&lt;=<span style="color: #000000;">n){
        chess[x][y] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
        dfs(x</span>+dx[i],y+<span style="color: #000000;">dy[i]);
        </span><span style="color: #0000ff;">if</span>(chess[x][y] == <span style="color: #800080;">1</span>) chess[x][y] = <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
}</span></pre>
</div>
<p>下面是错误代码示例：（错误原因为dfs返回时choice数组不会更新）</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('f2a41bc7-ba1e-4d85-b528-c597412c2f1c')"><img id="code_img_closed_f2a41bc7-ba1e-4d85-b528-c597412c2f1c" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_f2a41bc7-ba1e-4d85-b528-c597412c2f1c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('f2a41bc7-ba1e-4d85-b528-c597412c2f1c',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_f2a41bc7-ba1e-4d85-b528-c597412c2f1c" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200204</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;cmath&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span> chess[<span style="color: #800080;">6</span>][<span style="color: #800080;">6</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> count;
</span><span style="color: #0000ff;">int</span> n,m;<span style="color: #008000;">//</span><span style="color: #008000;">bound</span>
<span style="color: #0000ff;">struct</span><span style="color: #000000;"> node{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> x;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> y;
    </span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> state;    
}start,end,choice[</span><span style="color: #800080;">4</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">void</span> dfs(<span style="color: #0000ff;">int</span> x,<span style="color: #0000ff;">int</span><span style="color: #000000;"> y){
    </span><span style="color: #0000ff;">if</span>(x == end.x &amp;&amp; y ==<span style="color: #000000;"> end.y){
        count</span>++<span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">错误段 </span>
    choice[<span style="color: #800080;">0</span>].state = !chess[x+<span style="color: #800080;">1</span>][y] &amp;&amp; x+<span style="color: #800080;">1</span>&lt;=m &amp;&amp; y&lt;=<span style="color: #000000;">n;
    choice[</span><span style="color: #800080;">0</span>].x = x+<span style="color: #800080;">1</span>; choice[<span style="color: #800080;">0</span>].y =<span style="color: #000000;"> y;
    choice[</span><span style="color: #800080;">1</span>].state = !chess[x-<span style="color: #800080;">1</span>][y] &amp;&amp; x&gt;=<span style="color: #800080;">2</span> &amp;&amp; y&lt;=<span style="color: #000000;">n;
    choice[</span><span style="color: #800080;">1</span>].x = x-<span style="color: #800080;">1</span>; choice[<span style="color: #800080;">1</span>].y =<span style="color: #000000;"> y;
    choice[</span><span style="color: #800080;">2</span>].state = !chess[x][y+<span style="color: #800080;">1</span>] &amp;&amp; x&lt;=m &amp;&amp; y+<span style="color: #800080;">1</span>&lt;=<span style="color: #000000;">n;
    choice[</span><span style="color: #800080;">2</span>].x = x; choice[<span style="color: #800080;">2</span>].y = y+<span style="color: #800080;">1</span><span style="color: #000000;">;
    choice[</span><span style="color: #800080;">3</span>].state = !chess[x][y-<span style="color: #800080;">1</span>] &amp;&amp; x&lt;=m &amp;&amp; y&gt;=<span style="color: #800080;">2</span><span style="color: #000000;">;
    choice[</span><span style="color: #800080;">3</span>].x = x; choice[<span style="color: #800080;">3</span>].y = y-<span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;<span style="color: #800080;">4</span>;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(choice[i].state){ <span style="color: #008000;">//</span><span style="color: #008000;">出错的地方 </span>
            chess[x][y] = <span style="color: #800080;">1</span><span style="color: #000000;">;
            cout</span>&lt;&lt;choice[i].x&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span>&lt;&lt;choice[i].y&lt;&lt;<span style="color: #000000;">endl;
            dfs(choice[i].x,choice[i].y);
            </span><span style="color: #0000ff;">if</span>(chess[x][y])chess[x][y] = <span style="color: #800080;">0</span><span style="color: #000000;">;
        }
    }
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d</span><span style="color: #800000;">"</span>,&amp;n,&amp;<span style="color: #000000;">m);
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> num;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">num);
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d %d</span><span style="color: #800000;">"</span>,&amp;start.x,&amp;start.y,&amp;end.x,&amp;<span style="color: #000000;">end.y);
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> t1,t2;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;num;i++<span style="color: #000000;">) {
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d</span><span style="color: #800000;">"</span>,&amp;t1,&amp;<span style="color: #000000;">t2);
        chess[t1][t2] </span>= <span style="color: #800080;">2</span><span style="color: #000000;">;
    }
    dfs(start.x,start.y);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,count);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p><strong>2. 走迷宫2（bfs）：</strong><a href="https://www.luogu.com.cn/problem/P1141" target="_blank">P1141 01迷宫</a></p>
<p>下面是OJ时TLE代码，但算法思想都没有问题，OJ时每读一组数据判断一次花费了大量时间</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('eccf8483-9b53-45f7-9317-2ba9bbc5f339')"><img id="code_img_closed_eccf8483-9b53-45f7-9317-2ba9bbc5f339" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_eccf8483-9b53-45f7-9317-2ba9bbc5f339" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('eccf8483-9b53-45f7-9317-2ba9bbc5f339',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_eccf8483-9b53-45f7-9317-2ba9bbc5f339" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200204</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">
#include</span>&lt;queue&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">bool</span> chess[<span style="color: #800080;">1010</span>][<span style="color: #800080;">1010</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">bool</span> mark[<span style="color: #800080;">1010</span>][<span style="color: #800080;">1010</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> point{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> x;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> y;
}start,cur;
queue</span>&lt;point&gt;<span style="color: #000000;"> q;
</span><span style="color: #0000ff;">int</span> dx[] = {<span style="color: #800080;">0</span>,<span style="color: #800080;">0</span>,<span style="color: #800080;">1</span>,-<span style="color: #800080;">1</span><span style="color: #000000;">};
</span><span style="color: #0000ff;">int</span> dy[] = {<span style="color: #800080;">1</span>,-<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span>,<span style="color: #800080;">0</span><span style="color: #000000;">};
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,m;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d\n</span><span style="color: #800000;">"</span>,&amp;n,&amp;<span style="color: #000000;">m);
    
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> t;
        getline(cin,t);
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            chess[i][j] </span>= t[j-<span style="color: #800080;">1</span>]-<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        }
    }
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;m;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">int</span> count = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
                mark[i][j] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            }
        }
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d</span><span style="color: #800000;">"</span>,&amp;start.x,&amp;<span style="color: #000000;">start.y);
        q.push(start);
        mark[start.x][start.y] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span>(!<span style="color: #000000;">q.empty()){
            cur </span>=<span style="color: #000000;"> q.front();
            q.pop();
            </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">0</span>;j&lt;<span style="color: #800080;">4</span>;j++<span style="color: #000000;">){
                </span><span style="color: #0000ff;">if</span>(cur.x+dx[j]&gt;<span style="color: #800080;">0</span> &amp;&amp; cur.y+dy[j]&gt;<span style="color: #800080;">0</span> &amp;&amp; cur.x+dx[j]&lt;=n &amp;&amp; cur.y+dy[j]&lt;=n &amp;&amp;!mark[cur.x+dx[j]][cur.y+<span style="color: #000000;">dy[j]]){
                    </span><span style="color: #0000ff;">if</span>(chess[cur.x][cur.y] != chess[cur.x+dx[j]][cur.y+<span style="color: #000000;">dy[j]]){
                        point temp;
                        temp.x </span>= cur.x+<span style="color: #000000;">dx[j];
                        temp.y </span>= cur.y+<span style="color: #000000;">dy[j];
                        q.push(temp);
                        count</span>++<span style="color: #000000;">;
                        mark[temp.x][temp.y] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
                    }    
                }    
            }    
        }
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,count);
    }
    
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>下面是AC代码，算法思想和上面一致，但提前把每一个位置的结果都算好了。</p>
<p>具体计算方法是，bfs时所有在一个队列的点count值都一样（因为这些点是互通的，都能互相访问到）</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('e55918b0-af66-4d01-93da-bf24ac91275b')"><img id="code_img_closed_e55918b0-af66-4d01-93da-bf24ac91275b" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_e55918b0-af66-4d01-93da-bf24ac91275b" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('e55918b0-af66-4d01-93da-bf24ac91275b',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_e55918b0-af66-4d01-93da-bf24ac91275b" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200204</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">
#include</span>&lt;queue&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">bool</span> chess[<span style="color: #800080;">1010</span>][<span style="color: #800080;">1010</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">棋盘的原始信息 </span>
<span style="color: #0000ff;">int</span> mark[<span style="color: #800080;">1010</span>][<span style="color: #800080;">1010</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">存图上每一个点的count值 </span>
<span style="color: #0000ff;">bool</span> visited[<span style="color: #800080;">1010</span>][<span style="color: #800080;">1010</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">bfs时判断该点是否已经被访问过 </span>
<span style="color: #0000ff;">struct</span><span style="color: #000000;"> point{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> x;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> y;
}start,cur;
queue</span>&lt;point&gt;<span style="color: #000000;"> q,q2;
</span><span style="color: #0000ff;">int</span> dx[] = {<span style="color: #800080;">0</span>,<span style="color: #800080;">0</span>,<span style="color: #800080;">1</span>,-<span style="color: #800080;">1</span><span style="color: #000000;">};
</span><span style="color: #0000ff;">int</span> dy[] = {<span style="color: #800080;">1</span>,-<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span>,<span style="color: #800080;">0</span><span style="color: #000000;">};
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,m;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d\n</span><span style="color: #800000;">"</span>,&amp;n,&amp;<span style="color: #000000;">m);
    
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> t;
        getline(cin,t);
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            chess[i][j] </span>= t[j-<span style="color: #800080;">1</span>]-<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        }
    }
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> k=<span style="color: #800080;">1</span>;k&lt;=n;k++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> m=<span style="color: #800080;">1</span>;m&lt;=n;m++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(visited[k][m]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
                visited[k][m] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
                point ttt;
                ttt.x </span>= k; ttt.y =<span style="color: #000000;"> m;
                q.push(ttt);
                </span><span style="color: #0000ff;">int</span> count = <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">while</span>(!<span style="color: #000000;">q.empty()){
                    cur </span>=<span style="color: #000000;"> q.front();
                    q2.push(cur);    
                    q.pop();
                    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">0</span>;j&lt;<span style="color: #800080;">4</span>;j++<span style="color: #000000;">){
                        </span><span style="color: #0000ff;">if</span>(cur.x+dx[j]&gt;<span style="color: #800080;">0</span> &amp;&amp; cur.y+dy[j]&gt;<span style="color: #800080;">0</span> &amp;&amp; cur.x+dx[j]&lt;=n &amp;&amp; cur.y+dy[j]&lt;=n &amp;&amp;!visited[cur.x+dx[j]][cur.y+<span style="color: #000000;">dy[j]]){
                            </span><span style="color: #0000ff;">if</span>(chess[cur.x][cur.y] != chess[cur.x+dx[j]][cur.y+<span style="color: #000000;">dy[j]]){
                                point temp;
                                temp.x </span>= cur.x+<span style="color: #000000;">dx[j];
                                temp.y </span>= cur.y+<span style="color: #000000;">dy[j];
                                q.push(temp);
                                count</span>++<span style="color: #000000;">;
                                visited[temp.x][temp.y] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
                            }    
                        }    
                    }    
                }
                </span><span style="color: #0000ff;">while</span>(!<span style="color: #000000;">q2.empty()){
                    mark[q2.front().x][q2.front().y] </span>=<span style="color: #000000;"> count;
                    q2.pop();
                }
                
            }
            
        }
    }
    
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;m;i++<span style="color: #000000;">){
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d</span><span style="color: #800000;">"</span>,&amp;start.x,&amp;<span style="color: #000000;">start.y);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,mark[start.x][start.y]);
    }
    
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p><strong>3.最少换乘（bfs）：</strong>《啊哈算法》P142</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('06e75450-dbc4-4174-b341-b4d8cb88e770')"><img id="code_img_closed_06e75450-dbc4-4174-b341-b4d8cb88e770" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_06e75450-dbc4-4174-b341-b4d8cb88e770" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('06e75450-dbc4-4174-b341-b4d8cb88e770',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_06e75450-dbc4-4174-b341-b4d8cb88e770" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20190820</span>
#include&lt;stdio.h&gt;
<span style="color: #0000ff;">#define</span> inf 999999<span style="color: #000000;">
typedef </span><span style="color: #0000ff;">struct</span><span style="color: #000000;">{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> head;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> tail;
}queue;
typedef </span><span style="color: #0000ff;">struct</span><span style="color: #000000;">{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> number;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> times;
}point;

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span> n,m,a,b,cur,book[<span style="color: #800080;">101</span>]={<span style="color: #800080;">0</span>},e[<span style="color: #800080;">101</span>][<span style="color: #800080;">101</span>],flag=<span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> start,end;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d %d</span><span style="color: #800000;">"</span>,&amp;n,&amp;m,&amp;start,&amp;<span style="color: #000000;">end);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(i==j) e[i][j]=<span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> e[i][j]=<span style="color: #000000;">inf;
        }
    }
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=m;i++<span style="color: #000000;">){
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d</span><span style="color: #800000;">"</span>,&amp;a,&amp;<span style="color: #000000;">b);
        e[a][b]</span>=<span style="color: #800080;">1</span><span style="color: #000000;">;
        e[b][a]</span>=<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
    queue q;
    q.head</span>=<span style="color: #800080;">1</span><span style="color: #000000;">;
    q.tail</span>=<span style="color: #800080;">1</span><span style="color: #000000;">;
    
    point p[</span><span style="color: #800080;">101</span><span style="color: #000000;">];
    p[q.tail].number</span>=<span style="color: #000000;">start;
    p[q.tail].times</span>=<span style="color: #800080;">0</span><span style="color: #000000;">;
    q.tail</span>++<span style="color: #000000;">;
    
    book[</span><span style="color: #800080;">1</span>]=<span style="color: #000000;">start;
    </span><span style="color: #0000ff;">while</span>(q.head&lt;<span style="color: #000000;">q.tail){
        cur</span>=<span style="color: #000000;">p[q.head].number;
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(e[cur][i]==<span style="color: #800080;">1</span>&amp;&amp;book[i]==<span style="color: #800080;">0</span><span style="color: #000000;">){
                p[q.tail].number</span>=<span style="color: #000000;">i;
                p[q.tail].times </span>+= <span style="color: #800080;">1</span><span style="color: #000000;">;
                book[i]</span>=<span style="color: #800080;">1</span><span style="color: #000000;">;
                
            }
            </span><span style="color: #0000ff;">if</span>(p[q.tail].times==<span style="color: #000000;">end){
                flag</span>=<span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }    
        }
        </span><span style="color: #0000ff;">if</span>(flag) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
        q.head</span>++<span style="color: #000000;">;
    }
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,p[q.tail-<span style="color: #800080;">1</span><span style="color: #000000;">].times);
    
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p><strong>4.填等式（类似于全排列dfs）</strong></p>
<p>全排列、递归相关见&nbsp;<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/icodes8238/p/12257161.html">分治与递归</a></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('a49a8010-5713-4625-bcbb-6709c653c418')"><img id="code_img_closed_a49a8010-5713-4625-bcbb-6709c653c418" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_a49a8010-5713-4625-bcbb-6709c653c418" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('a49a8010-5713-4625-bcbb-6709c653c418',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_a49a8010-5713-4625-bcbb-6709c653c418" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20190820
</span><span style="color: #008000;">//</span><span style="color: #008000;">三位数+三位数=三位数，这九位数要求数字不同 </span>
#include&lt;stdio.h&gt;
<span style="color: #0000ff;">int</span> a[<span style="color: #800080;">15</span>],book[<span style="color: #800080;">15</span><span style="color: #000000;">],sum;
</span><span style="color: #0000ff;">int</span> n=<span style="color: #800080;">9</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">void</span> dfs(<span style="color: #0000ff;">int</span><span style="color: #000000;"> step){
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(book[i]==<span style="color: #800080;">0</span><span style="color: #000000;">){
            a[step]</span>=<span style="color: #000000;">i;
            book[i]</span>=<span style="color: #800080;">1</span><span style="color: #000000;">;
            dfs(step</span>+<span style="color: #800080;">1</span><span style="color: #000000;">);
            book[i]</span>=<span style="color: #800080;">0</span><span style="color: #000000;">;
        }
    }
    </span><span style="color: #0000ff;">if</span>(step==n+<span style="color: #800080;">1</span><span style="color: #000000;">){
        </span><span style="color: #0000ff;">int</span> s1=a[<span style="color: #800080;">1</span>]*<span style="color: #800080;">100</span>+a[<span style="color: #800080;">2</span>]*<span style="color: #800080;">10</span>+a[<span style="color: #800080;">3</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">int</span> s2=a[<span style="color: #800080;">4</span>]*<span style="color: #800080;">100</span>+a[<span style="color: #800080;">5</span>]*<span style="color: #800080;">10</span>+a[<span style="color: #800080;">6</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">int</span> s3=a[<span style="color: #800080;">7</span>]*<span style="color: #800080;">100</span>+a[<span style="color: #800080;">8</span>]*<span style="color: #800080;">10</span>+a[<span style="color: #800080;">9</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">if</span>(s1+s2==<span style="color: #000000;">s3) {
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d%d%d+%d%d%d=%d%d%d\n</span><span style="color: #800000;">"</span>,a[<span style="color: #800080;">1</span>],a[<span style="color: #800080;">2</span>],a[<span style="color: #800080;">3</span>],a[<span style="color: #800080;">4</span>],a[<span style="color: #800080;">5</span>],a[<span style="color: #800080;">6</span>],a[<span style="color: #800080;">7</span>],a[<span style="color: #800080;">8</span>],a[<span style="color: #800080;">9</span><span style="color: #000000;">]);
            sum</span>++<span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    dfs(</span><span style="color: #800080;">1</span><span style="color: #000000;">); 
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span>,sum/<span style="color: #800080;">2</span><span style="color: #000000;">);
    
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>]]></description></item><item><title>递归与分治</title><link>http://www.cnblogs.com/icodes8238/archive/2020/02/03/12257161.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Mon, 03 Feb 2020 12:19:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/02/03/12257161.html</guid><description><![CDATA[<p>《算法笔记》P112~118笔记</p>
<p><strong>如何理解递归？</strong><sup><br /></sup></p>
<p>1.不要想着&ldquo;不停地调用函数&rdquo;，应用<strong><span style="background-color: #ffff00;">数学归纳法</span></strong>的思想理解。</p>
<p>2.注意递归边界</p>
<p>3.寻找递归式（把问题分成若干的子问题，分而治之）</p>
<p>比如Fibonacci数列，F(n)的两个子问题分别是F(n-1)，F(n-2)；</p>
<p>再比如全排列问题，n位数全排列的子问题是n-1位数的全排列；</p>
<p>而n皇后问题则是全排列问题的应用。</p>
<p>4.综上：写递归函数重点关注<span style="text-decoration: underline;"><strong>递归调用过程</strong></span>和<span style="text-decoration: underline;"><strong>递归边界问题</strong></span></p>
<p>&nbsp;</p>
<p><strong>分治问题的模板：</strong></p>
<p>divide-and-conquer(P){</p>
<p>　　if(|P|&lt;=n0) { //解决小规模问题</p>
<p>　　　　adhoc(P); //直接求解P</p>
<p>　　　　return;</p>
<p>　　}</p>
<p>　　divide P into smaller subinstances P1,P2,...,Pk; //分解问题</p>
<p>　　for(int i = 1;i&lt;=k;i++) yi = divide-and-conquer(Pi); //递归的解决各子问题</p>
<p>　　return merge(y1,....,yk); //将子问题的解合并成原问题的解</p>
<p>}</p>
<p>&nbsp;</p>
<p><strong>例题1：求阶乘</strong></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('0ec18fe4-87d2-4908-8113-d6adf06e078e')"><img id="code_img_closed_0ec18fe4-87d2-4908-8113-d6adf06e078e" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_0ec18fe4-87d2-4908-8113-d6adf06e078e" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('0ec18fe4-87d2-4908-8113-d6adf06e078e',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_0ec18fe4-87d2-4908-8113-d6adf06e078e" class="cnblogs_code_hide">
<pre>#include&lt;stdio.h&gt;
<span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
</span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> dfs(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n){
    </span><span style="color: #0000ff;">if</span>(n == <span style="color: #800080;">1</span>)    <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> n*dfs(n-<span style="color: #800080;">1</span><span style="color: #000000;">);
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">n);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%lld\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,dfs(n));
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><strong>例题2：求斐波那契数列</strong></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('ab2cc7ed-dfe8-49e4-a845-68ac0ba9822a')"><img id="code_img_closed_ab2cc7ed-dfe8-49e4-a845-68ac0ba9822a" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_ab2cc7ed-dfe8-49e4-a845-68ac0ba9822a" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('ab2cc7ed-dfe8-49e4-a845-68ac0ba9822a',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_ab2cc7ed-dfe8-49e4-a845-68ac0ba9822a" class="cnblogs_code_hide">
<pre>#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

</span><span style="color: #0000ff;">int</span> Fib(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n){
    </span><span style="color: #0000ff;">if</span>(n==<span style="color: #800080;">0</span> || n==<span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> Fib(n-<span style="color: #800080;">1</span>)+Fib(n-<span style="color: #800080;">2</span><span style="color: #000000;">);
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">n);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;=n;i++) printf(<span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span><span style="color: #000000;">,Fib(i));
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><strong>例题3：全排列问题（数字不重复）</strong></p>
<p>思路1：</p>
<p>递归边界：最后一位已填完，全部输出；</p>
<p>递归过程：前k位已经填完，我们要填第k+1位</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('7793a96b-d2d6-468d-8bef-24770cad0100')"><img id="code_img_closed_7793a96b-d2d6-468d-8bef-24770cad0100" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_7793a96b-d2d6-468d-8bef-24770cad0100" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('7793a96b-d2d6-468d-8bef-24770cad0100',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_7793a96b-d2d6-468d-8bef-24770cad0100" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">任输入n个不同的数字（字符串），输出其全排列 </span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;<span style="color: #0000ff;">string</span>&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">bool</span> b[<span style="color: #800080;">11</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">记录某元素是否出现过 </span>
<span style="color: #0000ff;">int</span> a[<span style="color: #800080;">11</span>],len; <span style="color: #008000;">//</span><span style="color: #008000;">a[]存输入的n个不同数字 </span>
<span style="color: #0000ff;">int</span> per[<span style="color: #800080;">11</span>];<span style="color: #008000;">//</span><span style="color: #008000;">存每一次排列结果 </span>
<span style="color: #0000ff;">void</span> permu(<span style="color: #0000ff;">int</span> deep){ <span style="color: #008000;">//</span><span style="color: #008000;">deep代表在填第几位 </span>
    <span style="color: #0000ff;">if</span>(deep == len){ <span style="color: #008000;">//</span><span style="color: #008000;">终止条件 </span>
        <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;len;i++) cout&lt;&lt;<span style="color: #000000;">per[i];
        cout</span>&lt;&lt;<span style="color: #000000;">endl;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    }
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;len;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(b[a[i]]==<span style="color: #800080;">0</span>){ <span style="color: #008000;">//</span><span style="color: #008000;">元素 a[i] 没有出现过,则加入per[deep]中</span>
            b[a[i]] = <span style="color: #800080;">1</span><span style="color: #000000;">;
            per[deep] </span>=<span style="color: #000000;"> a[i];
            permu(deep</span>+<span style="color: #800080;">1</span>); <span style="color: #008000;">//</span><span style="color: #008000;">分治成n-1个数的全排列 </span>
            b[a[i]] = <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">递归完后复原 </span>
<span style="color: #000000;">        } 
    }
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> s;
    getline(cin,s);
    len </span>=<span style="color: #000000;"> s.length();
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;len;i++) a[i] = s[i]-<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
    permu(</span><span style="color: #800080;">0</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>思路2：</p>
<p>递归边界：（同上）</p>
<p>递归过程：我们以1 2 3的全排为例：</p>
<p>1&nbsp; &nbsp;2 3；&nbsp;1&nbsp; &nbsp;3 2</p>
<p>2&nbsp; &nbsp;1 3；&nbsp;2&nbsp; &nbsp;3 1</p>
<p>3&nbsp; &nbsp;1 2；&nbsp;3&nbsp; &nbsp;2 1</p>
<p>而1 2 的全排如下：1 2；2 1</p>
<p>我们发现,1 2的全排其实就是123后面两位的全排。</p>
<p>而我们对于1 2 全排这个问题是怎么解决的呢？分别让每一个数做开头的第一个数，然后让后面的数做全排。</p>
<p>实现让每个数做第一位数的方法：让第一个数和后面每个数都交换一次即可。</p>
<p>代码如下：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('b3e6c44f-4b26-49f9-a269-9540acea40c8')"><img id="code_img_closed_b3e6c44f-4b26-49f9-a269-9540acea40c8" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_b3e6c44f-4b26-49f9-a269-9540acea40c8" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('b3e6c44f-4b26-49f9-a269-9540acea40c8',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_b3e6c44f-4b26-49f9-a269-9540acea40c8" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200315</span>
#include&lt;iostream&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> MAXN = <span style="color: #800080;">100</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> a[MAXN];
</span><span style="color: #0000ff;">void</span> swap(<span style="color: #0000ff;">int</span> k,<span style="color: #0000ff;">int</span><span style="color: #000000;"> m){
    </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> a[k];
    a[k] </span>=<span style="color: #000000;"> a[m];
    a[m] </span>=<span style="color: #000000;"> t;
}
</span><span style="color: #0000ff;">void</span> perm(<span style="color: #0000ff;">int</span> <span style="color: #0000ff;">from</span>,<span style="color: #0000ff;">int</span><span style="color: #000000;"> n){
    </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">from</span> ==<span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++) printf(<span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span><span style="color: #000000;">,a[i]);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #0000ff;">from</span>;i&lt;n;i++<span style="color: #000000;">){
        swap(</span><span style="color: #0000ff;">from</span><span style="color: #000000;">,i);
        perm(</span><span style="color: #0000ff;">from</span>+<span style="color: #800080;">1</span><span style="color: #000000;">,n);
        swap(</span><span style="color: #0000ff;">from</span><span style="color: #000000;">,i);
    }
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">n);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++) scanf(<span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">a[i]);
    perm(</span><span style="color: #800080;">0</span><span style="color: #000000;">,n);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p><strong>例题4：全排列问题（数字可重复）</strong></p>
<p>思路1：</p>
<p>递归边界和递归过程同上。与上面不同的是，填第k+1位时，哪些数字可填的问题。</p>
<p>如果数字不重复，我们设置一个book数组检验是否在前k位已经填过即可；</p>
<p>如果数字重复，我们需要分配一个数字重复次数的数组，检验前k位已填过数字的次数是否小于用户输入该数字的次数</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('6844150a-9fbe-47b3-b8e9-1a3dcf12fcec')"><img id="code_img_closed_6844150a-9fbe-47b3-b8e9-1a3dcf12fcec" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_6844150a-9fbe-47b3-b8e9-1a3dcf12fcec" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('6844150a-9fbe-47b3-b8e9-1a3dcf12fcec',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_6844150a-9fbe-47b3-b8e9-1a3dcf12fcec" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">任输入n个不同的数字（字符串、可重复），输出其全排列 </span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;<span style="color: #0000ff;">string</span>&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span> b[<span style="color: #800080;">11</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">记录某元素是否出现过 </span>
<span style="color: #0000ff;">int</span> a[<span style="color: #800080;">11</span>],len; <span style="color: #008000;">//</span><span style="color: #008000;">记录用户输入字符串中每个数字的重复次数 </span>
<span style="color: #0000ff;">int</span> per[<span style="color: #800080;">11</span>];<span style="color: #008000;">//</span><span style="color: #008000;">存每一次排列结果 </span>
<span style="color: #0000ff;">void</span> permu(<span style="color: #0000ff;">int</span> deep){ <span style="color: #008000;">//</span><span style="color: #008000;">deep代表在填第几位 </span>
    <span style="color: #0000ff;">if</span>(deep == len){ <span style="color: #008000;">//</span><span style="color: #008000;">终止条件 </span>
        <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;len;i++) cout&lt;&lt;<span style="color: #000000;">per[i];
        cout</span>&lt;&lt;<span style="color: #000000;">endl;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    }
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;<span style="color: #800080;">11</span>;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(a[i]!=<span style="color: #800080;">0</span> &amp;&amp; b[i]&lt;a[i]){ <span style="color: #008000;">//</span><span style="color: #008000;">数字i出现的次数小于用户输入数字i的次数 </span>
            b[i]++<span style="color: #000000;">;
            per[deep] </span>=<span style="color: #000000;"> i;
            permu(deep</span>+<span style="color: #800080;">1</span>); <span style="color: #008000;">//</span><span style="color: #008000;">分治成n-1个数的全排列 </span>
            b[i]--; <span style="color: #008000;">//</span><span style="color: #008000;">递归完后复原 </span>
<span style="color: #000000;">        } 
    }
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> s;
    getline(cin,s);
    len </span>=<span style="color: #000000;"> s.length();
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;len;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">int</span> t = s[i]-<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        a[t]</span>++<span style="color: #000000;">; 
    }
    permu(</span><span style="color: #800080;">0</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p><strong>例题5：全组合问题（从n个数里面挑m个数组合）</strong></p>
<p>思路：访问到某个数时，该数有被选择和不被选择两种情况</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('b7751074-03e1-4cee-a4a1-fbfe42181d07')"><img id="code_img_closed_b7751074-03e1-4cee-a4a1-fbfe42181d07" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_b7751074-03e1-4cee-a4a1-fbfe42181d07" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('b7751074-03e1-4cee-a4a1-fbfe42181d07',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_b7751074-03e1-4cee-a4a1-fbfe42181d07" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200315</span>
#include&lt;iostream&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span> a[<span style="color: #800080;">10</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">bool</span> b[<span style="color: #800080;">10</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,m;

</span><span style="color: #0000ff;">void</span> comb(<span style="color: #0000ff;">int</span> <span style="color: #0000ff;">from</span>,<span style="color: #0000ff;">int</span><span style="color: #000000;"> count){
    </span><span style="color: #0000ff;">if</span>(count ==<span style="color: #000000;"> m) {
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">) 
            </span><span style="color: #0000ff;">if</span>(b[i]==<span style="color: #800080;">1</span>) printf(<span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span><span style="color: #000000;">,a[i]);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    }
    </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">from</span> == n) <span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    b[</span><span style="color: #0000ff;">from</span>] = <span style="color: #800080;">1</span><span style="color: #000000;">;
    comb(</span><span style="color: #0000ff;">from</span>+<span style="color: #800080;">1</span>,count+<span style="color: #800080;">1</span><span style="color: #000000;">);
    b[</span><span style="color: #0000ff;">from</span>] = <span style="color: #800080;">0</span><span style="color: #000000;">;
    comb(</span><span style="color: #0000ff;">from</span>+<span style="color: #800080;">1</span><span style="color: #000000;">,count);
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d</span><span style="color: #800000;">"</span>,&amp;n,&amp;<span style="color: #000000;">m);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++) scanf(<span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">a[i]);
    comb(</span><span style="color: #800080;">0</span>,<span style="color: #800080;">0</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p><strong>例题6：n皇后问题</strong>（洛谷 <a href="https://www.luogu.com.cn/problem/P1219" target="_blank">P1219 八皇后</a>）</p>
<p>暴力法：（n&gt;=11时TLE）</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('c4c388d1-a569-4fc8-a022-8cf4c4612e8a')"><img id="code_img_closed_c4c388d1-a569-4fc8-a022-8cf4c4612e8a" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_c4c388d1-a569-4fc8-a022-8cf4c4612e8a" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('c4c388d1-a569-4fc8-a022-8cf4c4612e8a',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_c4c388d1-a569-4fc8-a022-8cf4c4612e8a" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200203
</span><span style="color: #008000;">//</span><span style="color: #008000;">n皇后问题 （n&gt;10时超时） </span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">
#include</span>&lt;cmath&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">bool</span> b[<span style="color: #800080;">15</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,count;  
</span><span style="color: #0000ff;">int</span> ans[<span style="color: #800080;">3</span>][<span style="color: #800080;">15</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span> per[<span style="color: #800080;">15</span>];<span style="color: #008000;">//</span><span style="color: #008000;">存每一行皇后所在的列数 </span>
<span style="color: #0000ff;">bool</span> state[<span style="color: #800080;">20</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> test(){
    </span><span style="color: #0000ff;">bool</span> state = <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">int</span> num = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=i+<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(abs(i-j) == abs(per[i]-<span style="color: #000000;">per[j])){
                state </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            } 
        }
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> state;
}
</span><span style="color: #0000ff;">void</span> permu(<span style="color: #0000ff;">int</span><span style="color: #000000;"> deep){
    </span><span style="color: #0000ff;">if</span>(deep == n+<span style="color: #800080;">1</span>){ <span style="color: #008000;">//</span><span style="color: #008000;">终止条件 </span>
        <span style="color: #0000ff;">if</span>(test()){ <span style="color: #008000;">//</span><span style="color: #008000;">对每一种情况都进行判断</span>
            <span style="color: #0000ff;">if</span>(count&lt;<span style="color: #800080;">3</span><span style="color: #000000;">){
                </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">) 
                    ans[count][i] </span>=<span style="color: #000000;"> per[i];        
            }
            count</span>++<span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    }
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(b[i]==<span style="color: #800080;">0</span><span style="color: #000000;">){
            b[i] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
            per[deep] </span>=<span style="color: #000000;"> i;
            permu(deep</span>+<span style="color: #800080;">1</span>); <span style="color: #008000;">//</span><span style="color: #008000;">分治成n-1个数的全排列 </span>
            b[i] = <span style="color: #800080;">0</span><span style="color: #000000;">; 
        } 
    }
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">n);
    permu(</span><span style="color: #800080;">1</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;<span style="color: #800080;">3</span>;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span><span style="color: #000000;">,ans[i][j]);
        }
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    }
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span><span style="color: #000000;">,count);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>回溯法：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('10511f5b-5fc5-40d9-9267-3d145ec3be5d')"><img id="code_img_closed_10511f5b-5fc5-40d9-9267-3d145ec3be5d" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_10511f5b-5fc5-40d9-9267-3d145ec3be5d" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('10511f5b-5fc5-40d9-9267-3d145ec3be5d',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_10511f5b-5fc5-40d9-9267-3d145ec3be5d" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200203
</span><span style="color: #008000;">//</span><span style="color: #008000;">n皇后问题 P1219 八皇后（全排列知识拓展） </span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">
#include</span>&lt;cmath&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">bool</span> b[<span style="color: #800080;">15</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,count;  
</span><span style="color: #0000ff;">int</span> ans[<span style="color: #800080;">3</span>][<span style="color: #800080;">15</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span> per[<span style="color: #800080;">15</span>];<span style="color: #008000;">//</span><span style="color: #008000;">存每一行皇后所在的列数 </span>
<span style="color: #0000ff;">bool</span> test(<span style="color: #0000ff;">int</span><span style="color: #000000;"> deep){
    </span><span style="color: #0000ff;">bool</span> state = <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">int</span> num = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;deep;i++){ <span style="color: #008000;">//</span><span style="color: #008000;">判断两个元素是否在对角线上 </span>
        <span style="color: #0000ff;">if</span>(abs(i-deep) == abs(per[i]-<span style="color: #000000;">per[deep])){
            state </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        } 
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> state;
}
</span><span style="color: #0000ff;">void</span> permu(<span style="color: #0000ff;">int</span><span style="color: #000000;"> deep){
    </span><span style="color: #0000ff;">if</span>(deep == n+<span style="color: #800080;">1</span>){ <span style="color: #008000;">//</span><span style="color: #008000;">终止条件 </span>
        <span style="color: #0000ff;">if</span>(count&lt;<span style="color: #800080;">3</span><span style="color: #000000;">){
            </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">) 
                ans[count][i] </span>=<span style="color: #000000;"> per[i];        
        }
        count</span>++<span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    }
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(b[i]==<span style="color: #800080;">0</span><span style="color: #000000;">){
            b[i] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
            per[deep] </span>=<span style="color: #000000;"> i;
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(test(deep)) {
                permu(deep</span>+<span style="color: #800080;">1</span>); <span style="color: #008000;">//</span><span style="color: #008000;">分治成n-1个数的全排列 </span>
                b[i] = <span style="color: #800080;">0</span><span style="color: #000000;">;
            }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
                b[i] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                per[deep] </span>= <span style="color: #800080;">0</span>;    <span style="color: #008000;">//</span><span style="color: #008000;">复原 </span>
<span style="color: #000000;">            }
        } 
    }
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">n);
    permu(</span><span style="color: #800080;">1</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;<span style="color: #800080;">3</span>;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span><span style="color: #000000;">,ans[i][j]);
        }
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    }
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span><span style="color: #000000;">,count);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>本题反思：注意判断两个元素是否在对角线上的方法</p>
<p>&nbsp;</p>
<p><strong>例题7：Strassen矩阵乘法</strong>20200321</p>
<p>分析过程：<a href="https://zhuanlan.zhihu.com/p/78657463" target="_blank">知乎</a></p>
<p>代码实现（matlab）：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('9ab312e5-20a7-48c8-a351-f7f92224460a')"><img id="code_img_closed_9ab312e5-20a7-48c8-a351-f7f92224460a" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_9ab312e5-20a7-48c8-a351-f7f92224460a" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('9ab312e5-20a7-48c8-a351-f7f92224460a',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_9ab312e5-20a7-48c8-a351-f7f92224460a" class="cnblogs_code_hide">
<pre>%<span style="color: #000000;">输入n需为2的倍数
function C </span>=<span style="color: #000000;"> Strassen (A,B)
    </span><span style="color: #0000ff;">if</span>(isscalar(A) &amp;&amp; isscalar(B)) %isscalar ==<span style="color: #800080;">0</span> <span style="color: #0000ff;">if</span> size(A,<span style="color: #800080;">1</span>)=<span style="color: #800080;">1</span><span style="color: #000000;"> 
        C </span>= A*<span style="color: #000000;">B;
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;">
        sa </span>= size(A,<span style="color: #800080;">1</span><span style="color: #000000;">);
        sb </span>= size(B,<span style="color: #800080;">1</span><span style="color: #000000;">);
        A11 </span>= A(<span style="color: #800080;">1</span>:sa/<span style="color: #800080;">2</span>,<span style="color: #800080;">1</span>:sa/<span style="color: #800080;">2</span><span style="color: #000000;">);
        A12 </span>= A(<span style="color: #800080;">1</span>:sa/<span style="color: #800080;">2</span>,sa/<span style="color: #800080;">2</span>+<span style="color: #800080;">1</span><span style="color: #000000;">:sa);
        A21 </span>= A(sa/<span style="color: #800080;">2</span>+<span style="color: #800080;">1</span>:sa,<span style="color: #800080;">1</span>:sa/<span style="color: #800080;">2</span><span style="color: #000000;">);
        A22 </span>= A(sa/<span style="color: #800080;">2</span>+<span style="color: #800080;">1</span>:sa,sa/<span style="color: #800080;">2</span>+<span style="color: #800080;">1</span><span style="color: #000000;">:sa);
        B11 </span>= B(<span style="color: #800080;">1</span>:sb/<span style="color: #800080;">2</span>,<span style="color: #800080;">1</span>:sb/<span style="color: #800080;">2</span><span style="color: #000000;">);
        B12 </span>= B(<span style="color: #800080;">1</span>:sb/<span style="color: #800080;">2</span>,sb/<span style="color: #800080;">2</span>+<span style="color: #800080;">1</span><span style="color: #000000;">:sb);
        B21 </span>= B(sb/<span style="color: #800080;">2</span>+<span style="color: #800080;">1</span>:sb,<span style="color: #800080;">1</span>:sb/<span style="color: #800080;">2</span><span style="color: #000000;">);
        B22 </span>= B(sb/<span style="color: #800080;">2</span>+<span style="color: #800080;">1</span>:sb,sb/<span style="color: #800080;">2</span>+<span style="color: #800080;">1</span><span style="color: #000000;">:sb);
        S1 </span>= B12 -<span style="color: #000000;"> B22;
        S2 </span>= A11 +<span style="color: #000000;"> A12;
        S3 </span>= A21 +<span style="color: #000000;"> A22;
        S4 </span>= B21 -<span style="color: #000000;"> B11;
        S5 </span>= A11 +<span style="color: #000000;"> A22;
        S6 </span>= B11 +<span style="color: #000000;"> B22;
        S7 </span>= A12 -<span style="color: #000000;"> A22;
        S8 </span>= B21 +<span style="color: #000000;"> B22;
        S9 </span>= A11 -<span style="color: #000000;"> A21;
        S10 </span>= B11 +<span style="color: #000000;"> B12;
        P1 </span>=<span style="color: #000000;"> Strassen (A11,S1);
        P2 </span>=<span style="color: #000000;"> Strassen (S2,B22);
        P3 </span>=<span style="color: #000000;"> Strassen (S3,B11);
        P4 </span>=<span style="color: #000000;"> Strassen (A22,S4);
        P5 </span>=<span style="color: #000000;"> Strassen (S5,S6);
        P6 </span>=<span style="color: #000000;"> Strassen (S7,S8);
        P7 </span>=<span style="color: #000000;"> Strassen (S9,S10);
        C11 </span>= P5 + P4 - P2 +<span style="color: #000000;"> P6;
        C12 </span>= P1 +<span style="color: #000000;"> P2;
        C21 </span>= P3 +<span style="color: #000000;"> P4;
        C22 </span>= P5 + P1 - P3 -<span style="color: #000000;"> P7;
        C </span>=<span style="color: #000000;"> [C11 C12;C21 C22];
    end
end 


</span>%<span style="color: #000000;">main函数
A </span>= [<span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">3</span> <span style="color: #800080;">4</span>;<span style="color: #800080;">4</span> <span style="color: #800080;">5</span> <span style="color: #800080;">6</span> <span style="color: #800080;">7</span>;<span style="color: #800080;">7</span> <span style="color: #800080;">8</span> <span style="color: #800080;">9</span> <span style="color: #800080;">10</span>;<span style="color: #800080;">10</span> <span style="color: #800080;">11</span> <span style="color: #800080;">12</span> <span style="color: #800080;">13</span><span style="color: #000000;">];
B </span>= [<span style="color: #800080;">5</span> <span style="color: #800080;">2</span> <span style="color: #800080;">6</span> <span style="color: #800080;">4</span>;<span style="color: #800080;">9</span> <span style="color: #800080;">5</span> <span style="color: #800080;">4</span> <span style="color: #800080;">7</span>;<span style="color: #800080;">7</span> <span style="color: #800080;">8</span> <span style="color: #800080;">4</span> <span style="color: #800080;">10</span>;<span style="color: #800080;">10</span> <span style="color: #800080;">6</span> <span style="color: #800080;">12</span> <span style="color: #800080;">2</span><span style="color: #000000;">];
C </span>=<span style="color: #000000;"> Strassen (A,B)
X </span>= ceil(rand(<span style="color: #800080;">16</span>,<span style="color: #800080;">16</span>)*<span style="color: #800080;">10</span><span style="color: #000000;">);
Y </span>= ceil(rand(<span style="color: #800080;">16</span>,<span style="color: #800080;">16</span>)*<span style="color: #800080;">10</span><span style="color: #000000;">);
Z </span>=<span style="color: #000000;"> Strassen (X,Y)
    </span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p><strong>例题8：L型棋盘填充问题</strong>20200321</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('00c4d2d1-1348-491d-a253-b7aae13a66fd')"><img id="code_img_closed_00c4d2d1-1348-491d-a253-b7aae13a66fd" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_00c4d2d1-1348-491d-a253-b7aae13a66fd" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('00c4d2d1-1348-491d-a253-b7aae13a66fd',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_00c4d2d1-1348-491d-a253-b7aae13a66fd" class="cnblogs_code_hide">
<pre>#include&lt;stdio.h&gt;
<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> MAXN = <span style="color: #800080;">2048</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> chess[MAXN][MAXN];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> color,size;
</span><span style="color: #0000ff;">void</span> div(<span style="color: #0000ff;">int</span> x,<span style="color: #0000ff;">int</span> y,<span style="color: #0000ff;">int</span> sx,<span style="color: #0000ff;">int</span> sy,<span style="color: #0000ff;">int</span><span style="color: #000000;"> size){ 
    
    </span><span style="color: #0000ff;">if</span>(size == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    </span><span style="color: #0000ff;">int</span> c = color++; <span style="color: #008000;">//</span><span style="color: #008000;">color++;</span>
    <span style="color: #0000ff;">int</span> s = size/<span style="color: #800080;">2</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span>(sx&lt;x+s &amp;&amp; sy&lt;y+s){ <span style="color: #008000;">//</span><span style="color: #008000;">special block is in top-left</span>
<span style="color: #000000;">        div(x,y,sx,sy,s);
    }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
        chess[x</span>+s-<span style="color: #800080;">1</span>][y+s-<span style="color: #800080;">1</span>] =<span style="color: #000000;"> c;
        div(x,y,x</span>+s-<span style="color: #800080;">1</span>,y+s-<span style="color: #800080;">1</span><span style="color: #000000;">,s); 
    }
    
    </span><span style="color: #0000ff;">if</span>(sx&lt;x+s &amp;&amp; sy&gt;=y+s){ <span style="color: #008000;">//</span><span style="color: #008000;">special block is in top-right</span>
        div(x,y+<span style="color: #000000;">s,sx,sy,s);
    }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
        chess[x</span>+s-<span style="color: #800080;">1</span>][y+s] =<span style="color: #000000;"> c;
        div(x,y</span>+s,x+s-<span style="color: #800080;">1</span>,y+<span style="color: #000000;">s,s); 
    }
    
    </span><span style="color: #0000ff;">if</span>(sx&gt;=x+s &amp;&amp; sy&lt;y+s){ <span style="color: #008000;">//</span><span style="color: #008000;">special block is in bottom-left</span>
        div(x+<span style="color: #000000;">s,y,sx,sy,s);
    }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
        chess[x</span>+s][y+s-<span style="color: #800080;">1</span>] =<span style="color: #000000;"> c;
        div(x</span>+s,y,x+s,y+s-<span style="color: #800080;">1</span><span style="color: #000000;">,s); 
    }
    
    </span><span style="color: #0000ff;">if</span>(sx&gt;=x+s &amp;&amp; sy&gt;=y+s){ <span style="color: #008000;">//</span><span style="color: #008000;">special block is in bottom-right</span>
        div(x+s,y+<span style="color: #000000;">s,sx,sy,s);
    }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
        chess[x</span>+s][y+s] =<span style="color: #000000;"> c;
        div(x</span>+s,y+s,x+s,y+<span style="color: #000000;">s,s); 
    }
    
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">size);
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> spex,spey;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d</span><span style="color: #800000;">"</span>,&amp;spex,&amp;<span style="color: #000000;">spey);
    chess[spex][spey] </span>= -<span style="color: #800080;">1</span><span style="color: #000000;">;
    div(</span><span style="color: #800080;">0</span>,<span style="color: #800080;">0</span><span style="color: #000000;">,spex,spey,size);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;size;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">0</span>;j&lt;size;j++<span style="color: #000000;">)
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%4d</span><span style="color: #800000;">"</span><span style="color: #000000;">,chess[i][j]);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>思考：递归调用时一定要注意全局和局部变量</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('fdcfb4bf-b4c8-40c2-8545-9a0c4804229a')"><img id="code_img_closed_fdcfb4bf-b4c8-40c2-8545-9a0c4804229a" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_fdcfb4bf-b4c8-40c2-8545-9a0c4804229a" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('fdcfb4bf-b4c8-40c2-8545-9a0c4804229a',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_fdcfb4bf-b4c8-40c2-8545-9a0c4804229a" class="cnblogs_code_hide">
<pre>#include&lt;stdio.h&gt;
<span style="color: #0000ff;">int</span> a = <span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">void</span> test(<span style="color: #0000ff;">int</span><span style="color: #000000;"> b){
    </span><span style="color: #0000ff;">if</span>(b==<span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    </span><span style="color: #0000ff;">int</span> c = a+<span style="color: #800080;">1</span><span style="color: #000000;">;
    a</span>++<span style="color: #000000;">;
    test(b</span>-<span style="color: #800080;">1</span><span style="color: #000000;">);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,a,c);
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    test(</span><span style="color: #800080;">5</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p><strong>例题9：归并排序与快速排序</strong></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('a40dec09-1e7c-4b00-bcef-c21e05095c65')"><img id="code_img_closed_a40dec09-1e7c-4b00-bcef-c21e05095c65" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_a40dec09-1e7c-4b00-bcef-c21e05095c65" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('a40dec09-1e7c-4b00-bcef-c21e05095c65',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_a40dec09-1e7c-4b00-bcef-c21e05095c65" class="cnblogs_code_hide">
<pre>#include&lt;iostream&gt;
<span style="color: #0000ff;">#define</span> threshold 3
<span style="color: #008000;">//</span><span style="color: #008000;">当小于一定阈值时，直接调用快速排序 </span>
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;

</span><span style="color: #0000ff;">void</span> quicksort(<span style="color: #0000ff;">int</span> a[],<span style="color: #0000ff;">int</span> left,<span style="color: #0000ff;">int</span><span style="color: #000000;"> right){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,temp;
    </span><span style="color: #0000ff;">if</span>(left&gt;right) <span style="color: #0000ff;">return</span><span style="color: #000000;"> ; 
    
    temp </span>= a[left];<span style="color: #008000;">//</span><span style="color: #008000;">temp是基准数，选取数列中最左侧的数为基准数 </span>
    i = left;<span style="color: #008000;">//</span><span style="color: #008000;">i负责从左往右搜索比基准数大的数 </span>
    j = right;<span style="color: #008000;">//</span><span style="color: #008000;">j负责从右往左搜索比基准数小的数 </span>
    <span style="color: #0000ff;">while</span>(i !=<span style="color: #000000;"> j){
        </span><span style="color: #0000ff;">while</span>(i &lt; j &amp;&amp; a[j] &gt;= temp) j--;<span style="color: #008000;">//</span><span style="color: #008000;">注意顺序，先从右往左搜索 </span>
        <span style="color: #0000ff;">while</span>(i &lt; j &amp;&amp; a[i] &lt;= temp) i++<span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span>(i &lt; j){<span style="color: #008000;">//</span><span style="color: #008000;">交换两数的位置 </span>
            <span style="color: #0000ff;">int</span><span style="color: #000000;"> t;
            t </span>=<span style="color: #000000;"> a[i];
            a[i] </span>=<span style="color: #000000;"> a[j];
            a[j] </span>=<span style="color: #000000;"> t;
        }
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">结束循环后，i==j </span>
    a[left] =<span style="color: #000000;"> a[i];
    a[i] </span>=<span style="color: #000000;"> temp;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">上述两步交换了基准数的位置 </span>
<span style="color: #000000;">    
    quicksort(a,left,i</span>-<span style="color: #800080;">1</span>);<span style="color: #008000;">//</span><span style="color: #008000;">递归对i左侧的数进行同样操作 </span>
    quicksort(a,i+<span style="color: #800080;">1</span>,right);<span style="color: #008000;">//</span><span style="color: #008000;">递归对i右侧的数进行同样操作 </span>
<span style="color: #000000;">    
}

</span><span style="color: #0000ff;">void</span> mergesort(<span style="color: #0000ff;">int</span> A[],<span style="color: #0000ff;">int</span> temp[], <span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span><span style="color: #000000;"> right) {
    </span><span style="color: #0000ff;">if</span> (right - left &lt;=<span style="color: #000000;"> threshold) {
        quicksort(A,left,right);
        </span><span style="color: #0000ff;">return</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> List of one element</span>
<span style="color: #000000;">    }
    </span><span style="color: #0000ff;">int</span> mid = (left+right)/<span style="color: #800080;">2</span><span style="color: #000000;">;
    mergesort(A, temp, left, mid);
    mergesort(A, temp, mid</span>+<span style="color: #800080;">1</span><span style="color: #000000;">, right);
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i=left; i&lt;=right; i++) <span style="color: #008000;">//</span><span style="color: #008000;"> Copy subarray to temp</span>
        temp[i] = A[i];<span style="color: #008000;">//</span><span style="color: #008000;"> Do the merge operation back to A</span>
    <span style="color: #0000ff;">int</span> i1 = left; <span style="color: #0000ff;">int</span> i2 = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> curr=left; curr&lt;=right; curr++<span style="color: #000000;">) {
        </span><span style="color: #0000ff;">if</span> (i1 == mid+<span style="color: #800080;">1</span>) <span style="color: #008000;">//</span><span style="color: #008000;"> Left sublist exhausted</span>
            A[curr] = temp[i2++<span style="color: #000000;">];
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (i2 &gt; right) <span style="color: #008000;">//</span><span style="color: #008000;"> Right sublist exhausted</span>
            A[curr] = temp[i1++<span style="color: #000000;">];
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (temp[i1]&lt;<span style="color: #000000;">temp[i2])
            A[curr] </span>= temp[i1++<span style="color: #000000;">];
        </span><span style="color: #0000ff;">else</span> A[curr] = temp[i2++<span style="color: #000000;">];
    }
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++) cout&lt;&lt;A[i]&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
    cout</span>&lt;&lt;<span style="color: #000000;">endl;
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    cin</span>&gt;&gt;<span style="color: #000000;">n;
    </span><span style="color: #0000ff;">int</span> a[<span style="color: #800080;">20</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i =<span style="color: #800080;">0</span>;i&lt;n;i++) cin&gt;&gt;<span style="color: #000000;">a[i];
    </span><span style="color: #0000ff;">int</span> temp[<span style="color: #800080;">20</span>] = {<span style="color: #800080;">0</span><span style="color: #000000;">};
    mergesort(a,temp,</span><span style="color: #800080;">0</span>,n-<span style="color: #800080;">1</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}

</span><span style="color: #008000;">/*</span><span style="color: #008000;">-------Test-------
14
17 5 0 88 21 35 5 3 8 56 34 54 66 10
25
17 5 0 88 21 35 5 3 8 56 34 54 66 10 38 75 67 58 98 65 22 45 60 81 40
</span><span style="color: #008000;">*/</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p><strong><a href="https://www.cnblogs.com/icodes8238/p/12243155.html" target="_blank">例题10：寻找第k大的数（线性时间）</a></strong></p>
<p>&nbsp;</p>
<p><strong>例题11：</strong><a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/icodes8238/p/12630001.html">最短距离点对问题（几何中的分治法）</a></p>
<p>&nbsp;</p>
<p>例题12：循环赛表的填充问题</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('9b477522-c566-4de5-b7d9-ad19930c7b43')"><img id="code_img_closed_9b477522-c566-4de5-b7d9-ad19930c7b43" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_9b477522-c566-4de5-b7d9-ad19930c7b43" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('9b477522-c566-4de5-b7d9-ad19930c7b43',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_9b477522-c566-4de5-b7d9-ad19930c7b43" class="cnblogs_code_hide">
<pre>#include&lt;stdio.h&gt;<span style="color: #000000;">
#include</span>&lt;math.h&gt;
<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> MAXN = <span style="color: #800080;">9999</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> team[MAXN][MAXN];
</span><span style="color: #0000ff;">void</span> circul(<span style="color: #0000ff;">int</span><span style="color: #000000;"> dim){
    </span><span style="color: #0000ff;">if</span>(dim == <span style="color: #800080;">1</span><span style="color: #000000;">){
        team[</span><span style="color: #800080;">1</span>][<span style="color: #800080;">1</span>] = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    }
    dim </span>/= <span style="color: #800080;">2</span><span style="color: #000000;">;
    circul(dim);
    </span><span style="color: #008000;">//</span><span style="color: #008000;">copy top-left to bottom-right</span>
    <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=dim+<span style="color: #800080;">1</span>;i&lt;=dim*<span style="color: #800080;">2</span>;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=dim+<span style="color: #800080;">1</span>;j&lt;=dim*<span style="color: #800080;">2</span>;j++<span style="color: #000000;">){
            team[i][j] </span>= team[i-dim][j-<span style="color: #000000;">dim];
        }
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">creat top-rigt from top-left</span>
    <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=dim;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=dim+<span style="color: #800080;">1</span>;j&lt;=dim*<span style="color: #800080;">2</span>;j++<span style="color: #000000;">){
            team[i][j] </span>= team[i][j-dim] + pow(<span style="color: #800080;">2</span>,dim/<span style="color: #800080;">2</span><span style="color: #000000;">);
        }
    }
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;">copy top-right to bottom-left</span>
    <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=dim+<span style="color: #800080;">1</span>;i&lt;=dim*<span style="color: #800080;">2</span>;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=dim;j++<span style="color: #000000;">){
            team[i][j] </span>= team[i-dim][j+<span style="color: #000000;">dim];
        }
    }
    
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">n);
    circul(n);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">)
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%3d </span><span style="color: #800000;">"</span><span style="color: #000000;">,team[i][j]);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>]]></description></item><item><title>队列、栈、链表（STL）</title><link>http://www.cnblogs.com/icodes8238/archive/2020/02/03/12255222.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Mon, 03 Feb 2020 04:50:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/02/03/12255222.html</guid><description><![CDATA[<p><strong>队列、栈、链表均可调用STL中的容器。</strong></p>
<p>&nbsp;</p>
<p><strong>手写动态链表：</strong>（《算法笔记》P253也有详细讲解）</p>
<p>代码：头结点单链表 20190923</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('5c324171-1cec-48e0-8e30-68462278b67a')"><img id="code_img_closed_5c324171-1cec-48e0-8e30-68462278b67a" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_5c324171-1cec-48e0-8e30-68462278b67a" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('5c324171-1cec-48e0-8e30-68462278b67a',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_5c324171-1cec-48e0-8e30-68462278b67a" class="cnblogs_code_hide">
<pre>#include&lt;stdio.h&gt;<span style="color: #000000;">
#include</span>&lt;stdlib.h&gt; 
<span style="color: #008000;">//</span><span style="color: #008000;">有头结点单链表搭建（头插法）</span>
typedef <span style="color: #0000ff;">struct</span><span style="color: #000000;"> Node{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> value;
    </span><span style="color: #0000ff;">struct</span> Node *<span style="color: #000000;">next;
}Node;

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #008000;">//</span><span style="color: #008000;">创建头结点 </span>
    Node *head = (Node*)<span style="color: #0000ff;">malloc</span>(<span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(Node));
    head</span>-&gt;value = -<span style="color: #800080;">1</span><span style="color: #000000;">;
    head</span>-&gt;next =<span style="color: #000000;"> NULL;
    Node </span>*p = head;<span style="color: #008000;">//</span><span style="color: #008000;">写法一：复制头结点 </span>
    <span style="color: #008000;">/*</span><span style="color: #008000;">写法二，再创建一个结点。但构造基本同head，故复制头结点即可 
    Node *p = (Node*)malloc(sizeof(Node)); 
    p-&gt;value = 0;
    p-&gt;next = NULL;
    </span><span style="color: #008000;">*/</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">创建10个结点 并 将第一个结点与头结点连接起来</span>
    <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;<span style="color: #800080;">10</span>;i++<span style="color: #000000;">){
        Node </span>*t = (Node*)<span style="color: #0000ff;">malloc</span>(<span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(Node));
        t</span>-&gt;value =<span style="color: #000000;"> i;
        t</span>-&gt;next = NULL;<span style="color: #008000;">//</span><span style="color: #008000;">创建10个结点 </span>
<span style="color: #000000;">        
        p</span>-&gt;next =<span style="color: #000000;"> t;
        p </span>= p-&gt;next;<span style="color: #008000;">//</span><span style="color: #008000;">将结点连接起来 </span>
    } <span style="color: #008000;">//</span><span style="color: #008000;">执行到这里到了最后一个结点p-&gt;next为NULL，注意下一步要将p返回到第一个节点 </span>
    p = head-&gt;next;<span style="color: #008000;">//</span><span style="color: #008000;">返回第一个结点，让head-&gt;next指向第一个结点 </span>
    <span style="color: #0000ff;">while</span><span style="color: #000000;">(p){
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span>,p-&gt;<span style="color: #000000;">value);
        p </span>= p-&gt;<span style="color: #000000;">next;
    }
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    p </span>=head-&gt;<span style="color: #000000;">next;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">删除value==3的结点</span>
    <span style="color: #0000ff;">while</span><span style="color: #000000;">(p){
        </span><span style="color: #0000ff;">if</span>(p-&gt;value==<span style="color: #800080;">3</span><span style="color: #000000;">){
            p </span>= p-&gt;<span style="color: #000000;">next;
            </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        }
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span>,p-&gt;<span style="color: #000000;">value);
        p </span>= p-&gt;<span style="color: #000000;">next;
    } 
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    p </span>=head-&gt;<span style="color: #000000;">next;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">在value==5的结点前增加一个value==8的结点</span>
    Node *add = (Node*)<span style="color: #0000ff;">malloc</span>(<span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(Node));
    add</span>-&gt;value = <span style="color: #800080;">8</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">while</span><span style="color: #000000;">(p){
        </span><span style="color: #0000ff;">if</span>(p-&gt;next-&gt;value == <span style="color: #800080;">5</span><span style="color: #000000;">){
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span>,p-&gt;<span style="color: #000000;">value);
            add</span>-&gt;next = p-&gt;<span style="color: #000000;">next;
            p</span>-&gt;next = add;<span style="color: #008000;">//</span><span style="color: #008000;">这两句顺序很重要 </span>
            printf(<span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span>,p-&gt;next-&gt;<span style="color: #000000;">value);
            p </span>= p-&gt;next-&gt;<span style="color: #000000;">next;
            </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        }
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span>,p-&gt;<span style="color: #000000;">value);
        p </span>= p-&gt;<span style="color: #000000;">next;
    } 

    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><strong>静态链表：</strong>（思路来源于《算法笔记》P260~268）</p>
<p>代码：PAT A1032&nbsp;Sharing</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('cc2d1178-cddc-42d5-9ae1-ddfd81113738')"><img id="code_img_closed_cc2d1178-cddc-42d5-9ae1-ddfd81113738" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_cc2d1178-cddc-42d5-9ae1-ddfd81113738" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('cc2d1178-cddc-42d5-9ae1-ddfd81113738',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_cc2d1178-cddc-42d5-9ae1-ddfd81113738" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200203
</span><span style="color: #008000;">//</span><span style="color: #008000;">静态链表 </span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;

<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> Node{
    </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> data;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> address;
    </span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> flag;
}node[</span><span style="color: #800080;">100010</span><span style="color: #000000;">];


</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> add1,add2,n;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d</span><span style="color: #800000;">"</span>,&amp;add1,&amp;add2,&amp;<span style="color: #000000;">n);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> curadd,nextadd;
        </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> letter;
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %c %d</span><span style="color: #800000;">"</span>,&amp;curadd,&amp;letter,&amp;<span style="color: #000000;">nextadd);
        node[curadd].data </span>=<span style="color: #000000;"> letter;
        node[curadd].address </span>=<span style="color: #000000;"> nextadd;
    }
    </span><span style="color: #0000ff;">int</span> cur1 =<span style="color: #000000;"> add1;
    </span><span style="color: #0000ff;">int</span> cur2 =<span style="color: #000000;"> add2;
    </span><span style="color: #0000ff;">while</span>(cur1!=-<span style="color: #800080;">1</span><span style="color: #000000;">){
        node[cur1].flag </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
        cur1 </span>=<span style="color: #000000;"> node[cur1].address;
    }
    </span><span style="color: #0000ff;">while</span>(cur2!=-<span style="color: #800080;">1</span> &amp;&amp; !<span style="color: #000000;">node[cur2].flag){
        cur2 </span>=<span style="color: #000000;"> node[cur2].address;
    }
    </span><span style="color: #0000ff;">if</span>(cur2 == -<span style="color: #800080;">1</span>)  printf(<span style="color: #800000;">"</span><span style="color: #800000;">-1</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">else</span> printf(<span style="color: #800000;">"</span><span style="color: #800000;">%05d</span><span style="color: #800000;">"</span><span style="color: #000000;">,cur2);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}
</span><span style="color: #008000;">/*</span><span style="color: #008000;">超时代码
    while(cur1!=-1){ //会超时； n*n为pow(10,10)量级 
        while(cur2!=-1 &amp;&amp; cur1!=cur2){
            cur2 = node[cur2].address;
        } 
        if(cur1 == cur2) break;
        else{
            cur2 = curtemp;
            cur1 = node[cur1].address;
        }
    }
</span><span style="color: #008000;">*/</span> </pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p><strong>应用：</strong></p>
<p>1.&nbsp;静态链表：PAT A1052 Linked List Sorting</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('23aaf506-4fb4-4a06-9b66-c9c1151c3164')"><img id="code_img_closed_23aaf506-4fb4-4a06-9b66-c9c1151c3164" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_23aaf506-4fb4-4a06-9b66-c9c1151c3164" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('23aaf506-4fb4-4a06-9b66-c9c1151c3164',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_23aaf506-4fb4-4a06-9b66-c9c1151c3164" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200203
</span><span style="color: #008000;">//</span><span style="color: #008000;">静态链表 </span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> Node{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> address;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> value;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> next;
    </span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> flag;
}node[</span><span style="color: #800080;">100010</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> countn;
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> cmp(Node a,Node b){
    </span><span style="color: #0000ff;">if</span>(a.flag==<span style="color: #800080;">0</span> || b.flag==<span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> a.flag &gt; b.flag; <span style="color: #008000;">//</span><span style="color: #008000;">无效结点放后面 </span>
    <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> a.value &lt; b.value; <span style="color: #008000;">//</span><span style="color: #008000;">有效结点排序 </span>
<span style="color: #000000;">}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,start;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d</span><span style="color: #800000;">"</span>,&amp;n,&amp;<span style="color: #000000;">start);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;<span style="color: #800080;">100010</span>;i++) node[i].flag = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> curadd,value,nextadd;
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d</span><span style="color: #800000;">"</span>,&amp;curadd,&amp;value,&amp;<span style="color: #000000;">nextadd);
        node[curadd].address </span>=<span style="color: #000000;"> curadd;
        node[curadd].value </span>=<span style="color: #000000;"> value;
        node[curadd].next </span>=<span style="color: #000000;"> nextadd;
    }
    
    </span><span style="color: #0000ff;">int</span> p =<span style="color: #000000;"> start;
    </span><span style="color: #0000ff;">while</span>(p != -<span style="color: #800080;">1</span>){ <span style="color: #008000;">//</span><span style="color: #008000;">给出的数据不一定都在一条链表当中 </span>
        countn++<span style="color: #000000;">;
        node[p].flag </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
        p </span>=<span style="color: #000000;"> node[p].next;
    }
    </span><span style="color: #0000ff;">if</span>(countn == <span style="color: #800080;">0</span>) printf(<span style="color: #800000;">"</span><span style="color: #800000;">0 -1\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
        sort(node,node</span>+<span style="color: #800080;">100010</span><span style="color: #000000;">,cmp);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %05d\n</span><span style="color: #800000;">"</span>,countn,node[<span style="color: #800080;">0</span><span style="color: #000000;">].address);
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;countn-<span style="color: #800080;">1</span>;i++<span style="color: #000000;">){
            node[i].next </span>= node[i+<span style="color: #800080;">1</span><span style="color: #000000;">].address;
        }
        node[countn</span>-<span style="color: #800080;">1</span>].next = -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;countn-<span style="color: #800080;">1</span>;i++<span style="color: #000000;">){
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%05d %d %05d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,node[i].address,node[i].value,node[i].next);
        }
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%05d %d %d\n</span><span style="color: #800000;">"</span>,node[countn-<span style="color: #800080;">1</span>].address,node[countn-<span style="color: #800080;">1</span>].value,node[countn-<span style="color: #800080;">1</span><span style="color: #000000;">].next);    
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>2.动态链表（STL）：约塞夫问题</p>
<p><img src="https://img2018.cnblogs.com/common/1726496/202002/1726496-20200203124440980-1803741367.png" alt="" /></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('83c89305-2c7f-45dd-9e2f-8fa6294c5dbf')"><img id="code_img_closed_83c89305-2c7f-45dd-9e2f-8fa6294c5dbf" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_83c89305-2c7f-45dd-9e2f-8fa6294c5dbf" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('83c89305-2c7f-45dd-9e2f-8fa6294c5dbf',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_83c89305-2c7f-45dd-9e2f-8fa6294c5dbf" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20190523</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;list&gt;<span style="color: #000000;">
#include</span>&lt;iterator&gt;<span style="color: #008000;">//</span><span style="color: #008000;">调用advance函数移动迭代器 
</span><span style="color: #008000;">//</span><span style="color: #008000;">#include&lt;algorithm&gt; </span>
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    list</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> li;
    list</span>&lt;<span style="color: #0000ff;">int</span>&gt;::iterator iter=li.begin();<span style="color: #008000;">//</span><span style="color: #008000;">由于此时list里面没有东西，因此此时begin指针没有指向&ldquo;所想的第一个元素 &rdquo; </span>
    <span style="color: #0000ff;">int</span><span style="color: #000000;"> n,k,m;
    cin</span>&gt;&gt;n&gt;&gt;k&gt;&gt;<span style="color: #000000;">m;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        li.push_back(i); 
    }
    advance(iter,k);
    </span><span style="color: #0000ff;">while</span>(li.size() !=<span style="color: #800080;">2</span><span style="color: #000000;">){
        n</span>=<span style="color: #000000;">li.size() ;
        </span><span style="color: #0000ff;">if</span>(n-k&gt;m-<span style="color: #800080;">1</span><span style="color: #000000;">){
            advance(iter,m</span>-<span style="color: #800080;">1</span><span style="color: #000000;">);
            iter</span>=li.erase(iter);<span style="color: #008000;">//</span><span style="color: #008000;">返回值是下一个元素所在地址 </span>
            k=k+m-<span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;    
        }
        </span><span style="color: #0000ff;">if</span>(n-k&lt;m-<span style="color: #800080;">1</span><span style="color: #000000;">){
            iter</span>=<span style="color: #000000;">li.begin() ;
            advance(iter,m</span>-n+k-<span style="color: #800080;">2</span><span style="color: #000000;">);
            iter</span>=<span style="color: #000000;">li.erase(iter); 
            k</span>=k+m-n-<span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        }    
        </span><span style="color: #0000ff;">if</span>(n+<span style="color: #800080;">1</span>==k+<span style="color: #000000;">m){
            li.pop_back();
            iter</span>=li.begin();<span style="color: #008000;">//</span><span style="color: #008000;">注意此时list里面已经有元素了，此时begin指针指向的就是第一个元素 </span>
            k=<span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        }
    }

    li.sort();</span><span style="color: #008000;">//</span><span style="color: #008000;">list中的函数sort，从小到大排序
    </span><span style="color: #008000;">//</span><span style="color: #008000;">li.reverse();</span><span style="color: #008000;">//</span><span style="color: #008000;">如果想从大到小排序 </span>
    <span style="color: #0000ff;">for</span>(iter=li.begin();iter!=li.end();iter++<span style="color: #000000;">){
        cout</span>&lt;&lt;*iter&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>3.栈、队列（手写）：《啊哈算法》P35&nbsp;小猫钓鱼</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('50ca306c-ac26-4ace-8481-3952ee3f3fbb')"><img id="code_img_closed_50ca306c-ac26-4ace-8481-3952ee3f3fbb" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_50ca306c-ac26-4ace-8481-3952ee3f3fbb" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('50ca306c-ac26-4ace-8481-3952ee3f3fbb',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_50ca306c-ac26-4ace-8481-3952ee3f3fbb" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20190724
</span><span style="color: #008000;">//</span><span style="color: #008000;">不同于书上结果，根据叙述题意，应拿走两张相同的牌以及夹在中间的牌 </span>
#include&lt;stdio.h&gt;<span style="color: #000000;">
typedef </span><span style="color: #0000ff;">struct</span><span style="color: #000000;">{
    </span><span style="color: #0000ff;">int</span> data[<span style="color: #800080;">1000</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> head;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> tail;
}queue; 
typedef </span><span style="color: #0000ff;">struct</span><span style="color: #000000;">{
    </span><span style="color: #0000ff;">int</span> data[<span style="color: #800080;">10</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> top;
}stack;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    queue q1,q2;</span><span style="color: #008000;">//</span><span style="color: #008000;">两个队列，分别模拟小哼和小哈手中的牌</span>
    stack s;<span style="color: #008000;">//</span><span style="color: #008000;">一个栈，模拟桌上的牌
    </span><span style="color: #008000;">//</span><span style="color: #008000;">初始化队列和栈（都没有牌）</span>
    q1.head=<span style="color: #800080;">0</span>;q1.tail=<span style="color: #800080;">0</span><span style="color: #000000;">;
    q2.head</span>=<span style="color: #800080;">0</span>;q2.tail=<span style="color: #800080;">0</span><span style="color: #000000;">;
    s.top</span>=<span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">读入小哼手中的牌 </span>
    <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;<span style="color: #800080;">6</span>;i++<span style="color: #000000;">){
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;q1.data[q1.tail++<span style="color: #000000;">]);
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">读入小哈手中的牌</span>
    <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;<span style="color: #800080;">6</span>;i++<span style="color: #000000;">){
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;q2.data[q2.tail++<span style="color: #000000;">]);
    }
    </span><span style="color: #0000ff;">while</span>(q1.head&lt;q1.tail&amp;&amp;q2.head&lt;<span style="color: #000000;">q2.tail){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">小哼先出牌</span>
        <span style="color: #0000ff;">int</span> temp=q1.data[q1.head++<span style="color: #000000;">];
        </span><span style="color: #0000ff;">int</span> flag=<span style="color: #800080;">0</span>;<span style="color: #008000;">//</span><span style="color: #008000;">标记状态 </span>
        <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;s.top;i++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(s.data[i]==<span style="color: #000000;">temp){
                flag</span>=<span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
        } 
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(flag){
            q1.data[q1.tail</span>++]=<span style="color: #000000;">temp;
            </span><span style="color: #0000ff;">while</span>(s.data[--s.top]!=<span style="color: #000000;">temp){
                q1.data[q1.tail</span>++]=<span style="color: #000000;">s.data[s.top];
            }
            q1.data[q1.tail</span>++]=<span style="color: #000000;">s.data[s.top];
        }
        </span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">flag){
            s.data[s.top</span>++]=<span style="color: #000000;">temp;
        }
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">小哈出牌</span>
        temp=q2.data[q2.head++<span style="color: #000000;">];
        flag</span>=<span style="color: #800080;">0</span>;<span style="color: #008000;">//</span><span style="color: #008000;">标记状态 </span>
        <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;s.top;i++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(s.data[i]==<span style="color: #000000;">temp){
                flag</span>=<span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
        } 
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(flag){
            q2.data[q2.tail</span>++]=<span style="color: #000000;">temp;
            </span><span style="color: #0000ff;">while</span>(s.data[--s.top]!=<span style="color: #000000;">temp){
                q2.data[q2.tail</span>++]=<span style="color: #000000;">s.data[s.top];
            }
            q2.data[q2.tail</span>++]=<span style="color: #000000;">s.data[s.top];
        }
        </span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">flag){
            s.data[s.top</span>++]=<span style="color: #000000;">temp;
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">每一步输出 </span>
        <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=q1.head;i&lt;q1.tail;i++<span style="color: #000000;">){
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span><span style="color: #000000;">,q1.data[i]);
        } printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=q2.head;i&lt;q2.tail;i++<span style="color: #000000;">){
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span><span style="color: #000000;">,q2.data[i]);
        } printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;s.top;i++<span style="color: #000000;">) {
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span><span style="color: #000000;">,s.data[i]);
        } printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">\n\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        
    }
    </span><span style="color: #0000ff;">if</span>(q2.head==<span style="color: #000000;">q2.tail){
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">小哼win\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">小哼手中的牌有：</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=q1.head;i&lt;q1.tail;i++<span style="color: #000000;">){
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span><span style="color: #000000;">,q1.data[i]);
        } 
    }
    </span><span style="color: #0000ff;">if</span>(q1.head==<span style="color: #000000;">q1.tail){
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">小哈win\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">小哈手中的牌有：</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=q2.head;i&lt;q2.tail;i++<span style="color: #000000;">){
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span><span style="color: #000000;">,q2.data[i]);
        } 
    }
    </span><span style="color: #0000ff;">if</span>(s.top==<span style="color: #800080;">0</span>) printf(<span style="color: #800000;">"</span><span style="color: #800000;">\n桌面上没有牌</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">\n桌面上的牌有：</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;s.top;i++<span style="color: #000000;">) {
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span><span style="color: #000000;">,s.data[i]);
        }
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>4.栈（手写）：《啊哈算法》P32&nbsp;判断回文</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('af49c387-a71e-4bc3-9d45-a3add8b97568')"><img id="code_img_closed_af49c387-a71e-4bc3-9d45-a3add8b97568" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_af49c387-a71e-4bc3-9d45-a3add8b97568" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('af49c387-a71e-4bc3-9d45-a3add8b97568',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_af49c387-a71e-4bc3-9d45-a3add8b97568" class="cnblogs_code_hide">
<pre>#include&lt;stdio.h&gt;<span style="color: #000000;">
#include</span>&lt;<span style="color: #0000ff;">string</span>.h&gt;

<span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">char</span> a[<span style="color: #800080;">101</span>],s[<span style="color: #800080;">101</span><span style="color: #000000;">];
    fgets(a,</span><span style="color: #800080;">100</span><span style="color: #000000;">,stdin);
    </span><span style="color: #0000ff;">int</span> len=strlen(a)-<span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">int</span> top=<span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">int</span> mid=len/<span style="color: #800080;">2</span><span style="color: #000000;">;
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">if(len%2==0){
        for(int i=0;i&lt;mid;i++){
            s[++top]=a[i];
        }
        for(int i=mid;i&lt;len;i++){//abba
            if(a[i]==s[top]) --top;
        }
        if(!top) printf("YES");
        else printf("NO",top);
    }
    if(len%2==1){
        for(int i=0;i&lt;mid;i++){
            s[++top]=a[i];
        }
        for(int i=mid+1;i&lt;len;i++){//ahaha
            if(a[i]==s[top]) --top;
        }
        if(!top) printf("YES");
        else printf("NO",top);
    }</span><span style="color: #008000;">*/</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">由于上述代码高度重复，因此可以改进，如下：</span>
    <span style="color: #0000ff;">int</span><span style="color: #000000;"> point; 
    </span><span style="color: #0000ff;">if</span>(len%<span style="color: #800080;">2</span>==<span style="color: #800080;">0</span><span style="color: #000000;">){
        point</span>=<span style="color: #000000;">mid;
    }
    </span><span style="color: #0000ff;">else</span> point = mid+<span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;mid;i++<span style="color: #000000;">){
        s[</span>++top]=<span style="color: #000000;">a[i];
    }
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=point;i&lt;len;i++){<span style="color: #008000;">//</span><span style="color: #008000;">abba</span>
        <span style="color: #0000ff;">if</span>(a[i]==s[top]) --<span style="color: #000000;">top;
    }
    </span><span style="color: #0000ff;">if</span>(!top) printf(<span style="color: #800000;">"</span><span style="color: #800000;">YES</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">else</span> printf(<span style="color: #800000;">"</span><span style="color: #800000;">NO</span><span style="color: #800000;">"</span><span style="color: #000000;">,top);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>]]></description></item><item><title>Windows10环境下远程桌面控制</title><link>http://www.cnblogs.com/icodes8238/archive/2020/02/02/12254073.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Sun, 02 Feb 2020 14:28:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/02/02/12254073.html</guid><description><![CDATA[<p align="center">Windows10环境下远程桌面控制</p>
<p><a href="https://zhuanlan.zhihu.com/p/42174353">https://zhuanlan.zhihu.com/p/42174353</a></p>
<p>（点开直接看第2点windows原生法）</p>
<p><strong>1</strong><strong>、在被连接电脑开启允许远程连接</strong></p>
<p><strong>补充：如何添加用户？（在完成第1步后）</strong></p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/i-beta/1726496/202002/1726496-20200202222607214-1318386458.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/i-beta/1726496/202002/1726496-20200202222614554-1142256497.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/i-beta/1726496/202002/1726496-20200202222621725-203925998.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/i-beta/1726496/202002/1726496-20200202222632056-309372941.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/i-beta/1726496/202002/1726496-20200202222638562-638602682.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/i-beta/1726496/202002/1726496-20200202222643054-1388902814.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>2</strong><strong>、查找被连接电脑的</strong><strong>IP</strong></p>
<p><strong>3</strong><strong>、连接电脑</strong><strong>（进行远程控制电脑上的操作）</strong></p>
<p><strong>4</strong><strong>、无法远程的情况</strong></p>
<p><strong>若出现&ldquo;由于CredSSP加密Oracle修正&rdquo;，则参考下面这篇文章解决：</strong></p>
<p><a href="https://www.cnblogs.com/lindajia/p/9021082.html">https://www.cnblogs.com/lindajia/p/9021082.html</a></p>
<p>&nbsp;</p>
<p>说明：1）第一次连接成功后，远程操作比较慢。可退出后再次连接。</p>
<p>2）被连接的电脑必须开机、网络状态良好。</p>
<p>3）其它通过软件连接的方法见<a href="https://zhuanlan.zhihu.com/p/42174353">https://zhuanlan.zhihu.com/p/42174353</a></p>
<p>优先推荐teamviewer（不用注册、非商业用途免费），其次QQ（QQ连接方法如下）</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1726496/202002/1726496-20200202222655830-1861398321.png" alt="" /></p>
<p>&nbsp;</p>]]></description></item><item><title>统一资源定位符URL</title><link>http://www.cnblogs.com/icodes8238/archive/2020/02/02/12254054.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Sun, 02 Feb 2020 14:22:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/02/02/12254054.html</guid><description><![CDATA[<p>统一资源定位符</p>
<p>&nbsp;统一资源定位符（Uniform Resource Locator，URL）是对可以从互联网上得到的资源的<strong><span style="text-decoration: underline;">位置</span></strong>和<strong><span style="text-decoration: underline;">访问方法</span></strong>的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出<strong><span style="text-decoration: underline;">文件的位置</span></strong>以及<strong><span style="text-decoration: underline;">浏览器应该怎么处理它</span></strong>。</p>
<p>只要能够对资源定位，系统就可以对资源进行各种操作，如存取、更新、替换和查找其属性。</p>
<p>URL 相当于一个文件名在网络范围的扩展。因此 URL 是与因特网相连的机器上的任何可访问对象的一个指针。</p>
<p>基本URL包含模式（或称协议）、服务器名称（或IP地址）、路径和文件名，</p>
<p>如&ldquo;协议://授权/路径?查询&rdquo;。</p>
<p>完整的、带有授权部分的普通统一资源标志符语法看上去如下：</p>
<p>协议://用户名:密码@子域名.域名.顶级域名:端口号/目录/文件名.文件后缀?参数=值#标志</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/i-beta/1726496/202002/1726496-20200202222027589-1946273258.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>模式/协议（scheme）：它告诉浏览器如何处理将要打开的文件。最常用的模式是超文本传输协议（Hypertext Transfer Protocol，缩写为HTTP），这个协议可以用来访问网络。其他协议如下：</p>
<p>http&mdash;&mdash;超文本传输协议资源</p>
<p>https&mdash;&mdash;用安全套接字层传送的超文本传输协议</p>
<p>ftp&mdash;&mdash;文件传输协议</p>
<p>mailto&mdash;&mdash;电子邮件地址</p>
<p>ldap&mdash;&mdash;轻型目录访问协议搜索</p>
<p>file&mdash;&mdash;当地电脑或网上分享的文件</p>
<p>news&mdash;&mdash;Usenet新闻组</p>
<p>gopher&mdash;&mdash;Gopher协议</p>
<p>telnet&mdash;&mdash;Telnet协议</p>
<p>&nbsp;</p>
<p>文件所在的服务器的名称或IP地址，后面是到达这个文件的路径和文件本身的名称。服务器的名称或IP地址后面有时还跟一个冒号和一个端口号。它也可以包含接触服务器必须的用户名称和密码。路径部分包含等级结构的路径定义，一般来说不同部分之间以斜线（/）分隔。询问部分一般用来传送对服务器上的数据库进行<strong><span style="text-decoration: underline;">动态询问时所需要的参数</span></strong>。</p>
<p>有时候，URL以斜杠&ldquo;/&rdquo;结尾，而没有给出文件名，在这种情况下，URL引用路径中最后一个目录中的默认文件（通常对应于主页），这个文件常常被称为 index.html 或 default.htm。</p>
<p>&nbsp;</p>
<p>绝对URL（absolute URL）显示文件的完整路径，这意味着绝对<strong><span style="text-decoration: underline;">URL</span></strong><strong><span style="text-decoration: underline;">本身所在的位置</span></strong>与<strong><span style="text-decoration: underline;">被引用的实际文件的位置无关</span></strong>，</p>
<p>相对URL（relative URL）以包含URL本身的文件夹的统一资源定位符</p>
<p>&nbsp;</p>
<p>统一资源定位符</p>
<p>位置为参考点，描述目标文件夹的位置。如果目标文件与当前页面（也就是包含URL的页面）在同一个目录，那么这个文件的相对URL仅仅是文件名和扩展名，如果目标文件在当前目录的子目录中，那么它的相对URL是子目录名，后面是斜杠，然后是目标文件的文件名和扩展名。</p>
<p>如果要引用文件层次结构中更高层目录中的文件，那么使用两个句点和一条斜杠。可以组合和重复使用两个句点和一条斜杠，从而引用当前文件所在的硬盘上的任何文件，</p>
<p>一般来说，对于同一服务器上的文件，应该总是使用相对URL，它们更容易输入，而且在将页面从本地系统转移到服务器上时更方便，只要每个文件的相对位置保持不变，链接就仍然是有效地。</p>
<p>如：</p>
<p>http://mail.163.com/index.html</p>
<p>1)http://:这个是协议，也就是HTTP超文本传输协议，也就是网页在网上传输的协议。</p>
<p>2）mail：这个是服务器名，代表着是一个邮箱服务器，所以是mail.</p>
<p>3)163.com:这个是域名，是用来定位网站的独一无二的名字。</p>
<p>4)mail.163.com：这个是网站名，由服务器名+域名组成。</p>
<p>5）/：这个是根目录，也就是说，通过网站名找到服务器，然后在服务器存放网页的根目录</p>
<p>6:）index.html：这个是根目录下的默认网页（当然，163的默认网页是不是这个我不知道，只是大部分的默认网页，都是index.html）</p>
<p>7）http://mail.163.com/index.html:这个叫做URL，统一资源定位符，全球性地址，用于定位网上的资源。</p>
<p>&nbsp;</p>]]></description></item><item><title>VC系列编译器区别</title><link>http://www.cnblogs.com/icodes8238/archive/2020/02/02/12254046.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Sun, 02 Feb 2020 14:20:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/02/02/12254046.html</guid><description><![CDATA[<p>&ldquo;VC6.0&rdquo; 完整的名字是&ldquo;Microsoft Visual C++ 6.0&rdquo;，其中的6.0是版本号，这个是1998年发布的Visual C++集成开发环境，在后来版本中，微软按照发布日期给Visual C++命名，所以后面就有了Visual C++ 2010 .... Visual C++ 2015这些版本，所有这些都是Visual C++的集成开发环境。</p>
<p>Visual C++ 2010实际上就是Visual C++ 10.0，是Visual C++6.0的后继版本。<br />
<br />
Visual Studio是一个多语言的集成开发环境，支持C#、C++、VB等多种语言的开发，Visual C++只是它的一部分。比如Visual
C++ 6.0就是Visual Studio 6.0的一部分，Visual C++ 2010就是Visual
Studio 2010的一部分。现在的Visual C++已经整合到了Visual Studio中，不提供单独的版本了，所以使用Visual
C++需要安装Visual Studio。<br />
<br />
建议使用新版的Visual Studio，不要去用VC6.0了，这个东西都快有20年的历史了，已经完全跟不上时代了。</p>]]></description></item><item><title>计组学习笔记（brunch 和 jump）</title><link>http://www.cnblogs.com/icodes8238/archive/2020/02/02/12254036.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Sun, 02 Feb 2020 14:17:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/02/02/12254036.html</guid><description><![CDATA[<p>1.&nbsp;What is the difference between <strong><span style="text-decoration: underline;">unconditional branch</span></strong> and <strong><span style="text-decoration: underline;">unconditional jump</span></strong> (instructions in MIPS)?</p>
<p>Branches allow for conditions. But allowing for conditions takes up more bits in the instruction. Therefore, a branch's address is only 2^16 bits and only allows you to branch 2^15 - 1 instructions backward or 2^15 instructions forward.</p>
<p>A jump is unconditional and the bits saved by leaving out the condition can be used for the address. A jump allows for a 26 bit address and so can jump much further in the code than a branch. At the expense of not being conditional.</p>
<p><strong><span style="text-decoration: underline;">Sum: Branches allow for conditions, while jump is not. so branches have address with a narrow range.</span></strong></p>
<p>&nbsp;</p>
<p><strong><span style="text-decoration: underline;">Branches (b) use a PC-relative displacement while jumps (j) use absolute addresses.</span></strong> The distinction is important for position-independent code. Also, only jumps can be used for indirect control transfer (jr, using a register value).</p>
<p>&nbsp;</p>
<p>now what the other answers may not have mentioned is that the unconditional branch is encoded, at least by gnu assembler, as a branch if equal, with the same register. <strong><span style="text-decoration: underline;">There is no unconditional branch in mips</span></strong>, there is branch if equal and branch if not equal from what I can tell.</p>
<p>&nbsp;</p>
<p>You see above the jump uses a 0xB which is the word address, 0xB*4 = 0x2C the address of the destination, where the conditionals use relative addressing pc+(signed_offset*4) where the <strong><span style="text-decoration: underline;">pc=instruction_address+4; Or take instruction_address + 4 + (signed_offset*4)</span></strong> to get the destination address.</p>
<p>&nbsp;</p>
<p>Using the alias b for branch instead of j for jump will create position independent code. Jump will not, have to re-link if you move around, for near jumps probably better to use branch instead of jump even though it is an alias. If you are a purist then you can use the real instruction beq $0,$0,label or pick any register beq $4,$4,label. register 0 being special and fast may be the better choice.</p>
<p>&nbsp;</p>
<p><strong><span style="text-decoration: underline;">PC-relative instructions are called &ldquo;branch&rdquo; and absolute-addressed instructions &ldquo;jump&rdquo;;</span></strong></p>
<p><strong><span style="text-decoration: underline;">&nbsp;</span></strong></p>
<p><strong><span style="text-decoration: underline;">reference:<br />
</span></strong><a href="https://blog.csdn.net/phunxm/article/details/8913871"><strong>https://blog.csdn.net/phunxm/article/details/8913871</strong></a></p>
<p><a href="http://www.itkeyword.com/doc/6448328652150605x466/what-is-the-difference-between-unconditional-branch-and-unconditional-jump-inst"><strong>http://www.itkeyword.com/doc/6448328652150605x466/what-is-the-difference-between-unconditional-branch-and-unconditional-jump-inst</strong></a></p>
<p>&nbsp;</p>]]></description></item><item><title>单位根与欧拉函数</title><link>http://www.cnblogs.com/icodes8238/archive/2020/02/02/12254001.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Sun, 02 Feb 2020 14:11:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/02/02/12254001.html</guid><description><![CDATA[<p>2019.11.29</p>
<p>由数值分析一道题引发的思考：</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1726496/202002/1726496-20200202220156486-1918741568.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>1.什么是单位根？</strong>它与欧拉函数有何关系？<a href="https://baike.sogou.com/v7873877.htm" target="_blank">https://baike.sogou.com/v7873877.htm</a></p>
<p><strong>2.结合分圆多项式理解：</strong><a href="https://baike.baidu.com/item/%E5%88%86%E5%9C%86%E5%A4%9A%E9%A1%B9%E5%BC%8F/1210903?fr=aladdin" target="_blank">https://baike.baidu.com/item/%E5%88%86%E5%9C%86%E5%A4%9A%E9%A1%B9%E5%BC%8F/1210903?fr=aladdin</a></p>
<p><img src="https://img2018.cnblogs.com/i-beta/1726496/202002/1726496-20200202220847484-971610287.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>&nbsp;3.什么是欧拉函数？</strong><a href="https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/1944850?fr=aladdin" target="_blank">https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/1944850?fr=aladdin</a></p>
<p>4.编程求欧拉函数的值（java）：<a href="https://blog.csdn.net/Liuyaoyun/article/details/90381528" target="_blank">https://blog.csdn.net/Liuyaoyun/article/details/90381528</a></p>]]></description></item><item><title>筛数法求素数+回文判断</title><link>http://www.cnblogs.com/icodes8238/archive/2020/02/02/12253353.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Sun, 02 Feb 2020 11:35:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/02/02/12253353.html</guid><description><![CDATA[<p><strong>哪些数是素数？</strong></p>
<p><strong>质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数</strong></p>
<p><strong>因此，1不是素数，最小的素数是2。</strong></p>
<p><strong>判断一个数n是否为素数，看他能否被2~sqrt(n)整除即可，因为一个合数分解成两个数的乘积，必定一个&lt;=sqrt(n)，一个大于</strong></p>
<p>&nbsp;</p>
<p><strong>筛数法求素数：</strong>（时间复杂度：O(nlglgn）</p>
<p>基本思路：一个数的n倍都不是素数&nbsp;</p>
<div class="cnblogs_code">
<pre>#include&lt;iostream&gt;

<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span> b[<span style="color: #800080;">10000000</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span> prime[<span style="color: #800080;">10000</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> count;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
    cin</span>&gt;&gt;<span style="color: #000000;">n;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">2</span>;i&lt;n;i++) b[i] = <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">2</span>;i&lt;n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(b[i] == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">2</span>*i;j&lt;n;j=j+i) b[j] = <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">一个数的n倍都不是素数 </span>
<span style="color: #000000;">    }
    </span><span style="color: #0000ff;">int</span> count = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">2</span>;i&lt;n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(b[i] == <span style="color: #800080;">1</span><span style="color: #000000;">) {
            cout</span>&lt;&lt;i&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
            prime[count</span>++] =<span style="color: #000000;"> i;
        }
    }
    cout</span>&lt;&lt;endl&lt;&lt;<span style="color: #000000;">count;
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>如何判断一个int型数是否为回文？</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">bool</span> pd(<span style="color: #0000ff;">int</span><span style="color: #000000;"> a){
    </span><span style="color: #0000ff;">bool</span> state = <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">int</span> b =<span style="color: #000000;"> a;
    </span><span style="color: #0000ff;">int</span> num = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">while</span> (a!=<span style="color: #800080;">0</span><span style="color: #000000;">){
        num </span>= num*<span style="color: #800080;">10</span> + a%<span style="color: #800080;">10</span><span style="color: #000000;">;
        a </span>/= <span style="color: #800080;">10</span><span style="color: #000000;">;
    } 
    </span><span style="color: #0000ff;">if</span> (num != b) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>应用：找指定范围内的所有回文素数</strong>（<a href="https://www.luogu.com.cn/problem/P1217" target="_blank">P1217 [USACO1.5]回文质数 Prime Palindromes</a>）</p>
<p><strong>暴力法：</strong>（一个数一个数去判断）（TLE）</p>
<p>理解：为什么判断到平方根就可以了？</p>
<p>因为如果一个数不是素数而是合数， 那么一定可以由两个自然数相乘得到， 其中一个大于或等于它的平方根，一个小于或等于它的平方根，并且成对出现</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('0c627ed2-3a2b-467b-85a7-e0f1118266ec')"><img id="code_img_closed_0c627ed2-3a2b-467b-85a7-e0f1118266ec" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_0c627ed2-3a2b-467b-85a7-e0f1118266ec" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('0c627ed2-3a2b-467b-85a7-e0f1118266ec',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_0c627ed2-3a2b-467b-85a7-e0f1118266ec" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200204</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;cmath&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">bool</span> pd_prime(<span style="color: #0000ff;">int</span><span style="color: #000000;"> a){
    </span><span style="color: #0000ff;">bool</span> state = <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">int</span> b =<span style="color: #000000;"> a;
    </span><span style="color: #0000ff;">int</span> num = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">while</span> (a!=<span style="color: #800080;">0</span><span style="color: #000000;">){
        num </span>= num*<span style="color: #800080;">10</span> + a%<span style="color: #800080;">10</span><span style="color: #000000;">;
        a </span>/= <span style="color: #800080;">10</span><span style="color: #000000;">;
    } 
    </span><span style="color: #0000ff;">if</span> (num != b) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">int</span> n = sqrt(b); <span style="color: #008000;">//</span><span style="color: #008000;">理解 </span>
    <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">2</span>;i&lt;n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(b%i==<span style="color: #800080;">0</span><span style="color: #000000;">){
            state </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        } 
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> state;
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> start,end;
    </span><span style="color: #0000ff;">int</span> count=<span style="color: #800080;">0</span><span style="color: #000000;">;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d</span><span style="color: #800000;">"</span>,&amp;start,&amp;<span style="color: #000000;">end);
    </span><span style="color: #0000ff;">if</span>(start%<span style="color: #800080;">2</span> == <span style="color: #800080;">0</span>) start += <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=start;i&lt;=end;i=i+<span style="color: #800080;">2</span><span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(pd_prime(i)){
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,i); 
        </span><span style="color: #008000;">//</span><span style="color: #008000;">    count++;</span>
<span style="color: #000000;">        }
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">cout&lt;&lt;count;</span>
    <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><strong>筛数法：</strong>（&ldquo;半&rdquo;打表）(AC)</p>
<p>为什么&ldquo;if(end&gt;9989900) end = 9989900;&rdquo;&nbsp;？这个数据是先跑出来的，由于这个题OJ系统限时比较严格，而筛数法跑一边素数表已经超过时限了。</p>
<p>筛数法时间复杂度为O(nlglgn)，几乎接近于O(n)了，因此即使继续优化到O(n)效果不明显（洛谷题解中有O(n)的算法解释）。</p>
<p>通过在本地跑一边，发现100000000以内最大的回文素数是9989989，因此想出如此&ldquo;半&rdquo;打表之策。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('02b22774-54d8-4ad3-914b-343e6f52d531')"><img id="code_img_closed_02b22774-54d8-4ad3-914b-343e6f52d531" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_02b22774-54d8-4ad3-914b-343e6f52d531" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('02b22774-54d8-4ad3-914b-343e6f52d531',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_02b22774-54d8-4ad3-914b-343e6f52d531" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200204</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;cmath&gt;<span style="color: #000000;">
#include</span>&lt;<span style="color: #0000ff;">string</span>.h&gt;
<span style="color: #0000ff;">#define</span> MAXN 100000010
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> b[MAXN];
</span><span style="color: #0000ff;">void</span> find_prime(<span style="color: #0000ff;">int</span> end){ <span style="color: #008000;">//</span><span style="color: #008000;">先建立素数表 </span>
    memset(b, <span style="color: #0000ff;">true</span>, <span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(b));
    </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> sqrt(end);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">2</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(b[i]==<span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">2</span>*i;j&lt;=end;j=j+<span style="color: #000000;">i) 
            b[j] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
}
</span><span style="color: #0000ff;">bool</span> pd(<span style="color: #0000ff;">int</span><span style="color: #000000;"> a){
    </span><span style="color: #0000ff;">bool</span> state = <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">int</span> b =<span style="color: #000000;"> a;
    </span><span style="color: #0000ff;">int</span> num = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">while</span> (a!=<span style="color: #800080;">0</span><span style="color: #000000;">){
        num </span>= num*<span style="color: #800080;">10</span> + a%<span style="color: #800080;">10</span><span style="color: #000000;">;
        a </span>/= <span style="color: #800080;">10</span><span style="color: #000000;">;
    } 
    </span><span style="color: #0000ff;">if</span> (num != b) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span> count=<span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> start,end;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d</span><span style="color: #800000;">"</span>,&amp;start,&amp;<span style="color: #000000;">end);
    </span><span style="color: #0000ff;">if</span>(end&gt;<span style="color: #800080;">9989900</span>) end = <span style="color: #800080;">9989900</span>; <span style="color: #008000;">//</span><span style="color: #008000;">见解释 </span>
<span style="color: #000000;">    find_prime(end); 
    </span><span style="color: #0000ff;">if</span>(start%<span style="color: #800080;">2</span> == <span style="color: #800080;">0</span>) start += <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=start;i&lt;=end;i=i+<span style="color: #800080;">2</span><span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(pd(i)&amp;&amp;<span style="color: #000000;">b[i]){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">count++;</span>
            printf(<span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,i); 
        }
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>]]></description></item><item><title>寻找对称日（回文）（包括闰年的判断）</title><link>http://www.cnblogs.com/icodes8238/archive/2020/02/02/12253343.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Sun, 02 Feb 2020 11:32:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/02/02/12253343.html</guid><description><![CDATA[<p><strong>需求：</strong>寻找指定时间段的对称日，对称日所在年份为闰年的需做标记指出</p>
<p><strong>关键点：</strong></p>
<p><strong>　　</strong>1.把一年内的所有合法日期以四位数输出（存到数组中）（从1.1到12.31）</p>
<p>　　2.判断是否为闰年</p>
<p><strong>思路：</strong>把所有合法日期转化成四位的字符串；</p>
<p>　　把四位的字符串对称扩展成八位，并保存到容器中；</p>
<p>　　按年份从小到大对容器排序；</p>
<p>　　把前四位转化成年份，用来判断该对称日所在年份是否为闰年</p>
<p><strong>代码实现：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">20200202
</span><span style="color: #008000;">//range : </span><span style="color: #008000;">start from 10000101 , end with 99991231 （所有能用八位数表示的日期）</span>
#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;utility&gt;<span style="color: #000000;">
#include</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">
#include</span>&lt;vector&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
pair</span>&lt;<span style="color: #0000ff;">int</span>,<span style="color: #0000ff;">int</span>&gt; p[<span style="color: #800080;">370</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">first=mouth;second=day</span>
<span style="color: #0000ff;">char</span> arr[<span style="color: #800080;">370</span>][<span style="color: #800080;">8</span><span style="color: #000000;">];
vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> s;
</span><span style="color: #0000ff;">string</span><span style="color: #000000;"> start,endw;
</span><span style="color: #0000ff;">bool</span> leap(<span style="color: #0000ff;">int</span><span style="color: #000000;"> y){ //判断闰年
    </span><span style="color: #0000ff;">if</span>( (y%<span style="color: #800080;">4</span>==<span style="color: #800080;">0</span> &amp;&amp; y%<span style="color: #800080;">100</span>!=<span style="color: #800080;">0</span>) || y%<span style="color: #800080;">400</span>==<span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    cin</span>&gt;&gt;start&gt;&gt;endw; <span style="color: #008000;">//</span><span style="color: #008000;">输入起始年份（可输入日期） </span>
    <span style="color: #0000ff;">int</span><span style="color: #000000;"> k;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=<span style="color: #800080;">12</span>;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(i==<span style="color: #800080;">1</span>||i==<span style="color: #800080;">3</span>||i==<span style="color: #800080;">5</span>||i==<span style="color: #800080;">7</span>||i==<span style="color: #800080;">8</span>||i==<span style="color: #800080;">10</span>||i==<span style="color: #800080;">12</span><span style="color: #000000;">){
            </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=<span style="color: #800080;">31</span>;j++<span style="color: #000000;">){
                p[k].first </span>=<span style="color: #000000;"> i;    
                p[k</span>++].second =<span style="color: #000000;"> j;
            }        
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(i==<span style="color: #800080;">2</span><span style="color: #000000;">){
            </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=<span style="color: #800080;">29</span>;j++<span style="color: #000000;">){
                p[k].first </span>=<span style="color: #000000;"> i;    
                p[k</span>++].second =<span style="color: #000000;"> j;
            }
        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
            </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=<span style="color: #800080;">30</span>;j++<span style="color: #000000;">){
                p[k].first </span>=<span style="color: #000000;"> i;    
                p[k</span>++].second =<span style="color: #000000;"> j;
            }
        }
    }
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;k;i++<span style="color: #000000;">){
        arr[i][</span><span style="color: #800080;">3</span>] = arr[i][<span style="color: #800080;">4</span>] = p[i].first/<span style="color: #800080;">10</span>+<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        arr[i][</span><span style="color: #800080;">2</span>] = arr[i][<span style="color: #800080;">5</span>] = p[i].first%<span style="color: #800080;">10</span>+<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        arr[i][</span><span style="color: #800080;">1</span>] = arr[i][<span style="color: #800080;">6</span>] = p[i].second/<span style="color: #800080;">10</span>+<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        arr[i][</span><span style="color: #800080;">0</span>] = arr[i][<span style="color: #800080;">7</span>] = p[i].second%<span style="color: #800080;">10</span>+<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span>(arr[i]&gt;=start &amp;&amp; arr[i]&lt;=<span style="color: #000000;">endw) {
            s.push_back(arr[i]);
        }
    }
    sort(s.begin(),s.end());
    cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">count = </span><span style="color: #800000;">"</span>&lt;&lt;s.size()&lt;&lt;<span style="color: #000000;">endl;
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;::iterator it =<span style="color: #000000;"> s.begin();
    </span><span style="color: #0000ff;">for</span>(it;it!=s.end();it++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">string</span> temp = *<span style="color: #000000;">it;
        </span><span style="color: #0000ff;">int</span> year = (temp[<span style="color: #800080;">0</span>]-<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>)*<span style="color: #800080;">1000</span> + (temp[<span style="color: #800080;">1</span>]-<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>)*<span style="color: #800080;">100</span> + (temp[<span style="color: #800080;">2</span>]-<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>)*<span style="color: #800080;">10</span> + temp[<span style="color: #800080;">3</span>]-<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span>(leap(year)) cout&lt;&lt;*it&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">leap year</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
        </span><span style="color: #0000ff;">else</span> cout&lt;&lt;*it&lt;&lt;<span style="color: #000000;">endl;
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
} 
</span><span style="color: #008000;">//</span><span style="color: #008000;">输出从2000到2099年所有对称日
</span><span style="color: #008000;">//</span><span style="color: #008000;">2000 2099 </span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Tarjan算法求有向图强联通分量及其拓展</title><link>http://www.cnblogs.com/icodes8238/archive/2020/01/31/12245089.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Fri, 31 Jan 2020 06:31:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/01/31/12245089.html</guid><description><![CDATA[<h1 style="text-align: center;"><span style="font-family: 楷体;">Tarjan算法求有向图强联通分量及其拓展</span></h1>
<h2><span style="font-family: 楷体;">Tarjan算法：用于求有向图的强联通分量</span></h2>
<p><strong>算法描述：</strong></p>
<p>（1）首先介绍一些辅助数组：</p>
<p>　　dfn[ ]：表示这个点在dfs时是第几个被搜索到，与deep配套使用</p>
<p>　　low[ ]：表示这个点及其子孙结点连的所有点中dfn最小的值，即记录一个点它最大能连通到哪个祖先节点（包括自己）</p>
<p>　　stack&lt;&gt;：表示当前所有可能能构成强连通分量的点</p>
<p>　　book[ ]：表示一个点是否在stack中</p>
<p>　　color：表示所有点着色数，即图中强连通分量的个数</p>
<p>　　col[ ]：表示这个点属于哪个强连通分量中</p>
<p>（2）任选一起始点v：</p>
<p>　　（a）初始化前四个数组（dfn[ ] = low[ ] = ++deep；入栈（book[ ]标记））</p>
<p>　　【理解】为什么low也要这么做呢？ 因为low的定义如上，也就是说如果没有子孙与u的祖先相连的话，dfn[u]一定是它和它的所有子孙中dfn最小的（因为它的所有子孙一定比他后搜到）；stack和book的作用：如果v在stack中，v之后的所有点在v被回溯到时v和栈中所有在它之后的点都构成强连通分量</p>
<p>　　（b）遍历v的每一个<span style="text-decoration: underline;"><strong>能到</strong></span>的点（也就是e[v][i]为true的点）</p>
<p>　　　　（i）如果这个点i未访问过（dfn[i]==0），那么就对点i进行dfs，然后回溯时low[v]=min{low[v],low[i]}</p>
<p>　　　　（ii）如果遍历到的这个点已经被遍历到了，那么看它当前在不在stack里。</p>
<p>　　　　　　　　如果在（说明这个点肯定能到达v，同样v能到达它，它们强联通），则low[v]=min{low[v],low[i]}&nbsp;</p>
<p>　　　　　　　　如果不在，说明无论如何这个点也不能与v构成强连通分量，因为它不能到达v ，则不进行任何操作</p>
<p>　　（c）如果v<strong>能到</strong>的点都被访问过了，那么比较dfn[v]和low[v]，如果两者相等，说明v点及v的所有子节点没有边指向v的祖先，即v点与它的子孙节点构成了一个最大的强连通图，此时我们得到了一个强连通分量。因此此时我们把所有的v点以后压入栈中的点和v点一并弹出，将它们的book[ ]置为false，并给它们染上相同颜色。</p>
<p><span style="text-decoration: underline;"><strong>注意：由于存在孤立点，所以要对所有未被访问过的点（dfn[i]==0）进行一次Tarjan</strong></span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>代码实现：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">void</span> tarjan(<span style="color: #0000ff;">int</span><span style="color: #000000;"> v){
    dfn[v] </span>= ++<span style="color: #000000;">deep;
    low[v] </span>=<span style="color: #000000;"> deep;
    book[v] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    s.push(v);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(e[v][i] == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span>(dfn[i] == <span style="color: #800080;">0</span><span style="color: #000000;">) {
            tarjan(i);
            low[v] </span>= min(low[i],low[v]); <span style="color: #008000;">//</span><span style="color: #008000;">回溯时更新low[ ]，取最小值</span>
<span style="color: #000000;">        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(dfn[i] != <span style="color: #800080;">0</span> &amp;&amp; book[i] == <span style="color: #0000ff;">true</span>){ <span style="color: #008000;">//</span><span style="color: #008000;">i is not dfs-ed &amp;&amp; is in stack</span>
            low[v] =<span style="color: #000000;"> min(low[v],low[i]);
        } 
    }
    </span><span style="color: #0000ff;">if</span>(dfn[v] ==<span style="color: #000000;"> low[v]){
        color</span>++<span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> cur;
        </span><span style="color: #0000ff;">do</span><span style="color: #000000;">{
            cur </span>=<span style="color: #000000;"> s.top();
            book[cur] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            s.pop();
            col[cur] </span>=<span style="color: #000000;"> color;
        }</span><span style="color: #0000ff;">while</span>(cur !=<span style="color: #000000;"> v);    
    }    
}</span></pre>
</div>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;">Tarjan&nbsp;缩点</span></h2>
<p><strong>方法：</strong>首先建立一个结构体存结点的颜色和同一颜色结点的个数（把同一颜色的点权加到一块）；然后把该颜色指向不同颜色的边建好。</p>
<p>比如像练习题目1（<a href="https://www.luogu.com.cn/problem/P2341" target="_blank">&nbsp;[HAOI2006]受欢迎的牛</a>），统计同一颜色结点<span style="text-decoration: underline;"><strong>对外（该强连通分图以外）</strong></span>的出度就行了。因为受欢迎的奶牛只有可能是图中唯一的出度为零的强连通分量中的所有奶牛。所以若出现两个以上出度为0的强连通分量则不存在明星奶牛，因为那几个出度为零的分量的爱慕无法传递出去。那唯一的分量能受到其他分量的爱慕同时在分量内相互传递，所以该分量中的所有奶牛都是明星。[2]</p>
<p>&nbsp;</p>
<p><strong>代码实现：</strong></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('d2f6e7d2-456d-4c4e-a0b8-80aa0f11b725')"><img id="code_img_closed_d2f6e7d2-456d-4c4e-a0b8-80aa0f11b725" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_d2f6e7d2-456d-4c4e-a0b8-80aa0f11b725" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('d2f6e7d2-456d-4c4e-a0b8-80aa0f11b725',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_d2f6e7d2-456d-4c4e-a0b8-80aa0f11b725" class="cnblogs_code_hide">
<pre>#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt; <span style="color: #008000;">//</span><span style="color: #008000;"> min</span>
#include&lt;stack&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span> dfn[<span style="color: #800080;">10010</span>],low[<span style="color: #800080;">10010</span>],deep,ans,color,col[<span style="color: #800080;">10010</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">bool</span> book[<span style="color: #800080;">10010</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">i is in stack == true</span>
stack&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
</span><span style="color: #0000ff;">bool</span> e[<span style="color: #800080;">10010</span>][<span style="color: #800080;">10010</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
typedef </span><span style="color: #0000ff;">struct</span><span style="color: #000000;">{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> weight;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> outdegree;
}Node;
Node node[</span><span style="color: #800080;">10010</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">void</span> tarjan(<span style="color: #0000ff;">int</span><span style="color: #000000;"> v){
    dfn[v] </span>= ++<span style="color: #000000;">deep;
    low[v] </span>=<span style="color: #000000;"> deep;
    book[v] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    s.push(v);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(e[v][i] == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span>(dfn[i] == <span style="color: #800080;">0</span><span style="color: #000000;">) {
            tarjan(i);
            low[v] </span>= min(low[i],low[v]); <span style="color: #008000;">//</span><span style="color: #008000;">回溯时更新low[ ]，取最小值</span>
<span style="color: #000000;">        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(dfn[i] != <span style="color: #800080;">0</span> &amp;&amp; book[i] == <span style="color: #0000ff;">true</span>){ <span style="color: #008000;">//</span><span style="color: #008000;">i is not dfs-ed &amp;&amp; is in stack</span>
            low[v] =<span style="color: #000000;"> min(low[v],low[i]);
        } 
    }
    </span><span style="color: #0000ff;">if</span>(dfn[v] ==<span style="color: #000000;"> low[v]){
        color</span>++<span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> cur;
        </span><span style="color: #0000ff;">do</span><span style="color: #000000;">{
            cur </span>=<span style="color: #000000;"> s.top();
            book[cur] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            s.pop();
            col[cur] </span>=<span style="color: #000000;"> color;
        }</span><span style="color: #0000ff;">while</span>(cur !=<span style="color: #000000;"> v);    
    }    
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> m;
    cin</span>&gt;&gt;n&gt;&gt;<span style="color: #000000;">m;

    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> a,b;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;m;i++<span style="color: #000000;">){
        cin</span>&gt;&gt;a&gt;&gt;<span style="color: #000000;">b;
        e[a][b] </span>= <span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;">directed</span>
<span style="color: #000000;">    }
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">)
        </span><span style="color: #0000ff;">if</span>(dfn[i]==<span style="color: #800080;">0</span><span style="color: #000000;">)
            tarjan(i);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=color;i++<span style="color: #000000;">)
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(col[j]==i){ <span style="color: #008000;">//</span><span style="color: #008000;">缩点 </span>
                node[i].weight++<span style="color: #000000;">;
                </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> m=<span style="color: #800080;">1</span>;m&lt;=n;m++<span style="color: #000000;">){
                    </span><span style="color: #0000ff;">if</span>(col[m]!=i &amp;&amp; e[j][m]==<span style="color: #800080;">1</span><span style="color: #000000;">) 
                        node[i].outdegree</span>++<span style="color: #000000;">;
                }
            }
        }
    </span><span style="color: #0000ff;">int</span> count = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=color;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(node[i].outdegree==<span style="color: #800080;">0</span><span style="color: #000000;">) {
            ans </span>=<span style="color: #000000;"> node[i].weight;
            count</span>++<span style="color: #000000;">;
        }
    }
    </span><span style="color: #0000ff;">if</span>(count == <span style="color: #800080;">1</span>) cout&lt;&lt;<span style="color: #000000;">ans;
    </span><span style="color: #0000ff;">else</span> cout&lt;&lt;<span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
} 
</span><span style="color: #008000;">/*</span><span style="color: #008000;">---Test------
//4
6 8
1 2
1 3
4 1
5 3
5 6
6 4
2 4
3 4
//1
6 8
1 2
1 3
4 1
3 5
5 6
4 6
2 4
3 4
</span><span style="color: #008000;">*/</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;">Tarjan&nbsp;割点</span></h2>
<p>如果这个点的dfn比low要小，说明他的子树中没有能够到达他祖先的点，他是这个双连通分量的一个割点，但要加一个特例，根节点如果有两个及以上的儿子，那么他也是割点。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;">练习题目：</span></h2>
<p><strong>Tarjan缩点：</strong>（与出度连用）<a href="https://www.luogu.com.cn/problem/P2341" target="_blank">【模板】强连通分量 / [HAOI2006]受欢迎的牛</a></p>
<p id="p2002-消息扩散-与入度连用">　　【待做】（与入度连用）<a href="https://www.luogu.com.cn/problem/P2002" target="_blank">P2002 消息扩散&nbsp;</a></p>
<p><strong>Tarjan&nbsp;无向图：</strong>【待做】<a href="https://www.luogu.com.cn/problem/P3388" target="_blank">P3388 【模板】割点（割顶）</a></p>
<p class="lfe-h1">&nbsp;</p>
<p class="lfe-h1">&nbsp;</p>
<h2 class="lfe-h1"><span style="font-family: 楷体;">Reference:</span></h2>
<p>[1]洛谷日报Tarjan算法总结：<a href="https://www.sohu.com/a/245954819_100201031" target="_blank">https://www.sohu.com/a/245954819_100201031</a></p>
<p>[2]练习题目1题解：<a href="https://www.luogu.com.cn/problemnew/solution/P2341" target="_blank">https://www.luogu.com.cn/problemnew/solution/P2341</a></p>
<p>[3]Tarjan缩点：<a href="https://www.cnblogs.com/Tony-Double-Sky/p/9285458.html" target="_blank">https://www.cnblogs.com/Tony-Double-Sky/p/9285458.html</a></p>]]></description></item><item><title>最小生成树与判断无向图是否有回路（并查集）</title><link>http://www.cnblogs.com/icodes8238/archive/2020/01/31/12244850.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Fri, 31 Jan 2020 03:19:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/01/31/12244850.html</guid><description><![CDATA[<h1 style="text-align: center;"><span style="font-family: 楷体;">最小生成树与判断无向图是否有回路（并查集）</span>&nbsp;</h1>
<h2><span style="font-family: 楷体;">一、最小生成树算法：</span></h2>
<p>（1）Kruskal算法</p>
<p>　　（a）找出权重最小的边</p>
<p>　　（b）判断加入该边以后是否会构成回路（并查集），如果不会，将该边加入生成树中</p>
<p>　　重复（a）（b），直到生成树中有n-1条边</p>
<p>（2）Prim算法（推荐）</p>
<p>　　选一个结点作为起始结点，并将其加入已选结点集合；</p>
<p>　　（a）寻找与已选结点集合任一 一个（不能是两个）结点相关联的最小边（也就是这条最小边关联的结点不能都在已选结点集合中）</p>
<p>　　（b）判断这条边加进生成树中是否会形成回路，如果不会，加入生成树中</p>
<p>　　重复（a）（b）直到生成树中有n-1条边</p>
<p><strong>代码实现：</strong>（Prim算法，可AC练习题目，可优化（参考下面算法2练习题目1的代码））20191206</p>
<div class="cnblogs_code">
<pre>#include&lt;iostream&gt;
<span style="color: #0000ff;">#define</span> inf 999999
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span> book[<span style="color: #800080;">310</span>],e[<span style="color: #800080;">301</span>][<span style="color: #800080;">310</span><span style="color: #000000;">],n,count;
</span><span style="color: #0000ff;">int</span> maxm = -<span style="color: #000000;">inf;
</span><span style="color: #0000ff;">int</span> Prim(<span style="color: #0000ff;">int</span><span style="color: #000000;"> cur){
    book[cur] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    count</span>++<span style="color: #000000;">;
    </span><span style="color: #0000ff;">int</span> minn =<span style="color: #000000;"> inf;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> index;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> node;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(book[j]==<span style="color: #800080;">1</span><span style="color: #000000;">){
            </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
                </span><span style="color: #0000ff;">if</span>(book[i]==<span style="color: #800080;">0</span> &amp;&amp; e[j][i]&lt;<span style="color: #000000;">minn) {
                    minn </span>=<span style="color: #000000;"> e[j][i];
                    node </span>=<span style="color: #000000;"> j;
                    index </span>= i;<span style="color: #008000;">//</span><span style="color: #008000;">find the smallest distance of two vertices</span>
<span style="color: #000000;">                }
            }
        }
        
    }
    </span><span style="color: #0000ff;">if</span>(e[node][index]&gt;maxm) maxm =<span style="color: #000000;"> e[node][index];
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> index;
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,m,a,b,c;
    cin</span>&gt;&gt;n&gt;&gt;<span style="color: #000000;">m;
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(i==j) e[i][j]=<span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> e[i][j]=<span style="color: #000000;">inf;
        }
    }
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">1</span>;i&lt;=m;i++<span style="color: #000000;">){
        cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;<span style="color: #000000;">c;
        e[a][b]</span>=<span style="color: #000000;">c;
        e[b][a]</span>=c;<span style="color: #008000;">//i</span><span style="color: #008000;">ndirected graph</span>
<span style="color: #000000;">    }
    </span><span style="color: #0000ff;">int</span> next = Prim(<span style="color: #800080;">1</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">while</span>(count!=n-<span style="color: #800080;">1</span>){ <span style="color: #008000;">//</span><span style="color: #008000;">count used to judge if all vertices are in the tree</span>
        next =<span style="color: #000000;"> Prim(next);
    }
    cout</span>&lt;&lt;count&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span>&lt;&lt;maxm&lt;&lt;<span style="color: #000000;">endl;
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;">二、用Kruskal判断无向图是否有回路的方法总结：</span></h2>
<h2><span style="font-family: 楷体;">算法1：并查集（推荐）</span></h2>
<p><strong>并查集（与路径压缩）算法描述</strong>：《算法笔记》P328-332</p>
<p>&nbsp;</p>
<p><strong>代码实现：</strong>（可优化（参考下面算法2练习题目1的代码））20200130</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('87ee6c32-048c-49d1-a250-936e031427eb')"><img id="code_img_closed_87ee6c32-048c-49d1-a250-936e031427eb" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_87ee6c32-048c-49d1-a250-936e031427eb" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('87ee6c32-048c-49d1-a250-936e031427eb',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_87ee6c32-048c-49d1-a250-936e031427eb" class="cnblogs_code_hide">
<pre>#include&lt;iostream&gt;
<span style="color: #0000ff;">#define</span> inf 9999999 
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,edge,maxm;
</span><span style="color: #0000ff;">int</span> e[<span style="color: #800080;">310</span>][<span style="color: #800080;">310</span>],father[<span style="color: #800080;">310</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span> findfather(<span style="color: #0000ff;">int</span><span style="color: #000000;"> node){
    </span><span style="color: #0000ff;">int</span> vertex =<span style="color: #000000;"> node;
    </span><span style="color: #0000ff;">while</span>(node !=<span style="color: #000000;"> father[node])
        node </span>=<span style="color: #000000;"> father[node];
    </span><span style="color: #0000ff;">while</span>(vertex != father[vertex]){<span style="color: #008000;">//</span><span style="color: #008000;"> path compression</span>
        <span style="color: #0000ff;">int</span> temp =<span style="color: #000000;"> vertex;
        vertex </span>=<span style="color: #000000;"> father[vertex];
        father[temp] </span>=<span style="color: #000000;"> node;
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> node;
}
</span><span style="color: #0000ff;">void</span> unionsets(<span style="color: #0000ff;">int</span> node1,<span style="color: #0000ff;">int</span><span style="color: #000000;"> node2){
    </span><span style="color: #0000ff;">int</span> fa1 =<span style="color: #000000;"> findfather(node1);
    </span><span style="color: #0000ff;">int</span> fa2 =<span style="color: #000000;"> findfather(node2);
    father[fa2] </span>=<span style="color: #000000;"> fa1;
}
</span><span style="color: #0000ff;">bool</span> cycle(<span style="color: #0000ff;">int</span> nodea,<span style="color: #0000ff;">int</span><span style="color: #000000;"> nodeb){
    </span><span style="color: #0000ff;">if</span>(findfather(nodea) == findfather(nodeb)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
        unionsets(nodea,nodeb);
        edge</span>++;<span style="color: #008000;">//</span><span style="color: #008000;"> end condition</span>
        <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
}
</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> Kruskal(){
    </span><span style="color: #0000ff;">int</span> minn =<span style="color: #000000;"> inf;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> nodea,nodeb;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=i+<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(e[i][j] &lt;<span style="color: #000000;"> minn) {
                minn </span>=<span style="color: #000000;"> e[i][j];
                nodea </span>=<span style="color: #000000;"> i;
                nodeb </span>=<span style="color: #000000;"> j;
            }
        }
    }
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(cycle(nodea,nodeb)){
        maxm </span>=<span style="color: #000000;"> e[nodea][nodeb];
    }
    e[nodea][nodeb] </span>=<span style="color: #000000;"> inf;
    e[nodeb][nodea] </span>= inf;<span style="color: #008000;">//</span><span style="color: #008000;">ignore the edge checked</span>
<span style="color: #000000;">}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> m;
    cin</span>&gt;&gt;n&gt;&gt;<span style="color: #000000;">m; 
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        father[i] </span>= i; <span style="color: #008000;">//</span><span style="color: #008000;">initialize</span>
        <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            e[i][j]</span>=<span style="color: #000000;">inf;
        }
    }
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> a,b,c;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=m;i++<span style="color: #000000;">){
        cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;<span style="color: #000000;">c;
        e[a][b]</span>=<span style="color: #000000;">c;
        e[b][a]</span>=c;<span style="color: #008000;">//</span><span style="color: #008000;">indirected </span>
<span style="color: #000000;">    }
    </span><span style="color: #0000ff;">while</span>(edge&lt;n-<span style="color: #800080;">1</span><span style="color: #000000;">) Kruskal();
    cout</span>&lt;&lt;edge&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span>&lt;&lt;maxm&lt;&lt;<span style="color: #000000;">endl;
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p><strong>测试数据：</strong>见练习题目第1个</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;">算法2：基于dfs判断（同有向图）</span></h2>
<p><strong>算法描述：</strong><a title="拓扑排序与判断有向图是否有环" href="https://www.cnblogs.com/icodes8238/p/12244762.html" target="_blank">拓扑排序与判断有向图是否有环</a></p>
<p>区别于有向图的是：用dfs判断无向图是否有回路要注意防止结点&ldquo;杀回马枪&rdquo;，也就是说要防止结点访问它的父亲结点；比如说1dfs到2，要防止2dfs时去访问1.</p>
<p>解决办法就是记录每一个结点的父亲结点。</p>
<p>&nbsp;</p>
<p><strong>代码实现：</strong></p>
<p>练习题目2：20200129</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('c4a850f3-f45e-496b-8eac-3cce946818e3')"><img id="code_img_closed_c4a850f3-f45e-496b-8eac-3cce946818e3" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_c4a850f3-f45e-496b-8eac-3cce946818e3" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('c4a850f3-f45e-496b-8eac-3cce946818e3',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_c4a850f3-f45e-496b-8eac-3cce946818e3" class="cnblogs_code_hide">
<pre>#include&lt;iostream&gt;
<span style="color: #0000ff;">#define</span> inf 99999999
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span> book[<span style="color: #800080;">110</span>],e[<span style="color: #800080;">110</span>][<span style="color: #800080;">110</span>],n,sum,father[<span style="color: #800080;">110</span>],arr[<span style="color: #800080;">110</span>][<span style="color: #800080;">110</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span> <span style="color: #0000ff;">base</span> =<span style="color: #000000;"> inf;

</span><span style="color: #0000ff;">bool</span> dfs (<span style="color: #0000ff;">int</span><span style="color: #000000;"> cur){
    book[cur] </span>= -<span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(e[cur][i]!=<span style="color: #800080;">0</span>&amp;&amp;e[cur][i]!=inf&amp;&amp;father[cur]!=i&amp;&amp;book[i]==-<span style="color: #800080;">1</span><span style="color: #000000;">) 
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span>(e[cur][i]!=<span style="color: #800080;">0</span>&amp;&amp;e[cur][i]!=inf&amp;&amp;book[i]==<span style="color: #800080;">0</span><span style="color: #000000;">){
            father[i] </span>=<span style="color: #000000;"> cur;
            </span><span style="color: #0000ff;">if</span>(!dfs(i)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;    
        } 
    }
    book[cur] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
}
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> Kruskal(){
    </span><span style="color: #0000ff;">int</span> minn =<span style="color: #000000;"> inf;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> nodea,nodeb;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=i+<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(arr[i][j]&lt;<span style="color: #000000;">minn) {
                minn </span>=<span style="color: #000000;"> arr[i][j];
                nodea </span>=<span style="color: #000000;"> i;
                nodeb </span>=<span style="color: #000000;"> j;
            }
        }
    }
    </span><span style="color: #0000ff;">if</span>(minn!=<span style="color: #000000;">inf){
        e[nodea][nodeb] </span>=<span style="color: #000000;"> minn;
        e[nodeb][nodea] </span>=<span style="color: #000000;"> minn;
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;<span style="color: #800080;">110</span>;i++) book[i] = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">bool</span> state=<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">base</span> =<span style="color: #000000;"> inf;
            </span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">dfs(i)){
                state </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
        } 
        </span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">state){
            e[nodea][nodeb] </span>=<span style="color: #000000;"> inf;
            e[nodeb][nodea] </span>=<span style="color: #000000;"> inf;
        } 
        </span><span style="color: #0000ff;">else</span> sum +=<span style="color: #000000;"> minn;    
        arr[nodea][nodeb] </span>=<span style="color: #000000;"> inf;
        
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    cin</span>&gt;&gt;<span style="color: #000000;">n;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> temp;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            cin</span>&gt;&gt;<span style="color: #000000;">temp;
            </span><span style="color: #0000ff;">if</span>(i==j) temp =<span style="color: #000000;"> inf;
            arr[i][j] </span>=<span style="color: #000000;"> temp;
            e[i][j] </span>=<span style="color: #000000;"> inf;
        }
    }
    </span><span style="color: #0000ff;">while</span><span style="color: #000000;">(Kruskal()) ;
    cout</span>&lt;&lt;sum&lt;&lt;<span style="color: #000000;">endl;
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p>练习题目1：20200131（相对于练习题目2的代码有很大优化）</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('d7b17e2c-f7d0-4e7e-8a62-4316187d509f')"><img id="code_img_closed_d7b17e2c-f7d0-4e7e-8a62-4316187d509f" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_d7b17e2c-f7d0-4e7e-8a62-4316187d509f" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('d7b17e2c-f7d0-4e7e-8a62-4316187d509f',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_d7b17e2c-f7d0-4e7e-8a62-4316187d509f" class="cnblogs_code_hide">
<pre>#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt;
<span style="color: #0000ff;">#define</span> inf 999999
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,counte,maxm;
</span><span style="color: #0000ff;">int</span> book[<span style="color: #800080;">310</span>],father[<span style="color: #800080;">310</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">bool</span> e[<span style="color: #800080;">310</span>][<span style="color: #800080;">310</span><span style="color: #000000;">];
typedef </span><span style="color: #0000ff;">struct</span><span style="color: #000000;">{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> nodea;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> nodeb;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> weight;
}Edge; 
Edge edge[</span><span style="color: #800080;">100010</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> cmp(Edge e1,Edge e2){
    </span><span style="color: #0000ff;">return</span> e1.weight &lt;<span style="color: #000000;"> e2.weight;
}
</span><span style="color: #0000ff;">bool</span> dfs (<span style="color: #0000ff;">int</span><span style="color: #000000;"> cur){
    book[cur] </span>= -<span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(e[cur][i]==<span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span>(e[cur][i]==<span style="color: #800080;">1</span> &amp;&amp; father[cur]!=i &amp;&amp; book[i]==-<span style="color: #800080;">1</span><span style="color: #000000;">) 
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span>(e[cur][i]==<span style="color: #800080;">1</span> &amp;&amp; book[i]==<span style="color: #800080;">0</span><span style="color: #000000;">){
            father[i] </span>=<span style="color: #000000;"> cur;
            </span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">dfs(i)) 
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>; <span style="color: #008000;">//</span><span style="color: #008000;">注意不能单纯地dfs,一定要判断并return false;不判断的话就会执行到最后一行并return true        </span>
<span style="color: #000000;">        } 
    }
    book[cur] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
}
</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> Kruskal(Edge ed){
    e[ed.nodea][ed.nodeb] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    e[ed.nodeb][ed.nodea] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;<span style="color: #800080;">310</span>;i++) book[i] = <span style="color: #800080;">0</span>;<span style="color: #008000;">//</span><span style="color: #008000;">每放入一条边，都要重新判断是否构成环 </span>
    <span style="color: #0000ff;">bool</span> state=<span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(book[i] != <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">dfs(i)){
            state </span>= <span style="color: #800080;">0</span>;<span style="color: #008000;">//</span><span style="color: #008000;">有回路 </span>
            <span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
    } 
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(state){
        counte</span>++<span style="color: #000000;">;
        maxm </span>=<span style="color: #000000;"> ed.weight;
    }
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
        e[ed.nodea][ed.nodeb] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        e[ed.nodeb][ed.nodea] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> m,a,b,c;
    cin</span>&gt;&gt;n&gt;&gt;<span style="color: #000000;">m;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=m;i++<span style="color: #000000;">){
        cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;<span style="color: #000000;">c;
        edge[i].nodea </span>=<span style="color: #000000;"> a;
        edge[i].nodeb </span>=<span style="color: #000000;"> b;
        edge[i].weight </span>=<span style="color: #000000;"> c;
    }
    sort(edge,edge</span>+<span style="color: #000000;">m,cmp);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=m;i++<span style="color: #000000;">) {
        Kruskal(edge[i]);
        </span><span style="color: #0000ff;">if</span>(counte == n-<span style="color: #800080;">1</span>) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
    }
    cout</span>&lt;&lt;counte&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span>&lt;&lt;maxm&lt;&lt;<span style="color: #000000;">endl;
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;">算法3：如果&nbsp;边数 + 连通分支数 - 1 &gt;= 结点数，则图中有回路</span></h2>
<p><strong>代码实现：</strong>（没有考虑有多个连通分支的情况，第二组测试数据通不过）20191206</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('fc97bad0-fae9-48a0-a59f-414ab106bfd3')"><img id="code_img_closed_fc97bad0-fae9-48a0-a59f-414ab106bfd3" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_fc97bad0-fae9-48a0-a59f-414ab106bfd3" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('fc97bad0-fae9-48a0-a59f-414ab106bfd3',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_fc97bad0-fae9-48a0-a59f-414ab106bfd3" class="cnblogs_code_hide">
<pre>#include&lt;iostream&gt;
<span style="color: #0000ff;">#define</span> inf 999999
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span> book[<span style="color: #800080;">101</span>],e[<span style="color: #800080;">101</span>][<span style="color: #800080;">101</span>],n,data[<span style="color: #800080;">101</span><span style="color: #000000;">],sum,count,edge;

</span><span style="color: #0000ff;">bool</span> is_cycle(<span style="color: #0000ff;">int</span> nodea,<span style="color: #0000ff;">int</span><span style="color: #000000;"> nodeb){
</span><span style="color: #008000;">//</span><span style="color: #008000;">if edge&gt;=the number of vertices, then there is a cycle</span>
    <span style="color: #0000ff;">int</span> statea=<span style="color: #800080;">0</span>;<span style="color: #008000;">//</span><span style="color: #008000;">to record if nodea is booked before adding the edge</span>
    <span style="color: #0000ff;">int</span> stateb=<span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span>(book[nodea]==<span style="color: #800080;">0</span><span style="color: #000000;">){
        book[nodea] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
        count</span>++<span style="color: #000000;">;
        statea</span>++<span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">if</span>(book[nodeb]==<span style="color: #800080;">0</span><span style="color: #000000;">){
        book[nodeb] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
        count</span>++<span style="color: #000000;">;
        stateb</span>++<span style="color: #000000;">;
    }
    edge</span>++;<span style="color: #008000;">//</span><span style="color: #008000;">sequence(after count++)
    </span><span style="color: #008000;">//</span><span style="color: #008000;">after add the edge, if it leads to a cycle, then recover it</span>
    <span style="color: #0000ff;">if</span>(edge&gt;=<span style="color: #000000;">count){
        edge</span>--<span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(statea){
            count</span>--<span style="color: #000000;">;
            book[nodea]</span>=<span style="color: #800080;">0</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(stateb){
            count</span>--<span style="color: #000000;">;
            book[nodeb]</span>=<span style="color: #800080;">0</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    } 
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
}
</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> Kruskal(){
    </span><span style="color: #0000ff;">int</span> minn =<span style="color: #000000;"> inf;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> nodea,nodeb;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=i+<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(e[i][j]&lt;<span style="color: #000000;">minn) {
                minn </span>=<span style="color: #000000;"> e[i][j];
                nodea </span>=<span style="color: #000000;"> i;
                nodeb </span>= j;<span style="color: #008000;">//</span><span style="color: #008000;">find the two vertices of the min edge</span>
<span style="color: #000000;">            }
        }
    }
    </span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">is_cycle(nodea,nodeb)){
        cout</span>&lt;&lt;nodea&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span>&lt;&lt;nodeb&lt;&lt;<span style="color: #000000;">endl;
        book[nodea] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
        book[nodeb] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
        sum </span>+=<span style="color: #000000;"> e[nodea][nodeb];
    }
    e[nodea][nodeb] </span>=<span style="color: #000000;"> inf;
    e[nodeb][nodea] </span>= inf;<span style="color: #008000;">//</span><span style="color: #008000;">ignore the edge checked</span>
<span style="color: #000000;">}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,m,a,b,c;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d</span><span style="color: #800000;">"</span>,&amp;n,&amp;<span style="color: #000000;">m);
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(i==j) e[i][j]=<span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> e[i][j]=<span style="color: #000000;">inf;
        }
    }
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">1</span>;i&lt;=m;i++<span style="color: #000000;">){
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d %d</span><span style="color: #800000;">"</span>,&amp;a,&amp;b,&amp;<span style="color: #000000;">c);
        e[a][b]</span>=<span style="color: #000000;">c;
        e[b][a]</span>=<span style="color: #000000;">c;
    }
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;m;i++<span style="color: #000000;">) Kruskal();
    cout</span>&lt;&lt;sum&lt;&lt;<span style="color: #000000;">endl;
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p><strong>测试数据：</strong></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('a4dd84b5-1548-41bb-8e18-b0f21b378f88')"><img id="code_img_closed_a4dd84b5-1548-41bb-8e18-b0f21b378f88" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_a4dd84b5-1548-41bb-8e18-b0f21b378f88" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('a4dd84b5-1548-41bb-8e18-b0f21b378f88',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_a4dd84b5-1548-41bb-8e18-b0f21b378f88" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">左图（AC）</span>
<span style="color: #800080;">6</span> <span style="color: #800080;">9</span>
<span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">10</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">4</span> <span style="color: #800080;">5</span>
<span style="color: #800080;">1</span> <span style="color: #800080;">6</span> <span style="color: #800080;">2</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">3</span> <span style="color: #800080;">3</span>
<span style="color: #800080;">4</span> <span style="color: #800080;">5</span> <span style="color: #800080;">11</span>
<span style="color: #800080;">6</span> <span style="color: #800080;">5</span> <span style="color: #800080;">3</span>
<span style="color: #800080;">3</span> <span style="color: #800080;">5</span> <span style="color: #800080;">15</span>
<span style="color: #800080;">4</span> <span style="color: #800080;">6</span> <span style="color: #800080;">10</span>
<span style="color: #800080;">1</span> <span style="color: #800080;">4</span> <span style="color: #800080;">20</span>
<span style="color: #008000;">//</span><span style="color: #008000;">右图（WA）</span>
<span style="color: #800080;">8</span> <span style="color: #800080;">8</span>
<span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">3</span> <span style="color: #800080;">2</span>
<span style="color: #800080;">3</span> <span style="color: #800080;">4</span> <span style="color: #800080;">3</span>
<span style="color: #800080;">5</span> <span style="color: #800080;">6</span> <span style="color: #800080;">4</span>
<span style="color: #800080;">6</span> <span style="color: #800080;">7</span> <span style="color: #800080;">5</span>
<span style="color: #800080;">7</span> <span style="color: #800080;">8</span> <span style="color: #800080;">6</span>
<span style="color: #800080;">1</span> <span style="color: #800080;">4</span> <span style="color: #800080;">7</span>
<span style="color: #800080;">1</span> <span style="color: #800080;">5</span> <span style="color: #800080;">8</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><img src="https://img2018.cnblogs.com/common/1726496/202001/1726496-20200131111234158-133328339.png" alt="" width="270" height="166" /><img src="https://img2018.cnblogs.com/common/1726496/202001/1726496-20200131121432472-428611338.jpg" alt="" width="171" height="184" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;"><strong>练习题目：</strong></span></h2>
<p><a class="colored" href="https://www.luogu.com.cn/problem/P2330" target="_blank">P2330&nbsp;[SCOI2005]繁忙的都市</a></p>
<p><a class="colored" href="https://www.luogu.com.cn/problem/P1546" target="_blank">P1546&nbsp;最短网络 Agri-Net</a></p>]]></description></item><item><title>拓扑排序与判断有向图是否有回路</title><link>http://www.cnblogs.com/icodes8238/archive/2020/01/31/12244762.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Fri, 31 Jan 2020 02:44:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/01/31/12244762.html</guid><description><![CDATA[<h1 style="text-align: center;"><span style="font-family: 楷体;">拓扑排序与判断有向图是否有环</span></h1>
<h2><span style="font-family: 楷体;">一、基于dfs的拓扑排序</span></h2>
<p><strong>代码实现：</strong>（20191205）</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('8a55746b-af8e-47de-ac1b-e5d084e7a494')"><img id="code_img_closed_8a55746b-af8e-47de-ac1b-e5d084e7a494" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_8a55746b-af8e-47de-ac1b-e5d084e7a494" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('8a55746b-af8e-47de-ac1b-e5d084e7a494',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_8a55746b-af8e-47de-ac1b-e5d084e7a494" class="cnblogs_code_hide">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">
状态0是还没有被访问
状态 1是此次dfs结束，也就是说是最小元，后面没有结点了，才能被标记为1，然后入栈 
</span><span style="color: #008000;">*/</span><span style="color: #000000;"> 
#include</span>&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;stack&gt;
<span style="color: #0000ff;">#define</span> inf 9999999
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span> book[<span style="color: #800080;">101</span>],sum,n,e[<span style="color: #800080;">101</span>][<span style="color: #800080;">101</span><span style="color: #000000;">];
stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
</span><span style="color: #0000ff;">void</span> dfs (<span style="color: #0000ff;">int</span><span style="color: #000000;"> cur){
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">)
        </span><span style="color: #0000ff;">if</span>(e[cur][i]==<span style="color: #800080;">1</span>&amp;&amp;book[i]==<span style="color: #800080;">0</span><span style="color: #000000;">) 
            dfs(i);
    book[cur] </span>= <span style="color: #800080;">1</span>;<span style="color: #008000;">//</span><span style="color: #008000;">与DFS的区别在于 标记当前节点的时间 （在递归结束才加入）</span>
<span style="color: #000000;">    s.push(cur);
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,m,a,b;
    cin</span>&gt;&gt;n&gt;&gt;<span style="color: #000000;">m;
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(i==j) e[i][j]=<span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> e[i][j]=<span style="color: #000000;">inf;
        }
    }
    
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">1</span>;i&lt;=m;i++<span style="color: #000000;">){
        cin</span>&gt;&gt;a&gt;&gt;<span style="color: #000000;">b;
        e[a][b]</span>=<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
    dfs(</span><span style="color: #800080;">2</span><span style="color: #000000;">);

    </span><span style="color: #0000ff;">while</span>(!<span style="color: #000000;">s.empty()){
        cout</span>&lt;&lt;s.top()&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
        s.pop();
    }

    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p><strong>测试数据：</strong></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('1364a1ff-5a43-4782-b0ca-a027a883a874')"><img id="code_img_closed_1364a1ff-5a43-4782-b0ca-a027a883a874" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_1364a1ff-5a43-4782-b0ca-a027a883a874" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('1364a1ff-5a43-4782-b0ca-a027a883a874',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_1364a1ff-5a43-4782-b0ca-a027a883a874" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">左图</span>
<span style="color: #800080;">9</span> <span style="color: #800080;">9</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">4</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">5</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">1</span>
<span style="color: #800080;">1</span> <span style="color: #800080;">3</span>
<span style="color: #800080;">3</span> <span style="color: #800080;">6</span>
<span style="color: #800080;">3</span> <span style="color: #800080;">8</span>
<span style="color: #800080;">5</span> <span style="color: #800080;">8</span>
<span style="color: #800080;">5</span> <span style="color: #800080;">7</span>
<span style="color: #800080;">8</span> <span style="color: #800080;">9</span>
<span style="color: #008000;">//</span><span style="color: #008000;">右图</span>
<span style="color: #800080;">7</span> <span style="color: #800080;">8</span>
<span style="color: #800080;">1</span> <span style="color: #800080;">2</span>
<span style="color: #800080;">1</span> <span style="color: #800080;">3</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">4</span>
<span style="color: #800080;">3</span> <span style="color: #800080;">4</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">6</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">5</span>
<span style="color: #800080;">4</span> <span style="color: #800080;">5</span>
<span style="color: #800080;">5</span> <span style="color: #800080;">7</span> </pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><img src="https://img2018.cnblogs.com/common/1726496/202001/1726496-20200131103654647-1338324377.jpg" alt="" width="208" height="295" />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="https://img2018.cnblogs.com/common/1726496/202001/1726496-20200131103453183-1194302000.jpg" alt="" width="201" height="297" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;">二、判断有向图是否有环（基于dfs拓扑排序）</span></h2>
<p><strong>算法描述：</strong>每个结点有三个状态：状态0是还没有被访问；状态-1是在这次dfs过程中被标记；</p>
<p>状态 1是此次dfs结束，也就是说是最小元（后面没有结点了）才能被标记为1；</p>
<p>如果 与 在此次dfs过程中已访问过的结点（状态为-1）有边相连，说明有环（回路）；</p>
<p>如果 与 在此次dfs过程中未访问的结点（状态为0）有边相连，则继续dfs；</p>
<p>此次dfs结束后（到最小元的结点），将最小元的状态标记为1，并且return true（因为此次dfs过程中未出现环）</p>
<p>&nbsp;</p>
<p><strong>代码实现：</strong>（20200129）</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('509f3c68-4074-46c1-8748-1cef12794395')"><img id="code_img_closed_509f3c68-4074-46c1-8748-1cef12794395" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_509f3c68-4074-46c1-8748-1cef12794395" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('509f3c68-4074-46c1-8748-1cef12794395',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_509f3c68-4074-46c1-8748-1cef12794395" class="cnblogs_code_hide">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">
状态0是还没有被访问
状态-1是在这次dfs过程中被标记 
状态 1是此次dfs结束，也就是说是最小元，后面没有结点了，才能被标记为1 
</span><span style="color: #008000;">*/</span><span style="color: #000000;"> 
#include</span>&lt;iostream&gt;
<span style="color: #0000ff;">#define</span> inf 999999
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span> book[<span style="color: #800080;">110</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span> e[<span style="color: #800080;">110</span>][<span style="color: #800080;">110</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
</span><span style="color: #0000ff;">bool</span> dfs (<span style="color: #0000ff;">int</span><span style="color: #000000;"> cur){
    book[cur] </span>= -<span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(e[cur][i]!=<span style="color: #800080;">0</span>&amp;&amp;e[cur][i]!=inf&amp;&amp;book[i]==-<span style="color: #800080;">1</span><span style="color: #000000;">) 
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            </span><span style="color: #008000;">//</span><span style="color: #008000;">如果 与 在此次dfs过程中已访问过的结点（状态为-1）有边相连，说明有环 </span>
        <span style="color: #0000ff;">if</span>(e[cur][i]!=<span style="color: #800080;">0</span>&amp;&amp;e[cur][i]!=inf&amp;&amp;book[i]==<span style="color: #800080;">0</span>&amp;&amp;!<span style="color: #000000;">dfs(i)) 
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果 与 在此次dfs过程中未访问的结点（状态为0）有边相连，则继续dfs </span>
<span style="color: #000000;">    }
    book[cur] </span>= <span style="color: #800080;">1</span>;<span style="color: #008000;">//</span><span style="color: #008000;">与DFS的区别在于 标记当前节点的时间 （在递归结束才加入） </span>
    <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    cin</span>&gt;&gt;<span style="color: #000000;">n;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(i==j) e[i][j] = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> e[i][j] =<span style="color: #000000;"> inf;
        }
    }
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> m;
    cin</span>&gt;&gt;<span style="color: #000000;">m;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> a,b,c;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;m;i++<span style="color: #000000;">){
        cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;<span style="color: #000000;">c;
        e[a][b] </span>= c; <span style="color: #008000;">//</span><span style="color: #008000;"> directed</span>
<span style="color: #000000;">    }
    </span><span style="color: #0000ff;">bool</span> state = dfs(<span style="color: #800080;">1</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">if</span>(state) cout&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">none</span><span style="color: #800000;">"</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">else</span> cout&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">exist</span><span style="color: #800000;">"</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p><strong>测试数据：</strong></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('f4fe7f7f-7e5b-4470-b383-750254af5ed4')"><img id="code_img_closed_f4fe7f7f-7e5b-4470-b383-750254af5ed4" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_f4fe7f7f-7e5b-4470-b383-750254af5ed4" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('f4fe7f7f-7e5b-4470-b383-750254af5ed4',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_f4fe7f7f-7e5b-4470-b383-750254af5ed4" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">none左图</span>
<span style="color: #800080;">7</span> <span style="color: #800080;">7</span>
<span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span>
<span style="color: #800080;">1</span> <span style="color: #800080;">3</span> <span style="color: #800080;">1</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">7</span> <span style="color: #800080;">1</span>
<span style="color: #800080;">3</span> <span style="color: #800080;">4</span> <span style="color: #800080;">3</span>
<span style="color: #800080;">4</span> <span style="color: #800080;">5</span> <span style="color: #800080;">3</span>
<span style="color: #800080;">5</span> <span style="color: #800080;">7</span> <span style="color: #800080;">6</span>
<span style="color: #800080;">6</span> <span style="color: #800080;">7</span> <span style="color: #800080;">2</span>
<span style="color: #008000;">//</span><span style="color: #008000;">exist右图</span>
<span style="color: #800080;">7</span> <span style="color: #800080;">7</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span>
<span style="color: #800080;">1</span> <span style="color: #800080;">3</span> <span style="color: #800080;">1</span>
<span style="color: #800080;">7</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span>
<span style="color: #800080;">3</span> <span style="color: #800080;">4</span> <span style="color: #800080;">3</span>
<span style="color: #800080;">4</span> <span style="color: #800080;">5</span> <span style="color: #800080;">3</span>
<span style="color: #800080;">5</span> <span style="color: #800080;">7</span> <span style="color: #800080;">6</span>
<span style="color: #800080;">6</span> <span style="color: #800080;">7</span> <span style="color: #800080;">2</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h2><img src="https://img2018.cnblogs.com/common/1726496/202001/1726496-20200131103941280-1365742714.jpg" alt="" width="217" height="234" />&nbsp; &nbsp;<img src="https://img2018.cnblogs.com/common/1726496/202001/1726496-20200131104121690-332482552.jpg" alt="" width="219" height="228" /></h2>
<h2>&nbsp;</h2>
<h2>&nbsp;</h2>
<h2><span style="font-family: 楷体;">三、基于dfs的拓扑排序（可处理有回路的情况）</span></h2>
<p><strong>代码实现：</strong>（20191205）</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('b6aaf327-6d4e-4d8d-aa1f-6c8b9e88b222')"><img id="code_img_closed_b6aaf327-6d4e-4d8d-aa1f-6c8b9e88b222" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_b6aaf327-6d4e-4d8d-aa1f-6c8b9e88b222" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('b6aaf327-6d4e-4d8d-aa1f-6c8b9e88b222',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_b6aaf327-6d4e-4d8d-aa1f-6c8b9e88b222" class="cnblogs_code_hide">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">
状态0是还没有被访问
状态-1是在这次dfs过程中被标记 
状态 1是此次dfs结束，也就是说是最小元，后面没有结点了，才能被标记为1，然后入栈 
</span><span style="color: #008000;">*/</span><span style="color: #000000;"> 
#include</span>&lt;stdio.h&gt;<span style="color: #000000;">
#include</span>&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;stack&gt;
<span style="color: #0000ff;">#define</span> inf 9999999

<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span> book[<span style="color: #800080;">101</span>],sum,n,e[<span style="color: #800080;">101</span>][<span style="color: #800080;">101</span><span style="color: #000000;">];
stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
</span><span style="color: #0000ff;">bool</span> dfs (<span style="color: #0000ff;">int</span><span style="color: #000000;"> cur){
    book[cur] </span>= -<span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(e[cur][i]==<span style="color: #800080;">1</span>&amp;&amp;book[i]==-<span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>;<span style="color: #008000;">//</span><span style="color: #008000;">如果在这个dfs过程中边相连，说明有环 </span>
        <span style="color: #0000ff;">if</span>(e[cur][i]==<span style="color: #800080;">1</span>&amp;&amp;book[i]==<span style="color: #800080;">0</span>&amp;&amp;!dfs(i)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
    book[cur] </span>= <span style="color: #800080;">1</span>;<span style="color: #008000;">//</span><span style="color: #008000;">与DFS的区别在于 标记当前节点的时间 （在递归结束才加入） </span>
<span style="color: #000000;">    s.push(cur);
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,m,a,b;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d</span><span style="color: #800000;">"</span>,&amp;n,&amp;<span style="color: #000000;">m);
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(j=<span style="color: #800080;">1</span>;j&lt;=n;j++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(i==j) e[i][j]=<span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> e[i][j]=<span style="color: #000000;">inf;
        }
    }
    
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">1</span>;i&lt;=m;i++<span style="color: #000000;">){
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d</span><span style="color: #800000;">"</span>,&amp;a,&amp;<span style="color: #000000;">b);
        e[a][b]</span>=<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">bool</span> ans = dfs(<span style="color: #800080;">2</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">if</span>(ans == <span style="color: #0000ff;">false</span>) cout&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">Loop exists!</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
        </span><span style="color: #0000ff;">while</span>(!<span style="color: #000000;">s.empty()){
            cout</span>&lt;&lt;s.top()&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
            s.pop();
        }
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p><strong>测试数据：</strong></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('8b27d522-5a23-471f-a736-ead89f555ab2')"><img id="code_img_closed_8b27d522-5a23-471f-a736-ead89f555ab2" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_8b27d522-5a23-471f-a736-ead89f555ab2" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('8b27d522-5a23-471f-a736-ead89f555ab2',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_8b27d522-5a23-471f-a736-ead89f555ab2" class="cnblogs_code_hide">
<pre><span style="color: #800080;">9</span> <span style="color: #800080;">10</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">4</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">5</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">1</span>
<span style="color: #800080;">1</span> <span style="color: #800080;">3</span>
<span style="color: #800080;">3</span> <span style="color: #800080;">6</span>
<span style="color: #800080;">3</span> <span style="color: #800080;">8</span>
<span style="color: #800080;">5</span> <span style="color: #800080;">8</span>
<span style="color: #800080;">5</span> <span style="color: #800080;">7</span>
<span style="color: #800080;">8</span> <span style="color: #800080;">9</span>
<span style="color: #800080;">8</span> <span style="color: #800080;">1</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><img src="https://img2018.cnblogs.com/common/1726496/202001/1726496-20200131104312585-1879037215.png" alt="" width="245" height="278" /></p>]]></description></item><item><title>带括号表达式求值（数据结构与算法分析课程设计）</title><link>http://www.cnblogs.com/icodes8238/archive/2020/01/30/12243275.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Thu, 30 Jan 2020 09:46:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/01/30/12243275.html</guid><description><![CDATA[<h1 style="text-align: center;"><span style="font-family: 楷体;">带括号表达式求值</span></h1>
<h2><span style="font-family: 楷体;">算法1：双栈法 (2019.11)</span></h2>
<p><strong>算法描述：</strong><a href="file:///D:/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%B8%A6%E6%8B%AC%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%B1%82%E5%80%BC%EF%BC%88%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%89.pdf"><br /></a></p>
<p>（1）规定运算符优先级（详见具体操作步骤）</p>
<p>（2）对输入的字符逐一检验</p>
<p>　　（a）如果是数字字符：按位权转化为数值</p>
<p>　　（b）如果不是数字字符：将上一步的数值压栈</p>
<p>　　　　i&nbsp;如果是'('或符号栈为空：将该字符压入符号栈</p>
<p>　　　　ii 如果是')'或'='：将符号栈中所有符号弹出，每弹出一个符号从数据栈拿出两个数字进行计算，计算结果压入数据栈，直到数据栈为空或栈顶元素为'('为止</p>
<p>　　　　iii&nbsp;其他情况：比较当前元素与栈顶元素的优先级</p>
<p>　　　　　　(i)&nbsp;如果当前元素优先级<span style="background-color: #ffff00;">&nbsp;<strong>&gt;&nbsp;</strong></span>栈顶元素优先级：将当前元素压入符号栈</p>
<p>　　　　　　(ii)&nbsp;如果当前元素优先级<span style="background-color: #ffff00;">&nbsp;<strong>&lt;=&nbsp;</strong></span>栈顶元素优先级：符号栈弹出一个符号进行运算，直到当前元素优先级<span style="background-color: #ffff00;"> <strong>&gt;</strong> </span>栈顶元素优先级</p>
<p>&nbsp;</p>
<p><strong><strong>关键点提醒：</strong></strong></p>
<p><strong><strong>　　</strong></strong>使用双栈法时，如何确保表达式是从左往右计算的？这是处理当前元素与栈顶元素优先级相等关系时决定的，如果当前元素优先级<strong><span style="text-decoration: underline;">小于等于</span></strong>栈顶，则直接进行运算，把运算结果存入数值栈。试想如果<strong><span style="text-decoration: underline;">等于时</span></strong>不是弹栈进行运算，而是压栈，那么遇到优先级较小的运算符需要弹栈时，则会造成从右向左运算，这种情况下有减法运算时会出错（如3-4+8）</p>
<p>&nbsp;</p>
<p><strong>具体操作步骤：</strong></p>
<p>规定运算符优先级：</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="89">
<p><strong>运算符</strong></p>

</td>
<td valign="top" width="89">
<p><strong>(</strong></p>

</td>
<td valign="top" width="89">
<p><strong>+ &nbsp;-</strong></p>

</td>
<td valign="top" width="89">
<p><strong>x &nbsp;/ &nbsp;%</strong></p>

</td>
<td valign="top" width="89">
<p><strong>^</strong></p>

</td>

</tr>
<tr>
<td valign="top" width="89">
<p><strong>优先级</strong></p>

</td>
<td valign="top" width="89">
<p><strong>0</strong></p>

</td>
<td valign="top" width="89">
<p><strong>1</strong></p>

</td>
<td valign="top" width="89">
<p><strong>2</strong></p>

</td>
<td valign="top" width="89">
<p><strong>3</strong></p>

</td>

</tr>

</tbody>

</table>
<p>（1）首先，建立数值栈、符号栈两个栈分别存储操作符和操作数。</p>
<p>（2）将数字字符转化成数值。得到经过预处理的字符串后，从头到尾依次读取单个字符。为了将数字字符转化成数值，我们建立了state_sign和state_fraction两个标志位。一开始，将state_sign标志位置1，表示正在读取数字字符（数字字符还没读完），state_fraction标志位置0，表示即将读取的是一个数整数部分。如果遇到数字，并且state_fraction状态是0，则将单个字符的数值（这里指的是当前数字字符的ASCⅡ编码值减去字符&lsquo;0&rsquo; ASCⅡ编码值，下同）每次乘以10以后相加（最初d=0，0*10=0）；遇到小数点&lsquo;.&rsquo;，则将state_fraction状态置为1，表明即将读取的是一个数的小数部分；在此状态下读取数字字符，则依次将单个字符数值除以10后相加。</p>
<p>（3）将符号字符与符号栈顶字符优先级比较后决定是否存入符号栈。如果遇到的不是数字字符，则将state_sign置为0，表明数字字符已经转化成数值，可以将其放入数值栈中。如果读到的是&lsquo;(&rsquo;，或者符号栈为空，则将当前字符入符号栈，如果遇到的是&lsquo;)&rsquo;或者&lsquo;=&rsquo;，则将符号栈全部出栈，（一次弹出两个，进行计算后存入数值栈）直到符号栈为空，或者栈顶元素为&lsquo;(&rsquo;，如果遇到的不是上述符号并且符号栈不为空，则将当前字符与符号栈栈顶字符优先级进行比较（根据程序需要，我们将字符优先级定义为上面&ldquo;四.1&rdquo;所示），如果当前字符优先级小于等于栈顶字符（这里包含等于是为了保证从左到右的运算法则），则直接两次取出数值栈栈顶进行运算，并将运算结果存入栈顶；如果当前字符优先级大于栈顶字符，则把当前字符放入符号栈。</p>
<p>（4）对整个字符串执行上述操作，最终栈顶元素就是最后的计算结果。</p>
<p>&nbsp;</p>
<p><strong>代码实现：</strong>（可处理异常；支持负数、小数、多位数运算；支持加减乘数乘方模运算功能）</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('8f5f9b40-adad-46e7-8b09-e80ad16ef1cb')"><img id="code_img_closed_8f5f9b40-adad-46e7-8b09-e80ad16ef1cb" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_8f5f9b40-adad-46e7-8b09-e80ad16ef1cb" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('8f5f9b40-adad-46e7-8b09-e80ad16ef1cb',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_8f5f9b40-adad-46e7-8b09-e80ad16ef1cb" class="cnblogs_code_hide">
<pre>#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;stack&gt;<span style="color: #000000;">
#include</span>&lt;<span style="color: #0000ff;">string</span>.h&gt;<span style="color: #000000;">
#include</span>&lt;math.h&gt;

<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
stack</span>&lt;<span style="color: #0000ff;">double</span>&gt;<span style="color: #000000;"> data;
stack</span>&lt;<span style="color: #0000ff;">char</span>&gt;<span style="color: #000000;"> sign;

</span><span style="color: #0000ff;">int</span> priority(<span style="color: #0000ff;">char</span> ch){ <span style="color: #008000;">//</span><span style="color: #008000;">运算符优先级判断 </span>
    <span style="color: #0000ff;">if</span>(ch == <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span>||ch == <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span>(ch == <span style="color: #800000;">'</span><span style="color: #800000;">x</span><span style="color: #800000;">'</span>||ch == <span style="color: #800000;">'</span><span style="color: #800000;">/</span><span style="color: #800000;">'</span>|| ch== <span style="color: #800000;">'</span><span style="color: #800000;">%</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">2</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span>(ch == <span style="color: #800000;">'</span><span style="color: #800000;">^</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">3</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span>(ch == <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}

</span><span style="color: #0000ff;">double</span> aRb(<span style="color: #0000ff;">char</span> ch){ <span style="color: #008000;">//</span><span style="color: #008000;">判断运算类型 </span>
    <span style="color: #0000ff;">double</span><span style="color: #000000;"> a,b;
    a </span>=<span style="color: #000000;"> data.top();
    data.pop();
    b </span>=<span style="color: #000000;"> data.top();
    data.pop(); </span><span style="color: #008000;">//</span><span style="color: #008000;">依次取出栈顶两个元素 </span>
    <span style="color: #0000ff;">switch</span><span style="color: #000000;">(ch){
        </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span><span style="color: #000000;"> :
            b </span>+=<span style="color: #000000;"> a;
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span><span style="color: #000000;"> :
            b </span>-=<span style="color: #000000;"> a;
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">x</span><span style="color: #800000;">'</span><span style="color: #000000;"> :
            b </span>*=<span style="color: #000000;"> a;
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">/</span><span style="color: #800000;">'</span><span style="color: #000000;"> :
            </span><span style="color: #0000ff;">if</span>(a==<span style="color: #800080;">0</span><span style="color: #000000;">){
                </span><span style="color: #0000ff;">throw</span> <span style="color: #800000;">"</span><span style="color: #800000;">Divider can not be zero!</span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;">除数为0，抛出异常 </span>
            }<span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                b </span>/=<span style="color: #000000;"> a;
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
        </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">%</span><span style="color: #800000;">'</span><span style="color: #000000;"> :
            </span><span style="color: #0000ff;">if</span>(a==<span style="color: #800080;">0</span><span style="color: #000000;">){
                </span><span style="color: #0000ff;">throw</span> <span style="color: #800000;">"</span><span style="color: #800000;">divider can not be zero!</span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;">除数为0，抛出异常</span>
            }<span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                b </span>= (<span style="color: #0000ff;">double</span>)((<span style="color: #0000ff;">int</span>)b%(<span style="color: #0000ff;">int</span><span style="color: #000000;">)a);
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
        </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">^</span><span style="color: #800000;">'</span><span style="color: #000000;"> :
            b </span>= pow(b,a); <span style="color: #008000;">//</span><span style="color: #008000;">乘方、开方运算 </span>
            <span style="color: #0000ff;">break</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> b;
}

</span><span style="color: #0000ff;">int</span> <span style="color: #0000ff;">base</span>(<span style="color: #0000ff;">char</span> temp){ <span style="color: #008000;">//</span><span style="color: #008000;">判断字符类型 </span>
    <span style="color: #0000ff;">char</span> base_digtal[] = {<span style="color: #800000;">"</span><span style="color: #800000;">1234567890</span><span style="color: #800000;">"</span><span style="color: #000000;">};
    </span><span style="color: #0000ff;">char</span> base_sign[] = {<span style="color: #800000;">"</span><span style="color: #800000;">+-x/%^</span><span style="color: #800000;">"</span><span style="color: #000000;">};
    </span><span style="color: #0000ff;">char</span> base_others[] = {<span style="color: #800000;">"</span><span style="color: #800000;">().=</span><span style="color: #800000;">"</span><span style="color: #000000;">};
    </span><span style="color: #0000ff;">if</span>(strchr(base_digtal,temp)) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(strchr(base_sign,temp)) <span style="color: #0000ff;">return</span> <span style="color: #800080;">2</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(strchr(base_others,temp)) <span style="color: #0000ff;">return</span> <span style="color: #800080;">3</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}

</span><span style="color: #0000ff;">void</span> showerror(<span style="color: #0000ff;">char</span> temp[],<span style="color: #0000ff;">int</span> e){ <span style="color: #008000;">//</span><span style="color: #008000;">指出第一次出现错误的位置 </span>
    <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;strlen(temp);i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(i==e) cout&lt;&lt;temp[e]&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">&lt;| </span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span> cout&lt;&lt;<span style="color: #000000;">temp[i];
    }
    cout</span>&lt;&lt;<span style="color: #000000;">endl;
}
</span><span style="color: #0000ff;">bool</span> precheck(<span style="color: #0000ff;">char</span><span style="color: #000000;"> temp[]){
    stack</span>&lt;<span style="color: #0000ff;">char</span>&gt;<span style="color: #000000;"> t;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;strlen(temp);i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>((temp[i]&amp;<span style="color: #800080;">0x80</span>) &amp;&amp; (temp[i+<span style="color: #800080;">1</span>]&amp;<span style="color: #800080;">0x80</span>)){<span style="color: #008000;">//</span><span style="color: #008000;">如果字符高位为1且下一字符高位也是1则有中文字符</span>
            cout&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">请不要输入中文字符</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
            showerror(temp,i</span>+<span style="color: #800080;">1</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">if</span>(temp[i] == <span style="color: #800000;">'</span><span style="color: #800000;">=</span><span style="color: #800000;">'</span>&amp;&amp; i!=strlen(temp)-<span style="color: #800080;">1</span>){ <span style="color: #008000;">//</span><span style="color: #008000;">如果等号出现在表达式中间则报错 </span>
            cout&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">Invalid input</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
            showerror(temp,i);
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">if</span>(!<span style="color: #0000ff;">base</span><span style="color: #000000;">(temp[i])){
            cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">Please input the sign appointed！</span><span style="color: #800000;">"</span>&lt;&lt;endl;<span style="color: #008000;">//</span><span style="color: #008000;">出现未知符号 </span>
<span style="color: #000000;">            showerror(temp,i);
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">; 
        }
        </span><span style="color: #0000ff;">if</span>((temp[i]==<span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span>||temp[i]==<span style="color: #800000;">'</span><span style="color: #800000;">)</span><span style="color: #800000;">'</span>)&amp;&amp;i!=<span style="color: #800080;">0</span>&amp;&amp;i!=strlen(temp)-<span style="color: #800080;">1</span>&amp;&amp;<span style="color: #0000ff;">base</span>(temp[i-<span style="color: #800080;">1</span>])==<span style="color: #800080;">1</span>&amp;&amp;<span style="color: #0000ff;">base</span>(temp[i+<span style="color: #800080;">1</span>])==<span style="color: #800080;">1</span><span style="color: #000000;">){
            cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">Both sides of parenthesis are numbers!</span><span style="color: #800000;">"</span>&lt;&lt;endl; <span style="color: #008000;">//</span><span style="color: #008000;">符号省略 </span>
<span style="color: #000000;">            showerror(temp,i);
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        } 
        </span><span style="color: #0000ff;">if</span>(((<span style="color: #0000ff;">base</span>(temp[<span style="color: #800080;">0</span>])==<span style="color: #800080;">2</span>)&amp;&amp;temp[<span style="color: #800080;">0</span>]!=<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>)||(i==strlen(temp)-<span style="color: #800080;">1</span>&amp;&amp;<span style="color: #0000ff;">base</span>(temp[i])==<span style="color: #800080;">2</span>)||(<span style="color: #0000ff;">base</span>(temp[i])==<span style="color: #800080;">2</span>&amp;&amp;<span style="color: #0000ff;">base</span>(temp[i+<span style="color: #800080;">1</span>])==<span style="color: #800080;">2</span><span style="color: #000000;">)){
            cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">Signs redundancy!</span><span style="color: #800000;">"</span>&lt;&lt;endl;<span style="color: #008000;">//</span><span style="color: #008000;">符号冗余（重复输入） </span>
<span style="color: #000000;">            showerror(temp,i);
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">if</span>(temp[i]==<span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span>&amp;&amp;<span style="color: #0000ff;">base</span>(temp[i+<span style="color: #800080;">1</span>])!=<span style="color: #800080;">1</span><span style="color: #000000;">){
            cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">The fraction part you put is wrong!</span><span style="color: #800000;">"</span>&lt;&lt;endl;<span style="color: #008000;">//</span><span style="color: #008000;">小数部分输入错误 </span>
<span style="color: #000000;">            showerror(temp,i);
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">if</span>(temp[i]==<span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span><span style="color: #000000;">) t.push(temp[i]);
        </span><span style="color: #0000ff;">if</span>(temp[i]==<span style="color: #800000;">'</span><span style="color: #800000;">)</span><span style="color: #800000;">'</span><span style="color: #000000;">) t.pop();    
    }
    </span><span style="color: #0000ff;">if</span>(t.empty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
        cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">Parenthesis is not matching!</span><span style="color: #800000;">"</span>&lt;&lt;endl;<span style="color: #008000;">//</span><span style="color: #008000;">括号不匹配 </span>
        <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }    
}
</span><span style="color: #0000ff;">double</span> calculate(<span style="color: #0000ff;">char</span><span style="color: #000000;"> temp[]){
    </span><span style="color: #0000ff;">double</span> d = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">bool</span> state_fraction = <span style="color: #800080;">0</span>;<span style="color: #008000;">//</span><span style="color: #008000;">判断当前数字字符在小数点前面还是后面 </span>
    <span style="color: #0000ff;">bool</span> state_sign = <span style="color: #800080;">1</span>;<span style="color: #008000;">//</span><span style="color: #008000;">判断一个数是否读完 </span>
    <span style="color: #0000ff;">int</span> count = <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;strlen(temp);i++<span style="color: #000000;">){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">把数字字符处理成数值 </span>
        <span style="color: #0000ff;">if</span>(!state_fraction&amp;&amp;<span style="color: #0000ff;">base</span>(temp[i])==<span style="color: #800080;">1</span><span style="color: #000000;">){
            d </span>*= <span style="color: #800080;">10</span><span style="color: #000000;">; 
            d </span>+= (<span style="color: #0000ff;">double</span>)(temp[i] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
            state_sign</span>=<span style="color: #800080;">0</span><span style="color: #000000;">;
        }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(temp[i]==<span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span><span style="color: #000000;">){
            state_fraction </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
            
        }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(state_fraction&amp;&amp;(<span style="color: #0000ff;">base</span>(temp[i])==<span style="color: #800080;">1</span><span style="color: #000000;">)){
            d </span>+= (<span style="color: #0000ff;">double</span>)(temp[i] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>)/pow(<span style="color: #800080;">10</span><span style="color: #000000;">,count);
            count</span>++<span style="color: #000000;">;
            state_sign</span>=<span style="color: #800080;">0</span><span style="color: #000000;">;
        }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
            </span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">state_sign) {
                data.push(d);
            }
            d </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            state_fraction </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            count </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span>(temp[i]==<span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span>||sign.empty()){<span style="color: #008000;">//</span><span style="color: #008000;">如果是(或栈为空直接入栈 </span>
<span style="color: #000000;">                sign.push(temp[i]);
            }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(temp[i]==<span style="color: #800000;">'</span><span style="color: #800000;">)</span><span style="color: #800000;">'</span>||temp[i]==<span style="color: #800000;">'</span><span style="color: #800000;">=</span><span style="color: #800000;">'</span><span style="color: #000000;">){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">如果遇到)或者=，则符号栈全部出栈，同时从数值栈取出两个数进行运算 </span>
                <span style="color: #0000ff;">while</span>(!sign.empty()&amp;&amp;sign.top()!=<span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span>){<span style="color: #008000;">//</span><span style="color: #008000;">根据短路原则，注意顺序 </span>
                    <span style="color: #0000ff;">double</span> res =<span style="color: #000000;"> aRb(sign.top());
                    data.push(res);
                    sign.pop();
                }
                </span><span style="color: #0000ff;">if</span>(!sign.empty()) sign.pop();<span style="color: #008000;">//</span><span style="color: #008000;">弹出( </span>
            }<span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(priority(temp[i])&lt;=<span style="color: #000000;">priority(sign.top())){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">如果优先级小于等于栈顶，则直接进行运算，把运算结果存入数值栈 
            </span><span style="color: #008000;">//</span><span style="color: #008000;">等号的位置决定从左到右进行运算  </span>
                <span style="color: #0000ff;">while</span>(!sign.empty()&amp;&amp;priority(temp[i])&lt;=<span style="color: #000000;">priority(sign.top())){
                    </span><span style="color: #0000ff;">double</span> res =<span style="color: #000000;"> aRb(sign.top());
                    data.push(res);
                    sign.pop();
                }        
                sign.push(temp[i]);
            }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(priority(temp[i])&gt;<span style="color: #000000;">priority(sign.top())){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">如果优先级大于栈顶，则入符号栈 </span>
<span style="color: #000000;">                sign.push(temp[i]);
            }
            state_sign </span>= <span style="color: #800080;">1</span>;    <span style="color: #008000;">//</span><span style="color: #008000;">遇到非数字字符表示数字部分已读完 </span>
<span style="color: #000000;">        }
    }
    </span><span style="color: #0000ff;">return</span> data.top(); <span style="color: #008000;">//</span><span style="color: #008000;">栈顶元素即为最终运算结果 </span>
<span style="color: #000000;">}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main() {
    cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">---------Welcome!---------</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">----Input exit to exit----</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl; 
    </span><span style="color: #0000ff;">double</span> ans; <span style="color: #008000;">//</span><span style="color: #008000;">最终计算结果 </span>
    <span style="color: #0000ff;">while</span>(<span style="color: #800080;">1</span><span style="color: #000000;">){
        </span><span style="color: #0000ff;">char</span> temp[<span style="color: #800080;">300</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">存储读入的字符串，用于预处理等操作 </span>
        memset(temp,<span style="color: #800080;">0</span>,<span style="color: #800080;">300</span><span style="color: #000000;">);  
        </span><span style="color: #0000ff;">while</span>(!<span style="color: #000000;">data.empty()) data.pop();
        </span><span style="color: #0000ff;">while</span>(!sign.empty()) sign.pop(); <span style="color: #008000;">//</span><span style="color: #008000;">初始化</span>
        cin.getline(temp,<span style="color: #800080;">300</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">if</span>(strcmp(temp,<span style="color: #800000;">"</span><span style="color: #800000;">exit</span><span style="color: #800000;">"</span>)==<span style="color: #800080;">0</span>) <span style="color: #0000ff;">break</span>; <span style="color: #008000;">//</span><span style="color: #008000;">程序出口 
        </span><span style="color: #008000;">//</span><span style="color: #008000;">展示更精确的结果</span>
        <span style="color: #0000ff;">if</span>(strcmp(temp,<span style="color: #800000;">"</span><span style="color: #800000;">show more</span><span style="color: #800000;">"</span>)==<span style="color: #800080;">0</span><span style="color: #000000;">){  
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">ans = %.9lf\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,ans);
            </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">对空格进行处理</span>
        <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;strlen(temp);i++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(temp[i]==<span style="color: #800000;">'</span> <span style="color: #800000;">'</span><span style="color: #000000;">)
                </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> k=i;k&lt;strlen(temp);k++<span style="color: #000000;">) 
                    temp[k] </span>= temp[k+<span style="color: #800080;">1</span><span style="color: #000000;">];
        } 
        </span><span style="color: #0000ff;">if</span>(!precheck(temp)) <span style="color: #0000ff;">continue</span>; <span style="color: #008000;">//</span><span style="color: #008000;">预处理结果判断 
        </span><span style="color: #008000;">//</span><span style="color: #008000;">对'-'前没有数字的情况进行加0处理 </span>
        <span style="color: #0000ff;">if</span>(temp[<span style="color: #800080;">0</span>]==<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span><span style="color: #000000;">){
            </span><span style="color: #0000ff;">int</span> k =<span style="color: #000000;"> strlen(temp);
            </span><span style="color: #0000ff;">for</span>(k;k&gt;<span style="color: #800080;">0</span>;k--) temp[k] = temp[k-<span style="color: #800080;">1</span><span style="color: #000000;">];
            temp[</span><span style="color: #800080;">0</span>] = <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;strlen(temp);i++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(temp[i]==<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>&amp;&amp; <span style="color: #0000ff;">base</span>(temp[i-<span style="color: #800080;">1</span>])!=<span style="color: #800080;">1</span>&amp;&amp;temp[i-<span style="color: #800080;">1</span>]!=<span style="color: #800000;">'</span><span style="color: #800000;">)</span><span style="color: #800000;">'</span><span style="color: #000000;">){
                </span><span style="color: #0000ff;">int</span> k =<span style="color: #000000;"> strlen(temp);
                </span><span style="color: #0000ff;">for</span>(k;k&gt;i;k--) temp[k] = temp[k-<span style="color: #800080;">1</span><span style="color: #000000;">];
                    temp[i] </span>= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            }
        }    
        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果用户没有输入'='，在字符串末尾添加'=' </span>
        <span style="color: #0000ff;">int</span> k =<span style="color: #000000;"> strlen(temp);
        temp[k] </span>= <span style="color: #800000;">'</span><span style="color: #800000;">\0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span>(temp[k-<span style="color: #800080;">1</span>]!=<span style="color: #800000;">'</span><span style="color: #800000;">=</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
            temp[k] </span>= <span style="color: #800000;">'</span><span style="color: #800000;">=</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            temp[k</span>+<span style="color: #800080;">1</span>] = <span style="color: #800000;">'</span><span style="color: #800000;">\0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">运行异常检测 </span>
        <span style="color: #0000ff;">try</span><span style="color: #000000;">{
            ans </span>=<span style="color: #000000;"> calculate(temp);
            cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">ans = </span><span style="color: #800000;">"</span>&lt;&lt;ans&lt;&lt;<span style="color: #000000;">endl;    
        }</span><span style="color: #0000ff;">catch</span>(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>*<span style="color: #000000;">message){
            cout</span>&lt;&lt;message&lt;&lt;<span style="color: #000000;">endl;
        }    
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">测试数据
</span><span style="color: #008000;">//</span><span style="color: #008000;">-(-3+(3x(5/2+(3^2%5)+5)x2)/3)+((2x5-3)x2)=
</span><span style="color: #008000;">//</span><span style="color: #008000;">-(-2+3-5)=
</span><span style="color: #008000;">//</span><span style="color: #008000;">12+.3-.5x2
</span><span style="color: #008000;">//</span><span style="color: #008000;">.3+4-2x(3+5/2^3)-.3
</span><span style="color: #008000;">//</span><span style="color: #008000;">-3.4+4
</span><span style="color: #008000;">//</span><span style="color: #008000;">3.22.4+2?
</span><span style="color: #008000;">//</span><span style="color: #008000;">2.3x(3+3.4)-4/2.2
</span><span style="color: #008000;">//</span><span style="color: #008000;">(2-(-(-(-(-(-2)x3)x1)x.3)/2.3)-2)/2
</span><span style="color: #008000;">//</span><span style="color: #008000;">2.6125 + 0.04150390625</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;">算法2：基于栈的逆波兰算法&nbsp; (201911)</span></h2>
<p><strong>算法具体步骤：</strong></p>
<p>（1）建立一个操作符栈（临时存放操作符）；再建立一个队列（存放后缀表达式）；</p>
<p>再建立一个栈（后缀表达式求值时临时存放操作数）；</p>
<p><span style="text-decoration: underline;"><strong>后缀表达式中有数字(double)有字符(char)，后缀表达式要存放在一个栈中，可以将队列的基本类型定义为结构体类型</strong></span>。</p>
<p>&nbsp;</p>
<p>（2）将中缀表达式转换成后缀式（逆波兰表达式）</p>
<p>　　(a） 从左到右读进中缀表达式的每个字符。</p>
<p>　　(b)&nbsp; 如果读到的字符为操作数，则直接输出到后缀表达式中（注意多位数和小数的处理参照算法1（有优化））。</p>
<p>　　(c）如果遇到&ldquo;)&rdquo;，则弹出栈内的运算符，直到弹出到一个&ldquo;(&rdquo;；如果遇到&ldquo;=&rdquo;，则弹出栈内所有运算符</p>
<p>　　(d） &ldquo;(&rdquo;的优先级在栈内比任何运算符都小，但可直接入栈</p>
<p>　　(e）当运算符准备进入栈内时，和栈顶的运算符比较，如果外面的运算符优先级<span style="text-decoration: underline;"><strong>高于</strong></span>栈顶的运算符的优先级，则压栈；如果优先级<span style="text-decoration: underline;"><strong>低于或等于</strong></span>栈顶的运算符的优先级，则弹栈<span style="text-decoration: underline;"><strong>到后缀表达式</strong></span>中。直到栈顶的运算符的优先级低于外面的运算符优先级或者栈为空时，再把外面的运算符压栈。</p>
<p>　　(f）中缀表达式读完后，如果运算符栈不为空，则将其内的运算符逐一弹出，输出到后缀表达式中。</p>
<p>(2)然后对后缀表达式进行求值</p>
<p>　　(a）从头到尾读取表达式，如果遇到数字就压栈。</p>
<p>　　(b）如果遇到运算符，弹出两个数进行运算，将运算结果压栈。</p>
<p>&nbsp;</p>
<p><strong>代码实现：</strong>（为了简便起见，没有处理异常；支持负数、小数、多位数运算；支持加减乘数乘方模运算功能）20200202</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('c9fce8b7-1ea9-4dc5-86ad-2321f713d332')"><img id="code_img_closed_c9fce8b7-1ea9-4dc5-86ad-2321f713d332" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_c9fce8b7-1ea9-4dc5-86ad-2321f713d332" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('c9fce8b7-1ea9-4dc5-86ad-2321f713d332',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_c9fce8b7-1ea9-4dc5-86ad-2321f713d332" class="cnblogs_code_hide">
<pre>#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;stack&gt;<span style="color: #000000;">
#include</span>&lt;queue&gt;<span style="color: #000000;"> 
#include</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">
#include</span>&lt;cstring&gt;<span style="color: #000000;">
#include</span>&lt;cmath&gt;

<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
typedef </span><span style="color: #0000ff;">struct</span><span style="color: #000000;">{
    </span><span style="color: #0000ff;">double</span> num; <span style="color: #008000;">//</span><span style="color: #008000;">操作数 </span>
    <span style="color: #0000ff;">char</span> op; <span style="color: #008000;">//</span><span style="color: #008000;">操作符</span>
    <span style="color: #0000ff;">bool</span> flag; <span style="color: #008000;">//</span><span style="color: #008000;">true为操作数，false为操作符 </span>
<span style="color: #000000;">}node;

stack</span>&lt;<span style="color: #0000ff;">char</span>&gt; sign; <span style="color: #008000;">//</span><span style="color: #008000;">临时存放操作符 </span>
queue&lt;node&gt; suffix; <span style="color: #008000;">//</span><span style="color: #008000;">存放后缀表达式 </span>
stack&lt;<span style="color: #0000ff;">double</span>&gt; data; <span style="color: #008000;">//</span><span style="color: #008000;">后缀表达式求值时临时存放操作数 </span>

<span style="color: #0000ff;">int</span> priority(<span style="color: #0000ff;">char</span> ch){ <span style="color: #008000;">//</span><span style="color: #008000;">运算符优先级判断 </span><span style="color: #008000;">//</span><span style="color: #008000;">《算法笔记》中用map来映射运算符优先级 </span>
    <span style="color: #0000ff;">if</span>(ch == <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span>||ch == <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span>(ch == <span style="color: #800000;">'</span><span style="color: #800000;">x</span><span style="color: #800000;">'</span>||ch == <span style="color: #800000;">'</span><span style="color: #800000;">/</span><span style="color: #800000;">'</span>|| ch== <span style="color: #800000;">'</span><span style="color: #800000;">%</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">2</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span>(ch == <span style="color: #800000;">'</span><span style="color: #800000;">^</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">3</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span>(ch == <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}

</span><span style="color: #0000ff;">void</span> aRb(<span style="color: #0000ff;">char</span> ch){ <span style="color: #008000;">//</span><span style="color: #008000;">判断运算类型 </span>
    <span style="color: #0000ff;">double</span><span style="color: #000000;"> a,b;
    a </span>=<span style="color: #000000;"> data.top();
    data.pop();
    b </span>=<span style="color: #000000;"> data.top();
    data.pop(); </span><span style="color: #008000;">//</span><span style="color: #008000;">依次取出栈顶两个元素 </span>
    <span style="color: #0000ff;">switch</span><span style="color: #000000;">(ch){
        </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span><span style="color: #000000;"> :
            b </span>+=<span style="color: #000000;"> a;
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span><span style="color: #000000;"> :
            b </span>-=<span style="color: #000000;"> a;
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">x</span><span style="color: #800000;">'</span><span style="color: #000000;"> :
            b </span>*=<span style="color: #000000;"> a;
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">/</span><span style="color: #800000;">'</span><span style="color: #000000;"> :
            </span><span style="color: #0000ff;">if</span>(a==<span style="color: #800080;">0</span><span style="color: #000000;">){
                </span><span style="color: #0000ff;">throw</span> <span style="color: #800000;">"</span><span style="color: #800000;">Divider can not be zero!</span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;">除数为0，抛出异常 </span>
            }<span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                b </span>/=<span style="color: #000000;"> a;
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
        </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">%</span><span style="color: #800000;">'</span><span style="color: #000000;"> :
            </span><span style="color: #0000ff;">if</span>(a==<span style="color: #800080;">0</span><span style="color: #000000;">){
                </span><span style="color: #0000ff;">throw</span> <span style="color: #800000;">"</span><span style="color: #800000;">divider can not be zero!</span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;">除数为0，抛出异常</span>
            }<span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                b </span>= (<span style="color: #0000ff;">double</span>)((<span style="color: #0000ff;">int</span>)b%(<span style="color: #0000ff;">int</span><span style="color: #000000;">)a);
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
        </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">^</span><span style="color: #800000;">'</span><span style="color: #000000;"> :
            b </span>= pow(b,a); <span style="color: #008000;">//</span><span style="color: #008000;">乘方、开方运算 </span>
            <span style="color: #0000ff;">break</span><span style="color: #000000;">;
    }
    data.push(b);
}

</span><span style="color: #0000ff;">int</span> <span style="color: #0000ff;">base</span>(<span style="color: #0000ff;">char</span> temp){ <span style="color: #008000;">//</span><span style="color: #008000;">判断字符类型 </span>
    <span style="color: #0000ff;">char</span> base_digtal[] = {<span style="color: #800000;">"</span><span style="color: #800000;">1234567890</span><span style="color: #800000;">"</span><span style="color: #000000;">};
    </span><span style="color: #0000ff;">char</span> base_sign[] = {<span style="color: #800000;">"</span><span style="color: #800000;">+-x/%^</span><span style="color: #800000;">"</span><span style="color: #000000;">};
    </span><span style="color: #0000ff;">char</span> base_others[] = {<span style="color: #800000;">"</span><span style="color: #800000;">().=</span><span style="color: #800000;">"</span><span style="color: #000000;">};
    </span><span style="color: #0000ff;">if</span>(strchr(base_digtal,temp)) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(strchr(base_sign,temp)) <span style="color: #0000ff;">return</span> <span style="color: #800080;">2</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(strchr(base_others,temp)) <span style="color: #0000ff;">return</span> <span style="color: #800080;">3</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}


</span><span style="color: #0000ff;">void</span> change(<span style="color: #0000ff;">string</span><span style="color: #000000;"> temp){
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;temp.length();){ <span style="color: #008000;">//</span><span style="color: #008000;">从左到右依次读中缀表达式</span>
        <span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">base</span>(temp[i]) == <span style="color: #800080;">1</span> || temp[i] ==<span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span><span style="color: #000000;">){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">把数字字符处理成数值</span>
            <span style="color: #0000ff;">double</span> d = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">bool</span> state_fraction = <span style="color: #800080;">0</span>;<span style="color: #008000;">//</span><span style="color: #008000;">判断当前数字字符在小数点前面还是后面 </span>
            <span style="color: #0000ff;">int</span> count = <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span>(<span style="color: #0000ff;">base</span>(temp[i]) == <span style="color: #800080;">1</span> || temp[i] ==<span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span><span style="color: #000000;">){
                </span><span style="color: #0000ff;">if</span>(!state_fraction&amp;&amp;<span style="color: #0000ff;">base</span>(temp[i])==<span style="color: #800080;">1</span><span style="color: #000000;">){
                    d </span>*= <span style="color: #800080;">10</span><span style="color: #000000;">; 
                    d </span>+= (<span style="color: #0000ff;">double</span>)(temp[i] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
                }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(temp[i]==<span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span><span style="color: #000000;">){
                    state_fraction </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
                    
                }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(state_fraction&amp;&amp;(<span style="color: #0000ff;">base</span>(temp[i])==<span style="color: #800080;">1</span><span style="color: #000000;">)){
                    d </span>+= (<span style="color: #0000ff;">double</span>)(temp[i] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>)/pow(<span style="color: #800080;">10</span><span style="color: #000000;">,count);
                    count</span>++<span style="color: #000000;">;
                }
                i</span>++<span style="color: #000000;">;
            }
            node t;
            t.num </span>=<span style="color: #000000;"> d;
            t.flag </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
            suffix.push(t); </span><span style="color: #008000;">//</span><span style="color: #008000;">数值入栈   </span>
        }<span style="color: #0000ff;">else</span>{<span style="color: #008000;">//</span><span style="color: #008000;">处理非数字字符</span>
            <span style="color: #0000ff;">if</span>((sign.empty()||temp[i] == <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span>) &amp;&amp; temp[i]!=<span style="color: #800000;">'</span><span style="color: #800000;">=</span><span style="color: #800000;">'</span><span style="color: #000000;">) sign.push(temp[i]);
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(temp[i] == <span style="color: #800000;">'</span><span style="color: #800000;">)</span><span style="color: #800000;">'</span><span style="color: #000000;">){
                </span><span style="color: #0000ff;">while</span>(!sign.empty() &amp;&amp; sign.top()!=<span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span><span style="color: #000000;">){
                    node t;
                    t.op </span>=<span style="color: #000000;"> sign.top();
                    t.flag </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                    suffix.push(t);
                    sign.pop();    
                }
                </span><span style="color: #0000ff;">if</span>(!sign.empty()) sign.pop(); <span style="color: #008000;">//</span><span style="color: #008000;">pop操作前都必须判断是否为empty </span>
<span style="color: #000000;">            } 
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(temp[i] == <span style="color: #800000;">'</span><span style="color: #800000;">=</span><span style="color: #800000;">'</span><span style="color: #000000;">){
                </span><span style="color: #0000ff;">while</span>(!<span style="color: #000000;">sign.empty()){
                    node t;
                    t.op </span>=<span style="color: #000000;"> sign.top();
                    t.flag </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                    suffix.push(t);
                    sign.pop();
                } 
            }
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">base</span>(temp[i]) == <span style="color: #800080;">2</span><span style="color: #000000;">){
                </span><span style="color: #0000ff;">if</span>(priority(temp[i])&lt;=<span style="color: #000000;">priority(sign.top())){
                    </span><span style="color: #0000ff;">while</span>(!sign.empty()&amp;&amp;priority(temp[i])&lt;=<span style="color: #000000;">priority(sign.top())){
                        node t;
                        t.op </span>=<span style="color: #000000;"> sign.top();
                        t.flag </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                        suffix.push(t);
                        sign.pop();
                    }    
                }
                sign.push(temp[i]);
            }
            i</span>++<span style="color: #000000;">;    
        } 
        
    }
}

</span><span style="color: #0000ff;">double</span><span style="color: #000000;"> calculate(){
    </span><span style="color: #0000ff;">while</span>(!<span style="color: #000000;">suffix.empty()){
        </span><span style="color: #0000ff;">if</span>(suffix.front().flag == <span style="color: #800080;">1</span><span style="color: #000000;">) {
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%lf </span><span style="color: #800000;">"</span><span style="color: #000000;">,suffix.front().num);
            data.push(suffix.front().num);
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(suffix.front().flag == <span style="color: #800080;">0</span><span style="color: #000000;">){
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%c </span><span style="color: #800000;">"</span><span style="color: #000000;">,suffix.front().op);
            aRb(suffix.front().op);    
        }
        suffix.pop();
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> data.top();
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main() {
    </span><span style="color: #0000ff;">double</span> ans; <span style="color: #008000;">//</span><span style="color: #008000;">最终计算结果 </span>
    <span style="color: #0000ff;">while</span>(<span style="color: #800080;">1</span><span style="color: #000000;">){
        </span><span style="color: #0000ff;">string</span> temp; <span style="color: #008000;">//</span><span style="color: #008000;">存储读入的字符串，用于预处理等操作   </span>
        <span style="color: #0000ff;">while</span>(!<span style="color: #000000;">data.empty()) data.pop();
        </span><span style="color: #0000ff;">while</span>(!sign.empty()) sign.pop(); <span style="color: #008000;">//</span><span style="color: #008000;">初始化</span>
<span style="color: #000000;">        getline(cin,temp);
        </span><span style="color: #0000ff;">if</span>(temp == <span style="color: #800000;">"</span><span style="color: #800000;">exit</span><span style="color: #800000;">"</span>) <span style="color: #0000ff;">break</span>; <span style="color: #008000;">//</span><span style="color: #008000;">程序出口 </span>
        <span style="color: #0000ff;">string</span>::iterator it = temp.end() - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span>(*it != <span style="color: #800000;">'</span><span style="color: #800000;">=</span><span style="color: #800000;">'</span>) temp.insert(it+<span style="color: #800080;">1</span>,<span style="color: #800000;">'</span><span style="color: #800000;">=</span><span style="color: #800000;">'</span>);<span style="color: #008000;">//</span><span style="color: #008000;">如果用户没有输入'='，在字符串末尾添加'=' </span>
        <span style="color: #0000ff;">for</span>(it = temp.begin();it!=temp.end();it++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(*it == <span style="color: #800000;">'</span> <span style="color: #800000;">'</span>) temp.erase(it); <span style="color: #008000;">//</span><span style="color: #008000;">对空格进行处理；注意先检验空格，再进行下一步处理 </span>
            <span style="color: #0000ff;">if</span>(it==temp.begin() &amp;&amp; *it==<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>) temp.insert(it,<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">if</span>(*it == <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span><span style="color: #000000;">){ 
                </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">base</span>(*(it-<span style="color: #800080;">1</span>))!=<span style="color: #800080;">1</span> &amp;&amp; *(it-<span style="color: #800080;">1</span>)!=<span style="color: #800000;">'</span><span style="color: #800000;">)</span><span style="color: #800000;">'</span><span style="color: #000000;">)
                    temp.insert(it,</span><span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>); <span style="color: #008000;">//</span><span style="color: #008000;">对'-'前没有数字的情况进行加0处理 </span>
<span style="color: #000000;">            }
        } 
        cout</span>&lt;&lt;temp&lt;&lt;<span style="color: #000000;">endl;
        change(temp);
        ans </span>=<span style="color: #000000;"> calculate();
        cout</span>&lt;&lt;<span style="color: #000000;">endl;
        cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">ans = </span><span style="color: #800000;">"</span>&lt;&lt;ans&lt;&lt;<span style="color: #000000;">endl;      
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">测试数据
</span><span style="color: #008000;">//</span><span style="color: #008000;">-(-3+(3x(5/2+(3^2%5)+5)x2)/3)+((2x5-3)x2)=
</span><span style="color: #008000;">//</span><span style="color: #008000;"> - ( - 2 + 3 - 5 ) =
</span><span style="color: #008000;">//</span><span style="color: #008000;">12+.3-.5x2
</span><span style="color: #008000;">//</span><span style="color: #008000;">.3+4-2x(3+5/2^3)-.3
</span><span style="color: #008000;">//</span><span style="color: #008000;">-3.4+4
</span><span style="color: #008000;">//</span><span style="color: #008000;">2.3x(3+3.4)-4/2.2
</span><span style="color: #008000;">//</span><span style="color: #008000;">(2-(-(-(-(-(-2)x3)x1)x.3)/2.3)-2)/2</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;">算法3：基于二叉树的逆波兰算法 (20200122)</span></h2>
<p><strong>算法描述：</strong>将中缀表达式用二叉树结构存储。二叉树的后序遍历即为后缀表达式，然后用逆波兰算法求后缀表达式的值。</p>
<p>&nbsp;</p>
<p><strong>如何构建二叉树？（摘自课件）</strong></p>
<p>1. If the current token is a&nbsp;'(', add a new node as the left child of the current node, and <strong><span style="text-decoration: underline;">descend to</span></strong>（指向） the left child.</p>
<p>2. If the current token is in the vector&nbsp;['+','-','/','*'], set the root value of the current node to the operator represented by the current token. Add a new node as the right child of the current node and descend to the right child.</p>
<p>3. If the current token is a number, set the root value of the current node to the number and return to the parent.</p>
<p>4. If the current token is a&nbsp;')', go to the parent of the current node.</p>
<p>&nbsp;</p>
<p><strong>关键点提醒：</strong>构造二叉树时要注意初始化<span style="text-decoration: underline;"><strong>叶节点的左右孩子为NULL</strong></span></p>
<p>&nbsp;</p>
<p><strong>代码实现：</strong>（仅支持一位数加减乘除运算，且必须带有括号；也可对字符串进行预处理成下列代码能运行的格式）</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('b04306b2-b813-45c1-9b60-2b57bd96b1d9')"><img id="code_img_closed_b04306b2-b813-45c1-9b60-2b57bd96b1d9" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_b04306b2-b813-45c1-9b60-2b57bd96b1d9" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('b04306b2-b813-45c1-9b60-2b57bd96b1d9',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_b04306b2-b813-45c1-9b60-2b57bd96b1d9" class="cnblogs_code_hide">
<pre>#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;stack&gt;

<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
typedef </span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> BSTNode{
    </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> value;
    </span><span style="color: #0000ff;">struct</span> BSTNode *<span style="color: #000000;">parent;
    </span><span style="color: #0000ff;">struct</span> BSTNode *<span style="color: #000000;">left;
    </span><span style="color: #0000ff;">struct</span> BSTNode *<span style="color: #000000;">right;
}BSTNode; 
BSTNode </span>*cur = <span style="color: #0000ff;">new</span><span style="color: #000000;"> BSTNode;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> ans;
stack</span>&lt;<span style="color: #0000ff;">char</span>&gt;<span style="color: #000000;"> s;

</span><span style="color: #0000ff;">void</span> aRb(<span style="color: #0000ff;">char</span><span style="color: #000000;"> t){
    </span><span style="color: #0000ff;">char</span> temp =<span style="color: #000000;"> s.top();
    s.pop();
    </span><span style="color: #0000ff;">if</span>(t==<span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span>) ans = s.top() +<span style="color: #000000;"> temp;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(t==<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>) ans = s.top() -<span style="color: #000000;"> temp;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(t==<span style="color: #800000;">'</span><span style="color: #800000;">x</span><span style="color: #800000;">'</span>) ans = s.top() *<span style="color: #000000;"> temp;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(t==<span style="color: #800000;">'</span><span style="color: #800000;">/</span><span style="color: #800000;">'</span>) ans = s.top() /<span style="color: #000000;"> temp;
    s.pop();
    s.push(ans);
}
</span><span style="color: #0000ff;">void</span> InOrder(BSTNode *<span style="color: #000000;">T){
    </span><span style="color: #0000ff;">if</span>(T!=<span style="color: #000000;">NULL){
        InOrder(T</span>-&gt;<span style="color: #000000;">left);
        cout</span>&lt;&lt;T-&gt;<span style="color: #000000;">value;
        InOrder(T</span>-&gt;<span style="color: #000000;">right);
    }
}
</span><span style="color: #0000ff;">void</span> PostOrder(BSTNode *<span style="color: #000000;">T){
    </span><span style="color: #0000ff;">if</span>(T!=<span style="color: #000000;">NULL){
        PostOrder(T</span>-&gt;<span style="color: #000000;">left);
        PostOrder(T</span>-&gt;<span style="color: #000000;">right);
        cout</span>&lt;&lt;T-&gt;value&lt;&lt;<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span>(T-&gt;value&gt;=<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>&amp;&amp;T-&gt;value&lt;=<span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>) s.push(T-&gt;value - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">else</span> aRb(T-&gt;<span style="color: #000000;">value);
    }
}


</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    cur</span>-&gt;parent = NULL; <span style="color: #008000;">//</span><span style="color: #008000;">赋初值很重要 </span>
    <span style="color: #0000ff;">char</span> ch = cin.<span style="color: #0000ff;">get</span><span style="color: #000000;">();
    </span><span style="color: #0000ff;">while</span>(ch != <span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(ch==<span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
            cur</span>-&gt;left = <span style="color: #0000ff;">new</span><span style="color: #000000;"> BSTNode;
            cur</span>-&gt;left-&gt;parent =<span style="color: #000000;"> cur;
            cur </span>= cur-&gt;<span style="color: #000000;">left;
            cur</span>-&gt;left = NULL;<span style="color: #008000;">//</span><span style="color: #008000;">赋初值很重要 </span>
            cur-&gt;right =<span style="color: #000000;"> NULL;
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(ch&gt;=<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>&amp;&amp;ch&lt;=<span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span><span style="color: #000000;">){
            cur</span>-&gt;value =<span style="color: #000000;"> ch;
            cur </span>= cur-&gt;<span style="color: #000000;">parent;
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(ch==<span style="color: #800000;">'</span><span style="color: #800000;">)</span><span style="color: #800000;">'</span><span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(cur-&gt;parent) cur = cur-&gt;<span style="color: #000000;">parent;
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(ch==<span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span>||<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>||<span style="color: #800000;">'</span><span style="color: #800000;">x</span><span style="color: #800000;">'</span>||<span style="color: #800000;">'</span><span style="color: #800000;">/</span><span style="color: #800000;">'</span><span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(ch==<span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span>) cur-&gt;value = <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(ch==<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>) cur-&gt;value = <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(ch==<span style="color: #800000;">'</span><span style="color: #800000;">x</span><span style="color: #800000;">'</span>) cur-&gt;value = <span style="color: #800000;">'</span><span style="color: #800000;">x</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(ch==<span style="color: #800000;">'</span><span style="color: #800000;">/</span><span style="color: #800000;">'</span>) cur-&gt;value = <span style="color: #800000;">'</span><span style="color: #800000;">/</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            cur</span>-&gt;right = <span style="color: #0000ff;">new</span><span style="color: #000000;"> BSTNode;
            cur</span>-&gt;right-&gt;parent =<span style="color: #000000;"> cur;
            cur </span>= cur-&gt;<span style="color: #000000;">right;
            cur</span>-&gt;left = NULL;<span style="color: #008000;">//</span><span style="color: #008000;">赋初值很重要 </span>
            cur-&gt;right =<span style="color: #000000;"> NULL;
        }
        ch </span>= cin.<span style="color: #0000ff;">get</span><span style="color: #000000;">();
    }
    cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">中缀表达式：</span><span style="color: #800000;">"</span><span style="color: #000000;">;
    InOrder(cur);
    cout</span>&lt;&lt;<span style="color: #000000;">endl;
    cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">后缀表达式：</span><span style="color: #800000;">"</span><span style="color: #000000;">;
    PostOrder(cur);
    cout</span>&lt;&lt;<span style="color: #000000;">endl;
    cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">Answer = </span><span style="color: #800000;">"</span>&lt;&lt;ans&lt;&lt;<span style="color: #000000;">endl;
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}
</span><span style="color: #008000;">/*</span><span style="color: #008000;">----Test----
//注意测试数据需严格按照该标准来定，否则无法构建二叉树 
(3+(4x5))
(3-(4+(5x3)))
(3-(4-(5x(3-(4+5))))
</span><span style="color: #008000;">*/</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;">反思：</span></h2>
<p>　　逆波兰表达式进行一位数运算时，具有很大的优点，但涉及到多位数与小数的运算时，它使用起来需要一点技巧。因为转化为后缀表达式时，需要将数值和运算符存入同一个队列中，而如果是多位数与小数，则必须将数值转化为double型，而不能利用char型（一位数可以利用char型减去'0'的ASCII码），但是运算符是char型，这样就导致了同一个队列中要存入两种类型的元素。</p>
<p>　　有两种解决办法：第一种：（思路来源于《算法笔记》P249）将队列的基本类型定义为结构体类型；（如上述代码所示）</p>
<p>　　第二种：把运算符double化，即把运算符转为double型类型的数据与数值一道，存入同一个容器中，为了避免运算符的值与数值的值发生冲突，我们必须对数值的范围作出限制（如若我们规定+为99999999，那么所有进行计算的数值必须小于99999999），这样使得运算范围缩小，故不推荐。</p>]]></description></item><item><title>寻找第K大的数</title><link>http://www.cnblogs.com/icodes8238/archive/2020/01/30/12243155.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Thu, 30 Jan 2020 09:05:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/01/30/12243155.html</guid><description><![CDATA[<h1 style="text-align: center;"><span style="font-family: 楷体;">寻找第K大的数</span></h1>
<p style="text-align: center;">本随笔写于20200123</p>
<h2><span style="font-family: 楷体;">算法1：快速选择算法（quicksort）</span></h2>
<p><strong>算法描述：</strong>（建立在快速排序的基础上）[1]</p>
<p>1. Choose an element from the array as pivot, exchange the position of pivot and number at the end of the array.</p>
<p>2. The pivot can either be the end element or a random chosen element. A random chosen pivot can make the algorithm much possibly run in average case time.</p>
<p>3. Partition the array into 2 parts in which the numbers in left subarray is less than (or equal to) the pivot and the numbers in right subarray is greater than (or equal to) the pivot.</p>
<p>4. Exchange pivot (at the end of the array now) with the first element in the right part.</p>
<p>5. Compare k with length of the left subarray, say, len.</p>
<p>　　if k == len， then pivot is the target. (return pivot)</p>
<p>　　if k &lt; len, repeat from step 1 on the left subarray.</p>
<p>　　if k &gt; len, repeat from step 1 on the right subarray.</p>
<p>&nbsp;</p>
<p>time cost: average case O(n);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worst case O(n2)</p>
<p>&nbsp;</p>
<p><strong>代码实现（方便理解）：</strong></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('5b35f182-0daa-44c9-8654-55070fd9127e')"><img id="code_img_closed_5b35f182-0daa-44c9-8654-55070fd9127e" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_5b35f182-0daa-44c9-8654-55070fd9127e" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('5b35f182-0daa-44c9-8654-55070fd9127e',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_5b35f182-0daa-44c9-8654-55070fd9127e" class="cnblogs_code_hide">
<pre>#include&lt;iostream&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span> arr[<span style="color: #800080;">100</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> ans;
</span><span style="color: #0000ff;">int</span> findpivot(<span style="color: #0000ff;">int</span> left,<span style="color: #0000ff;">int</span><span style="color: #000000;"> right){
    </span><span style="color: #0000ff;">return</span> (left+right)/<span style="color: #800080;">2</span><span style="color: #000000;">;
}
</span><span style="color: #0000ff;">void</span> swap(<span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span><span style="color: #000000;"> b){
    </span><span style="color: #0000ff;">int</span> temp =<span style="color: #000000;"> arr[a];
    arr[a] </span>=<span style="color: #000000;"> arr[b];
    arr[b] </span>=<span style="color: #000000;"> temp;
}

</span><span style="color: #0000ff;">void</span> quickselect(<span style="color: #0000ff;">int</span> left,<span style="color: #0000ff;">int</span> right,<span style="color: #0000ff;">int</span><span style="color: #000000;"> k){
    </span><span style="color: #0000ff;">if</span>(left &gt;=<span style="color: #000000;"> right) {
        ans </span>=<span style="color: #000000;"> arr[right];
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    }
    </span><span style="color: #0000ff;">int</span> index =<span style="color: #000000;"> findpivot(left,right);
    </span><span style="color: #0000ff;">int</span> pivot =<span style="color: #000000;"> arr[index];
    swap(index,right);
    </span><span style="color: #0000ff;">int</span> lp =<span style="color: #000000;"> left;
    </span><span style="color: #0000ff;">int</span> rp =<span style="color: #000000;"> right;
    </span><span style="color: #0000ff;">while</span>(lp &lt;<span style="color: #000000;"> rp){
        </span><span style="color: #0000ff;">while</span>((lp &lt; rp) &amp;&amp; (arr[lp] &lt;= pivot)) lp++<span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span>((lp &lt; rp) &amp;&amp; (arr[rp] &gt;= pivot)) rp--<span style="color: #000000;">;
        swap(lp,rp);
    }
    swap(right,lp);
    index </span>=<span style="color: #000000;"> lp;
    </span><span style="color: #0000ff;">if</span>(k == index + <span style="color: #800080;">1</span>) ans =<span style="color: #000000;"> arr[index];
    </span><span style="color: #0000ff;">if</span>(k &lt; index + <span style="color: #800080;">1</span>) quickselect(left,index-<span style="color: #800080;">1</span><span style="color: #000000;">,k);
    </span><span style="color: #0000ff;">if</span>(k &gt; index + <span style="color: #800080;">1</span><span style="color: #000000;">) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">k = k - index - 1;</span>
        quickselect(index+<span style="color: #800080;">1</span><span style="color: #000000;">,right,k);
    }
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
    cin</span>&gt;&gt;<span style="color: #000000;">n;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++) cin&gt;&gt;<span style="color: #000000;">arr[i];
    quickselect(</span><span style="color: #800080;">0</span>,n-<span style="color: #800080;">1</span>,n/<span style="color: #800080;">2</span><span style="color: #000000;">);
    cout</span>&lt;&lt;ans&lt;&lt;<span style="color: #000000;">endl;
    
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><strong>改进版（思路更清晰）：</strong></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('069b3558-1c3d-4177-92c6-04eb8f0d7a48')"><img id="code_img_closed_069b3558-1c3d-4177-92c6-04eb8f0d7a48" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_069b3558-1c3d-4177-92c6-04eb8f0d7a48" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('069b3558-1c3d-4177-92c6-04eb8f0d7a48',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_069b3558-1c3d-4177-92c6-04eb8f0d7a48" class="cnblogs_code_hide">
<pre>#include&lt;iostream&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span> arr[<span style="color: #800080;">100</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span> findpivot(<span style="color: #0000ff;">int</span> left,<span style="color: #0000ff;">int</span><span style="color: #000000;"> right){
    </span><span style="color: #0000ff;">return</span> (left+right)/<span style="color: #800080;">2</span><span style="color: #000000;">;
}
</span><span style="color: #0000ff;">void</span> swap(<span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span><span style="color: #000000;"> b){
    </span><span style="color: #0000ff;">int</span> temp =<span style="color: #000000;"> arr[a];
    arr[a] </span>=<span style="color: #000000;"> arr[b];
    arr[b] </span>=<span style="color: #000000;"> temp;
}

</span><span style="color: #0000ff;">int</span> quickselect(<span style="color: #0000ff;">int</span> left,<span style="color: #0000ff;">int</span> right,<span style="color: #0000ff;">int</span><span style="color: #000000;"> k){
    </span><span style="color: #008000;">//</span><span style="color: #008000;">if(left &gt;= right) return arr[right];</span>
    <span style="color: #0000ff;">int</span> index =<span style="color: #000000;"> findpivot(left,right);
    </span><span style="color: #0000ff;">int</span> pivot =<span style="color: #000000;"> arr[index];
    swap(index,right);
    </span><span style="color: #0000ff;">int</span> lp =<span style="color: #000000;"> left;
    </span><span style="color: #0000ff;">int</span> rp =<span style="color: #000000;"> right;
    </span><span style="color: #0000ff;">while</span>(lp &lt;<span style="color: #000000;"> rp){
        </span><span style="color: #0000ff;">while</span>((lp &lt; rp) &amp;&amp; (arr[lp] &lt;= pivot)) lp++<span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span>((lp &lt; rp) &amp;&amp; (arr[rp] &gt;= pivot)) rp--<span style="color: #000000;">;
        swap(lp,rp);
    }
    swap(right,lp);
    index </span>=<span style="color: #000000;"> lp;
    </span><span style="color: #0000ff;">if</span>(k == index + <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> arr[index];
    </span><span style="color: #0000ff;">if</span>(k &lt; index + <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> quickselect(left,index-<span style="color: #800080;">1</span><span style="color: #000000;">,k);
    </span><span style="color: #0000ff;">if</span>(k &gt; index + <span style="color: #800080;">1</span><span style="color: #000000;">) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">k = k - index - 1;</span>
        <span style="color: #0000ff;">return</span> quickselect(index+<span style="color: #800080;">1</span><span style="color: #000000;">,right,k);
    }
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
    cin</span>&gt;&gt;<span style="color: #000000;">n;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++) cin&gt;&gt;<span style="color: #000000;">arr[i];
    
    cout</span>&lt;&lt;quickselect(<span style="color: #800080;">0</span>,n-<span style="color: #800080;">1</span>,n/<span style="color: #800080;">2</span>)&lt;&lt;<span style="color: #000000;">endl;
    
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;">算法2：BFPRT算法（Median of medians）</span></h2>
<p>在快速选择（算法1）的基础上，对pivot选择采取中位数的中位数方法，就能把最坏时间复杂度降到O(n)。选取的过程就是把所有的数等分成很多小段，然后求所有小段的中间值。构成一个由所有中间值组成的段，然后再取中间值，作为划分元素。即中间值的中间值作为划分元素。取中间值可以先任选一种排序方法排序之后选择，因为每一小段的长度很短，不是影响复杂度的主要因素；取中间值的中间值，利用递归的方法调用自身即可。</p>
<p>&nbsp;</p>
<p><strong>算法描述：</strong>[2]</p>
<p>1. 首先把数组按5个数为一组进行分组，最后不足5个的忽略。对每组数进行排序（如插入排序）求取其中位数。</p>
<p>2. 把上一步的所有中位数移到数组的前面，对这些中位数递归调用BFPRT算法求得他们的中位数。</p>
<p>3. 将上一步得到的中位数作为划分的主元进行整个数组的划分。</p>
<p>4. 判断第k个数在划分结果的左边、右边还是恰好是划分结果本身，前两者递归处理，后者直接返回答案。</p>
<p>&nbsp;</p>
<p><strong>代码实现：</strong></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('ae898314-8ee8-4a4e-bbba-4863b1013ac8')"><img id="code_img_closed_ae898314-8ee8-4a4e-bbba-4863b1013ac8" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_ae898314-8ee8-4a4e-bbba-4863b1013ac8" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('ae898314-8ee8-4a4e-bbba-4863b1013ac8',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_ae898314-8ee8-4a4e-bbba-4863b1013ac8" class="cnblogs_code_hide">
<pre>#include&lt;iostream&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span> arr[<span style="color: #800080;">100</span><span style="color: #000000;">];

</span><span style="color: #0000ff;">void</span> swap(<span style="color: #0000ff;">int</span>* swarr,<span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span><span style="color: #000000;"> b){
    </span><span style="color: #0000ff;">int</span> temp =<span style="color: #000000;"> swarr[a];
    swarr[a] </span>=<span style="color: #000000;"> swarr[b];
    swarr[b] </span>=<span style="color: #000000;"> temp;
}
</span><span style="color: #0000ff;">void</span> insert_sort(<span style="color: #0000ff;">int</span>* sarr,<span style="color: #0000ff;">int</span><span style="color: #000000;"> n){
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;n;i++<span style="color: #000000;">){  
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=i;j&gt;<span style="color: #800080;">0</span>&amp;&amp;(sarr[j]&lt;sarr[j-<span style="color: #800080;">1</span>]);j--<span style="color: #000000;">){
            swap(sarr,j,j</span>-<span style="color: #800080;">1</span><span style="color: #000000;">);     
        }
    }
}
</span><span style="color: #0000ff;">int</span> midOfmid(<span style="color: #0000ff;">int</span> *midarr,<span style="color: #0000ff;">int</span> left,<span style="color: #0000ff;">int</span><span style="color: #000000;"> right){
    </span><span style="color: #0000ff;">int</span> tarr[<span style="color: #800080;">10</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=left;i&lt;=right;i++) tarr[k++] =<span style="color: #000000;"> midarr[i];
    insert_sort(tarr,k);
    </span><span style="color: #0000ff;">return</span> tarr[k/<span style="color: #800080;">2</span><span style="color: #000000;">];
}
</span><span style="color: #0000ff;">int</span> findpivot(<span style="color: #0000ff;">int</span> left,<span style="color: #0000ff;">int</span><span style="color: #000000;"> right){
    </span><span style="color: #0000ff;">int</span> findarr[<span style="color: #800080;">20</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">int</span> m = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span>(right - left &lt; <span style="color: #800080;">4</span>) findarr[m++] =<span style="color: #000000;"> midOfmid(arr,left,right);
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = left;i&lt;=right;i+=<span style="color: #800080;">5</span><span style="color: #000000;">)
        findarr[m</span>++] = midOfmid(arr,i,i+<span style="color: #800080;">4</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">return</span> midOfmid(findarr,<span style="color: #800080;">0</span>,m-<span style="color: #800080;">1</span><span style="color: #000000;">);
}
</span><span style="color: #0000ff;">int</span> lookindex(<span style="color: #0000ff;">int</span> d){ <span style="color: #008000;">//</span><span style="color: #008000;">寻找pivot的下标，pivot的重复虽然对下标有影响，但对划分无影响 </span>
    <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;<span style="color: #800080;">100</span>;i++<span style="color: #000000;">)
        </span><span style="color: #0000ff;">if</span>(arr[i]==<span style="color: #000000;">d)
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
}
</span><span style="color: #0000ff;">int</span> quickselect(<span style="color: #0000ff;">int</span> left,<span style="color: #0000ff;">int</span> right,<span style="color: #0000ff;">int</span><span style="color: #000000;"> k){
    </span><span style="color: #0000ff;">int</span> pivot =<span style="color: #000000;"> findpivot(left,right);
    </span><span style="color: #0000ff;">int</span> index =<span style="color: #000000;"> lookindex(pivot);
    </span><span style="color: #008000;">//</span><span style="color: #008000;">cout&lt;&lt;index&lt;&lt;" "&lt;&lt;pivot&lt;&lt;endl;</span>
<span style="color: #000000;">    swap(arr,index,right);
    </span><span style="color: #0000ff;">int</span> lp =<span style="color: #000000;"> left;
    </span><span style="color: #0000ff;">int</span> rp =<span style="color: #000000;"> right;
    </span><span style="color: #0000ff;">while</span>(lp &lt;<span style="color: #000000;"> rp){
        </span><span style="color: #0000ff;">while</span>((lp &lt; rp) &amp;&amp; (arr[lp] &lt;= pivot)) lp++<span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span>((lp &lt; rp) &amp;&amp; (arr[rp] &gt;= pivot)) rp--<span style="color: #000000;">;
        swap(arr,lp,rp);
    }
    swap(arr,right,lp);
    index </span>=<span style="color: #000000;"> lp;
    </span><span style="color: #0000ff;">if</span>(k == index + <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> arr[index];
    </span><span style="color: #0000ff;">if</span>(k &lt; index + <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> quickselect(left,index-<span style="color: #800080;">1</span><span style="color: #000000;">,k);
    </span><span style="color: #0000ff;">if</span>(k &gt; index + <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> quickselect(index+<span style="color: #800080;">1</span><span style="color: #000000;">,right,k);
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
    cin</span>&gt;&gt;<span style="color: #000000;">n;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++) cin&gt;&gt;<span style="color: #000000;">arr[i];
    cout</span>&lt;&lt;quickselect(<span style="color: #800080;">0</span>,n-<span style="color: #800080;">1</span>,n/<span style="color: #800080;">2</span>)&lt;&lt;<span style="color: #000000;">endl;
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p><strong>time cost :</strong> Worst case O(n)</p>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;">练习题目：</span></h2>
<p><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/">https://leetcode.com/problems/kth-largest-element-in-an-array/description/</a></p>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;">Reference&nbsp;:&nbsp;</span></h2>
<p>[1]快速选择算法描述：<a href="https://www.jianshu.com/p/52f90fe2b141" target="_blank">https://www.jianshu.com/p/52f90fe2b141</a></p>
<p>[2]BFPRT算法描述：<a href="https://www.cnblogs.com/informatics/p/5092741.html">https://www.cnblogs.com/informatics/p/5092741.html</a></p>]]></description></item><item><title>最长子序列和问题</title><link>http://www.cnblogs.com/icodes8238/archive/2020/01/30/12243120.html</link><dc:creator>icodes</dc:creator><author>icodes</author><pubDate>Thu, 30 Jan 2020 08:52:00 GMT</pubDate><guid>http://www.cnblogs.com/icodes8238/archive/2020/01/30/12243120.html</guid><description><![CDATA[<h1 style="text-align: center;"><span style="font-family: 楷体; font-size: 18pt;">最长子序列和问题</span></h1>
<p style="text-align: center;"><span style="font-family: 楷体; font-size: 12px;">本随笔写于20200121</span></p>
<p style="text-align: left;"><strong><span style="font-family: 宋体; font-size: 12px;">问题描述：</span></strong></p>
<p style="text-align: left;"><span style="font-family: 宋体; font-size: 12px;"><img src="https://img2018.cnblogs.com/common/1726496/202001/1726496-20200130165838780-514149866.png" alt="" /></span></p>
<h2><span style="font-family: 楷体;">算法1：枚举法</span></h2>
<p><strong>算法描述：</strong>以2 -3 -4 13 -5 2 -5 -3 12 -9 为例，分别计算以2，-3，-4&hellip;，-9开头的所有子序列和，如果新子序列的和大于当前最大值，则用新子序列的和替代当前最大值。最长序列的下标的更新就发生在最大值的更新过程中。</p>
<p>&nbsp;</p>
<p><strong>time cost :</strong>&nbsp;枚举左端点和右端点，需要O(n2)的复杂度；根据计算新子序列之和的方式，总复杂度不一样：</p>
<p>　　　　(a)&nbsp;计算新子序列之和方式为 从新子序列头加到尾，计算复杂度为O(n)，总时间复杂度为O(n3);</p>
<p>　　　　(b)&nbsp;计算新子序列之和方式为 新子序列和 =&nbsp;旧子序列和 +&nbsp;新增加的元素 -&nbsp;新减少的元素，计算时间复杂度为O(1)，总时间复杂度为O(n2)</p>
<p>&nbsp;</p>
<p><strong>代码实现：</strong></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('bc7da09e-b12e-4023-8ba1-2b649ef0243c')"><img id="code_img_closed_bc7da09e-b12e-4023-8ba1-2b649ef0243c" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_bc7da09e-b12e-4023-8ba1-2b649ef0243c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('bc7da09e-b12e-4023-8ba1-2b649ef0243c',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_bc7da09e-b12e-4023-8ba1-2b649ef0243c" class="cnblogs_code_hide">
<pre>#include&lt;iostream&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span> maxm,a[<span style="color: #800080;">100</span><span style="color: #000000;">],sum;
</span><span style="color: #0000ff;">int</span> start,end;<span style="color: #008000;">//</span><span style="color: #008000;"> record the index of the subsequence</span>
<span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
    cin</span>&gt;&gt;<span style="color: #000000;">n;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++) cin&gt;&gt;<span style="color: #000000;">a[i];
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">){
        sum </span>=<span style="color: #000000;"> a[i];
        </span><span style="color: #0000ff;">if</span>(sum &gt;<span style="color: #000000;"> maxm) {
            maxm </span>=<span style="color: #000000;"> sum;
            start </span>=<span style="color: #000000;"> i;
            end </span>=<span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=i+<span style="color: #800080;">1</span>;j&lt;n;j++<span style="color: #000000;">){
            sum </span>+=<span style="color: #000000;"> a[j];
            </span><span style="color: #0000ff;">if</span>(sum &gt;<span style="color: #000000;"> maxm) {
                maxm </span>=<span style="color: #000000;"> sum;
                start </span>=<span style="color: #000000;"> i;
                end </span>=<span style="color: #000000;"> j;
            }
        }
    }
    cout</span>&lt;&lt;maxm&lt;&lt;<span style="color: #000000;">endl;
    cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">from </span><span style="color: #800000;">"</span>&lt;&lt;start&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;"> to </span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">end;
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;">算法2：动态规划</span></h2>
<p><strong>算法描述：</strong>用变量sum记录当前子序列累加和，用maxm记录最大值。</p>
<p>从头开始进行累加，如果sum&gt;max，则max = sum；如果sum&lt;0，则将sum置0。</p>
<p>最长序列尾端下标的更新，发生在最大值更新过程中；</p>
<p>最长序列前端下标的更新，发生在第一个非负数时，因此下标为sum&lt;0时的下标加一。</p>
<p>&nbsp;</p>
<p><strong>理解：</strong>最长子序列和的子序列肯定以正数开头，所以如果sum是负数，不妨将其设为0，等待下一个正数的到来。</p>
<p>&nbsp;</p>
<p><strong>time cost :</strong> O(n) （从头到尾只进行了一次扫描）</p>
<p>&nbsp;</p>
<p><strong>代码实现：</strong></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('d04478bc-8daf-4b6c-be0b-909f5ef96a16')"><img id="code_img_closed_d04478bc-8daf-4b6c-be0b-909f5ef96a16" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_d04478bc-8daf-4b6c-be0b-909f5ef96a16" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('d04478bc-8daf-4b6c-be0b-909f5ef96a16',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_d04478bc-8daf-4b6c-be0b-909f5ef96a16" class="cnblogs_code_hide">
<pre>#include&lt;iostream&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span> maxm,a[<span style="color: #800080;">100</span><span style="color: #000000;">],sum;
</span><span style="color: #0000ff;">int</span> start,end;<span style="color: #008000;">//</span><span style="color: #008000;"> record the index of the subsequence</span>
<span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
    cin</span>&gt;&gt;<span style="color: #000000;">n;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++) cin&gt;&gt;<span style="color: #000000;">a[i];
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">){
        sum </span>+=<span style="color: #000000;"> a[i];
        </span><span style="color: #0000ff;">if</span>(sum &gt;<span style="color: #000000;"> maxm) {
            maxm </span>=<span style="color: #000000;"> sum;
            end </span>=<span style="color: #000000;"> i; 
        } 
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(sum &lt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
            sum </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            start </span>= i+<span style="color: #800080;">1</span><span style="color: #000000;">;
        }
    }
    cout</span>&lt;&lt;maxm&lt;&lt;<span style="color: #000000;">endl;
    cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">from </span><span style="color: #800000;">"</span>&lt;&lt;start&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;"> to </span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">end;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p>&nbsp;<strong>另一种算法描述</strong>（更容易理解）：见《算法笔记》P430；<strong>状态的无后效性</strong>&nbsp;：P431</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;">算法3：分治法（递归）</span></h2>
<p>分治算法的核心是把问题分成两个大致相等的子问题，然后递归对它们求解，这是&ldquo;分&rdquo;的部分，在&ldquo;治&rdquo;这一阶段将两个子问题的解合并到一起求解。</p>
<p><strong>算法描述：</strong>把数组分割成两部分，左半部分和右半部分，最大子序列出现的位置可能在：左半部、右半部、跨越分割的位置占据左右半部。</p>
<p>对于横跨整个序列的情况，我们采用以下方法：从中间开始，分别向左、向右遍历，分别得到向左、向右遍历的最大值，将这两个最大值相加得到跨越分割的位置占据左右半部的最大值，再与左半部、右半部的最大值比较，找到三者中的最大值，即为整个序列的最大值。<sup>[2]</sup></p>
<p>&nbsp;</p>
<p><strong>代码实现：</strong><a href="file:///D:/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%EF%BC%88%E5%88%86%E6%B2%BB%E6%B3%95%EF%BC%89.cpp"><br /></a></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('40ae7808-962e-49d2-8cad-60e411fbdfa0')"><img id="code_img_closed_40ae7808-962e-49d2-8cad-60e411fbdfa0" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_40ae7808-962e-49d2-8cad-60e411fbdfa0" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('40ae7808-962e-49d2-8cad-60e411fbdfa0',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_40ae7808-962e-49d2-8cad-60e411fbdfa0" class="cnblogs_code_hide">
<pre>#include&lt;iostream&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

</span><span style="color: #0000ff;">int</span> a[<span style="color: #800080;">100</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> ans,start,end,state;
</span><span style="color: #0000ff;">int</span> maxm(<span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span> b,<span style="color: #0000ff;">int</span><span style="color: #000000;"> c){
    </span><span style="color: #0000ff;">if</span>(a&gt;b &amp;&amp; a&gt;c)  <span style="color: #0000ff;">return</span><span style="color: #000000;"> a;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(b&gt;a &amp;&amp; b&gt;c) <span style="color: #0000ff;">return</span><span style="color: #000000;"> b;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(c&gt;a &amp;&amp; c&gt;b) <span style="color: #0000ff;">return</span><span style="color: #000000;"> c;
}

</span><span style="color: #0000ff;">int</span> merge(<span style="color: #0000ff;">int</span> left,<span style="color: #0000ff;">int</span><span style="color: #000000;"> right){
    </span><span style="color: #0000ff;">if</span>(left == right) <span style="color: #0000ff;">return</span><span style="color: #000000;"> a[left];
    </span><span style="color: #0000ff;">int</span> mid = (left+right) / <span style="color: #800080;">2</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">int</span> t1 =<span style="color: #000000;"> merge(left,mid);
    </span><span style="color: #0000ff;">int</span> t2 = merge(mid+<span style="color: #800080;">1</span><span style="color: #000000;">,right);
    </span><span style="color: #0000ff;">int</span> suml = <span style="color: #800080;">0</span>; <span style="color: #0000ff;">int</span> sumr = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">int</span> maxl = <span style="color: #800080;">0</span>; <span style="color: #0000ff;">int</span> maxr = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=mid;i&gt;=left;i--<span style="color: #000000;">){
        suml </span>+=<span style="color: #000000;"> a[i];
        </span><span style="color: #0000ff;">if</span>(suml &gt;<span style="color: #000000;"> maxl) {
            maxl </span>=<span style="color: #000000;"> suml;
            start </span>=<span style="color: #000000;"> i;
        }
    }
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = mid+<span style="color: #800080;">1</span>;i&lt;=right;i++<span style="color: #000000;">){
        sumr </span>+=<span style="color: #000000;"> a[i];
        </span><span style="color: #0000ff;">if</span>(sumr &gt;<span style="color: #000000;"> maxr) {
            maxr </span>=<span style="color: #000000;"> sumr;
            end </span>=<span style="color: #000000;"> i;
        }        
    }
    </span><span style="color: #0000ff;">return</span> maxm(t1,t2,maxl+<span style="color: #000000;">maxr);
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
    cin</span>&gt;&gt;<span style="color: #000000;">n;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i =<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">){
        cin</span>&gt;&gt;<span style="color: #000000;">a[i];
    }
    ans </span>= merge(<span style="color: #800080;">0</span>,n-<span style="color: #800080;">1</span><span style="color: #000000;">);
    cout</span>&lt;&lt;ans&lt;&lt;<span style="color: #000000;">endl;
    cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">from </span><span style="color: #800000;">"</span>&lt;&lt;start&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;"> to </span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">end;
    
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p>&nbsp;<strong>time cost :</strong>&nbsp;O(nlogn)</p>
<p>&nbsp;</p>
<p><strong>测试数据 :</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">test1</span>
<span style="color: #800080;">10</span>
<span style="color: #800080;">2</span> -<span style="color: #800080;">3</span> -<span style="color: #800080;">4</span> <span style="color: #800080;">13</span> -<span style="color: #800080;">5</span> <span style="color: #800080;">2</span> -<span style="color: #800080;">5</span> -<span style="color: #800080;">3</span> <span style="color: #800080;">12</span> -<span style="color: #800080;">9</span>
<span style="color: #008000;">//</span><span style="color: #008000;">test2</span>
<span style="color: #800080;">6</span>
-<span style="color: #800080;">2</span> <span style="color: #800080;">11</span> -<span style="color: #800080;">4</span> <span style="color: #800080;">13</span> -<span style="color: #800080;">5</span> -<span style="color: #800080;">2</span>
<span style="color: #008000;">//</span><span style="color: #008000;">test3</span>
<span style="color: #800080;">8</span>
<span style="color: #800080;">2</span> -<span style="color: #800080;">3</span> -<span style="color: #800080;">4</span> <span style="color: #800080;">13</span> -<span style="color: #800080;">5</span> <span style="color: #800080;">2</span> -<span style="color: #800080;">5</span> <span style="color: #800080;">12</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>如何理解递归？</strong><sup>[3]</sup></p>
<p>看递归程序不要老想着它是怎么执行的，没必要看成&ldquo;不停调用函数&rdquo;。基本原理同数学归纳法。</p>
<p>递归程序理解两点：</p>
<p>1.只要假设第一句求出了前半段的最大子序列和，第二句求出了后半段的，而下面的合并过程在上面假设的基础上能正确执行。</p>
<p>2.终止条件，并且终止处是满足上面假设的。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;">练习题目：</span></h2>
<p><a href="http://codeup.cn/problem.php?cid=100000626&amp;pid=0" target="_blank">http://codeup.cn/problem.php?cid=100000626&amp;pid=0</a></p>
<p>&nbsp;</p>
<h2><span style="font-family: 楷体;">Reference:</span></h2>
<p>[1]《算法笔记》胡凡 P430-431</p>
<p>[2]&nbsp;分治法算法思想：<a href="https://www.jianshu.com/p/c4d68d0376ad" target="_blank">https://www.jianshu.com/p/c4d68d0376ad</a></p>
<p>[3]&nbsp;如何理解递归：<a href="https://bbs.csdn.net/topics/300115494?locationNum=8&amp;fps=1" target="_blank">https://bbs.csdn.net/topics/300115494?locationNum=8&amp;fps=1</a></p>
<p>&nbsp;</p>]]></description></item></channel></rss>